<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>xinqiyang notes</title>
  
  <subtitle>Nothing behind me, everything ahead of me,as is ever so on the road.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yangxinqi.com/"/>
  <updated>2021-04-20T16:36:38.507Z</updated>
  <id>http://yangxinqi.com/</id>
  
  <author>
    <name>xinqiyang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>BSC基础服务GAS Price Service实现</title>
    <link href="http://yangxinqi.com/2021/04/21/BSC-GAS-Service%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yangxinqi.com/2021/04/21/BSC-GAS-Service实现/</id>
    <published>2021-04-20T16:01:34.000Z</published>
    <updated>2021-04-20T16:36:38.507Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Apr 21 2021 01:36:52 GMT+0900 (Japan Standard Time) --><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>“老板说，小杨，现在的ETH的Gas太贵了，把现在的合约业务都切换到BSC上吧。”， 小杨 – “ 收到，老板” 。。。。。。</p><p>开始了连续几周的加班中， 最近在用Metamask钱包上，对应BSC，然后开始修改合约，修改钱包，修改DAPP，俨然重来一遍啊。</p><p>本次记录下一些过程，修正BSC下的wallet的币种的价格，修复BSC下的GasPrice 获取服务，本次主要讲解Gas Price的获取, ETH的Gas价格是 BSC 的180x ，大家都切换到BSC吧，一样玩的很hi啊。</p><p><img src="/images/bscgasprice/1.png" alt="BSC Gas Price Service"></p><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>先讲结果， 通过将钱包的默认Gas价格服务修改到自己搭建的节点上，省下了180x的Gas，虽然没几个币，但是总量算起来还是蛮多的，所以有必要花时间来处理下.</p><p>Metamask ETH Gas Price: (单位Gwei)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">curl https://api.metaswap.codefi.network/gasPrices</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"SafeGasPrice"</span>: <span class="string">"227"</span>,</span><br><span class="line">  <span class="string">"ProposeGasPrice"</span>: <span class="string">"257"</span>,</span><br><span class="line">  <span class="string">"FastGasPrice"</span>: <span class="string">"282"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CoinPhD BSC Gas Price: (单位Gwei)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">curl https://coinphd.com/api/bscgasprice</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"health"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">"block_number"</span>: 6735170,</span><br><span class="line">  <span class="string">"SafeGasPrice"</span>: 5.0,</span><br><span class="line">  <span class="string">"ProposeGasPrice"</span>: 5.0,</span><br><span class="line">  <span class="string">"FastGasPrice"</span>: 6.241,</span><br><span class="line">  <span class="string">"InstantGasPrice"</span>: 150.0,</span><br><span class="line">  <span class="string">"block_time"</span>: 3.857</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从返回的结果来看，ETH 的Gas价格是BSC的 227/5 x 4 = <strong>190 X </strong>, 在ETH上做操作的人，都是贼有钱。。。。。。</p><h4 id="强烈推荐大家都来BSC上来玩"><a href="#强烈推荐大家都来BSC上来玩" class="headerlink" title="强烈推荐大家都来BSC上来玩"></a><strong>强烈推荐大家都来BSC上来玩</strong></h4><p>在Metamask上，使用修改过的Gas Price服务，看到Gas费用基本可以忽略了。</p><p><img src="/images/bscgasprice/2.png" alt="Metamask BSC Gas Price Service"></p><p>在对BSC的tx进行分析后发现， 土豪很多，7000+ Gwei的gas也大有人在，看到最大的 42538.538， 所以在BSC上争抢交易的事情也在发生，接下来会在写一篇关于BSC上使用gas的土豪分析的文章。</p><p><img src="/images/bscgasprice/3.png" alt="BSC Gas Max / AVG "></p><p>想想还是把Gas Price服务开源吧，都是学习的过程，进来留在Github上，希望对大家有帮助。</p><p>访问： <a href="https://github.com/xinqiyang/bscgasprice" target="_blank" rel="noopener">https://github.com/xinqiyang/bscgasprice</a> 下载最新的源码</p><p>实现用Python + Web3 实现的，实现了重连和同时获取多个备用节点的国内，BSC提供了3个主节点，但是第三个连不上，目前2个可用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/xinqiyang/bscgasprice</span><br><span class="line"><span class="comment"># docker 对外提供服务 0.0.0.0:6669 提供gas price service</span></span><br><span class="line">docker-compose up -d --build</span><br></pre></td></tr></table></figure><p>核心代码：</p><p>拿到web3的实例，然后需要设定 poa middleware 之后即可去连BSC了， 在轮询获取 last block 并统计 tx.gasPrice 进行计算，得出gas price的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">    localw3 = web3_instance()</span><br><span class="line">    localw3.middleware_onion.inject(geth_poa_middleware, layer=<span class="number">0</span>)</span><br><span class="line">    <span class="comment"># print(localw3.clientVersion)</span></span><br><span class="line">    latest = localw3.eth.filter(<span class="string">'latest'</span>)</span><br><span class="line">    <span class="comment"># print('worker:', latest)</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> skip_warmup <span class="keyword">and</span> <span class="keyword">not</span> block_times:</span><br><span class="line">        warmup()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">for</span> n <span class="keyword">in</span> latest.get_new_entries():</span><br><span class="line">                process_block(localw3, n)</span><br><span class="line">                log.info(str(stats))</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> localw3.eth.syncing:</span><br><span class="line">                stats[<span class="string">'health'</span>] = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            sleep(<span class="number">5</span>)</span><br><span class="line">            localw3 = web3_instance()</span><br><span class="line">            latest = localw3.eth.filter(<span class="string">'latest'</span>)</span><br><span class="line">            log.warning(<span class="string">"do reconnect ------- &#123;&#125; &#123;&#125; &#123;&#125;"</span>.format(int(time.time()), str(localw3), str(latest)))</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        sleep(<span class="number">2</span>)</span><br><span class="line">       </span><br><span class="line">      </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_block</span><span class="params">(w3i, n)</span>:</span></span><br><span class="line">    block = w3i.eth.getBlock(n, <span class="keyword">True</span>)</span><br><span class="line">    stats[<span class="string">'block_number'</span>] = block.number</span><br><span class="line"></span><br><span class="line">    block_times.append(block.timestamp)</span><br><span class="line">    <span class="keyword">if</span> len(block_times) &gt; <span class="number">1</span>:</span><br><span class="line">        t = sorted(block_times)</span><br><span class="line">        stats[<span class="string">'block_time'</span>] = round(mean(b - a <span class="keyword">for</span> a, b <span class="keyword">in</span> zip(t, t[<span class="number">1</span>:])), <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> block.transactions:</span><br><span class="line">        prices = []</span><br><span class="line">        <span class="keyword">for</span> tx <span class="keyword">in</span> block.transactions:</span><br><span class="line">            <span class="keyword">if</span> int(tx.gasPrice) &gt; <span class="number">0</span>:</span><br><span class="line">                prices.append(tx.gasPrice)</span><br><span class="line">        blocks_gwei.append(min(prices))</span><br><span class="line">        data = pd.Series(blocks_gwei)</span><br><span class="line">        <span class="keyword">for</span> name, q <span class="keyword">in</span> QUANTILES.items():</span><br><span class="line">            <span class="keyword">if</span> name <span class="keyword">in</span> [<span class="string">'FastGasPrice'</span>]:</span><br><span class="line">                stats[name] = round(float(w3i.fromWei(average(prices), <span class="string">'gwei'</span>)), <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">elif</span> name <span class="keyword">in</span> [<span class="string">'InstantGasPrice'</span>]:</span><br><span class="line">                stats[name] = round(float(w3i.fromWei(max(prices), <span class="string">'gwei'</span>)), <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                price = data.quantile(q / <span class="number">100</span>)</span><br><span class="line">                stats[name] = round(float(w3i.fromWei(price, <span class="string">'gwei'</span>)), <span class="number">3</span>)</span><br><span class="line">    print(stats)</span><br><span class="line">    <span class="keyword">return</span> block</span><br></pre></td></tr></table></figure><p>其实比较简单，就是网络有时候有问题， 需要重连，这个地方搞了2个小时，后面只能exception的时候，重新去创建web3连接。</p><p><img src="/images/bscgasprice/4.png" alt="BSC Gas Price Service"></p><p>这个是跑起来的服务器的日志，发现连接次数太多，会被block一段时间，所以需要增加timeout。</p><p>返回的json，针对Metamask的格式进行优化过了，欢迎大家使用。</p><p>如果不想大家自己的GasPrice服务节点，可以使用CoinPhD BSC Gas Price Service :</p><p><a href="https://coinphd.com/api/bscgasprice" target="_blank" rel="noopener">https://coinphd.com/api/bscgasprice</a></p><p>这个api我会一直维护下去。</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>提供免费的服务给大家，是CoinPhD接下来的方向，DEFI很有意思，BSC比起ETH来，确实更适合国人来用。</p><p>Gas Price只是简单的服务，但是之前不注意，还是相当贵的，所以BSC在基础服务上还是需要继续完善啊。</p><p>CoinPhD要复活了，接下来多开源一些有用的服务，为DEFI继续搬砖。。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Apr 21 2021 01:36:52 GMT+0900 (Japan Standard Time) --&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h
      
    
    </summary>
    
      <category term="blockchain" scheme="http://yangxinqi.com/categories/blockchain/"/>
    
    
      <category term="BSC" scheme="http://yangxinqi.com/tags/BSC/"/>
    
  </entry>
  
  <entry>
    <title>迁移服务到飞书</title>
    <link href="http://yangxinqi.com/2021/04/06/%E8%BF%81%E7%A7%BB%E6%9C%8D%E5%8A%A1%E5%88%B0%E9%A3%9E%E4%B9%A6/"/>
    <id>http://yangxinqi.com/2021/04/06/迁移服务到飞书/</id>
    <published>2021-04-06T13:41:32.000Z</published>
    <updated>2021-04-06T13:51:09.620Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Apr 21 2021 01:32:54 GMT+0900 (Japan Standard Time) --><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>“当你想放弃的时候，想想你为什么开始” – 埃隆·马斯克 。</p><p>名人总是可以用自己的身体力行，来表示优越感。</p><p>可是有的时候，我就想做我自己。 弄个自己的域名，写自己的想写的东西，算是记录自己活着的过程，当感到孤独的时候，写写博客，自己和自己对话，就有一个人陪你说话了，这个人可能是过去的自己，也可能是未来的自己， 总之，有个人无条件的陪你，这样就足够了。</p><h3 id="飞书体验"><a href="#飞书体验" class="headerlink" title="飞书体验"></a>飞书体验</h3><p>最近把项目管理工具都迁移到飞书了， 从最早的JINA，到后面的github，到现在的飞书，确实感觉飞书还是很好用的。</p><p>但是他们的运营人员，老是会打电话，在日本，我们也不接电话了。</p><p>最赞的是，他们的插件式的服务，这块有很多好的app可以集成进来，还有就是很好的邮件服务。</p><p>对于腾讯邮箱，网易邮箱，还有mailgun邮箱，还有gmo邮箱，还有godday的服务，最后还是回到了飞书，虽然他们不能及时的获取邮件推送，但是能够收发，就已经很赞了。</p><p>还有板栗看板，还有视频会议和云文档，这些都相当的好用，好用的东西用过之后，才知道。 。。。。</p><h3 id="总计"><a href="#总计" class="headerlink" title="总计"></a>总计</h3><p>飞书真的好， 可以推荐给大家。 。。。<br>字节的产品做的还是很不错的，赞下。<br>弄个自己域名的邮箱，以后可以直接联系我： me@yangxinqi.com 感觉比较有逼格，😄</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Apr 21 2021 01:32:54 GMT+0900 (Japan Standard Time) --&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h
      
    
    </summary>
    
      <category term="others" scheme="http://yangxinqi.com/categories/others/"/>
    
    
      <category term="others" scheme="http://yangxinqi.com/tags/others/"/>
    
  </entry>
  
  <entry>
    <title>AU 10G宽带初步体验</title>
    <link href="http://yangxinqi.com/2021/03/16/AU-10G%E5%AE%BD%E5%B8%A6%E5%88%9D%E6%AD%A5%E4%BD%93%E9%AA%8C/"/>
    <id>http://yangxinqi.com/2021/03/16/AU-10G宽带初步体验/</id>
    <published>2021-03-16T13:13:03.000Z</published>
    <updated>2021-04-06T14:08:16.371Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Apr 21 2021 01:32:54 GMT+0900 (Japan Standard Time) --><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>AU 10G宽带拉上之后的初步体验<br>尝试新东西，是一贯的追求，但是从今年起，要践行够用就好的原则，把时间花在必须的地方，其实除了赚钱之外，还有很多有意义的事情，你可以去做，而且方法有很多，每个人都有自己的点，自己需要get到自己的点，其实最惨的就是盲目的努力，到最后都是徒劳。</p><p><img src="/images/au10g/au_10g.jpg" alt="AU 10G"></p><p>本次签约的是AU的10G光， 名字 auひかり ホーム10ギガ ，第一年每个月费用 5,610円 （1年目），看过去还是可以的。</p><h3 id="实际使用"><a href="#实际使用" class="headerlink" title="实际使用"></a>实际使用</h3><p>速度测试：<br>基本上传 100M/s 以上，最高的时候 120M/s ，这个速度相当不错了。<br>基本下载 50M/s 左右，下载比上传还慢，这个是日本网络的一大特色。</p><p>带宽限制：<br>每天最多30G的流量，超过了之后会被降速，这个也是可以理解的，但是做为常用的功能来看，还是足够的了。</p><p>SpeedTest的测试：<br><img src="/images/au10g/au_10g_2.png" alt="SpeedTest Server"><br><img src="/images/au10g/au_10g_3.png" alt="SpeedTest Wifi 5G"></p><p>通过服务器和Wifi 5G测试，看过去也都还行，对得起这个价格。</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>最后感觉10G，虽然速度很赞，但是流量限制比较鸡肋，家庭来用还是很足够的。<br>默认的AU的路由器，不开启无线模块，可以使用自己的路由器来开启，不需要他们自己带的路由器功能，这块对于小白，他们还是能够每个月多收几百块的费用的。 这个收费模式比较恶心倒是。<br>随着日本5G还有流量竞争的激烈，其实真心感觉，AU还是走在前面的，这个应该赞下。</p><p>最后</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Apr 21 2021 01:32:54 GMT+0900 (Japan Standard Time) --&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h
      
    
    </summary>
    
      <category term="others" scheme="http://yangxinqi.com/categories/others/"/>
    
    
      <category term="10G" scheme="http://yangxinqi.com/tags/10G/"/>
    
  </entry>
  
  <entry>
    <title>Line Blockchain解决方案介绍</title>
    <link href="http://yangxinqi.com/2021/01/04/Line-Blockchain%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%BB%8B%E7%BB%8D/"/>
    <id>http://yangxinqi.com/2021/01/04/Line-Blockchain解决方案介绍/</id>
    <published>2021-01-04T02:27:27.000Z</published>
    <updated>2021-01-04T03:38:25.505Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Apr 21 2021 01:32:54 GMT+0900 (Japan Standard Time) --><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>新年在家休整了2天后，开始继续奋战，在考虑phase 2的和区块链技术整合的阶段，看到日本的IM巨头，Line在Blockchain上做的solution。具体链接在这里 <a href="https://jp.techcrunch.com/2020/12/31/line-blockchain-developers-meetup-001-part01/" target="_blank" rel="noopener">https://jp.techcrunch.com/2020/12/31/line-blockchain-developers-meetup-001-part01/</a> ， 就翻译了下，和大家一起分享，也许未来区块链在日本真正的落地，还得依赖这些巨头，看最近中国的蚂蚁链，推广的也不错。</p><p>主要面向用户：</p><p>对区块链感兴趣的开发人员</p><p>考虑引入 LINE Blockchain 的公司</p><p>来介绍LINE区块链未来的发展。</p><p>本次文章由Line区块链开发工程团队经理 那須 利将 来发表。</p><h3 id="LINE区块链概述"><a href="#LINE区块链概述" class="headerlink" title="LINE区块链概述"></a>LINE区块链概述</h3><p>LINE区块链的口号是“为每个人设计的LINE区块链”。目的是将区块链技术纳入我们的日常生活。</p><p><img src="/images/lineblockchain/img1.jpg" alt="Line Blockchain history"></p><a id="more"></a><p>LINE于2018年4月成立了“ LINE Blockchain Lab”，并于7月在全球市场上开设了当前加密资产交易所“ BITFRONT”的前身“ BITBOX”。10月，加密资产“ LINK”被列出。2019年9月，加密资产交易所“ BITMAX”在日本开业，LINK于2020年8月在日本上市。同时，我们开始提供“ <a href="https://wallet.bitmax.me/" target="_blank" rel="noopener">BITMAX钱包</a>”和LINE区块链开发人员，并且在过去三年中，我们逐一发布了区块链服务和产品，以实现通证经济的概念。</p><p><img src="/images/lineblockchain/img2.jpg" alt="Line Blockchain history"></p><p>LINK（LN）是LINE最初发行的加密资产。在LINE服务中，预计用户会收到它作为贡献活动的奖励，并且由于服务的增长，通证经济将扩大，对LINK的需求也会增加。</p><p>用户已经获得激励的LINK，目前正在与LINE家庭服务和合作伙伴公司进行准备，以便可以在各种dApp和服务中使用。LINK已经可以通过BITMAX转换为合法货币，并且正在为通证经济做好准备。</p><p>为了扩大对加密资产LINK的使用，LINE还推出“ <a href="https://blockchain.line.me/ja/linkrewards/" target="_blank" rel="noopener">LINK Rewards Program</a> ”。LINK奖励计划是LINE代币经济的每个服务轻松参与的机制，简单来说，它是一种将加密资产LINK返还给服务用户的机制，就像各种常规点服务一样。</p><p>BITMAX钱包也可以作为用户接收LINK的入口。<strong>BITMAX钱包是一项钱包服务，可以管理在LINK和区块链上发行的数字资产。它具有一个LINE ID，旨在供任何LINE用户使用，以使<u>私钥不会被遗忘和丢失</u>。</strong></p><p>BITMAX钱包将是一项重要服务，它将成为8600万LINE用户访问区块链服务的网关。顺便说一下，它不同于BITMAX，后者是一种加密资产交易服务，因此您需要小心。</p><p><img src="/images/lineblockchain/img3.jpg" alt="Line Blockchain history"></p><p>LINE Blockchain Developers将是一个开发工具，可为开发人员提供与区块链链接的服务的轻松访问，类似于为用户开发BITMAX Wallet。</p><p>借助LINE区块链开发人员，可以使用API和Web UI在区块链上轻松<strong>发行Token和NFT（非可替代通证Token）</strong>，并可以将其链接到服务。</p><p>区块链的另一个功能是交易的透明性，该服务称为“ LINE Blockchain Explorer”。您可以查看在用户或服务中正在发出和处理哪些事务。</p><p>所有这些都是LINE Blockchain提供的服务的整体情况。以上是那须先生的开幕式。</p><h2 id="使用LINE区块链DEVELOPERS项目进行DApp开发"><a href="#使用LINE区块链DEVELOPERS项目进行DApp开发" class="headerlink" title="使用LINE区块链DEVELOPERS项目进行DApp开发"></a>使用LINE区块链DEVELOPERS项目进行DApp开发</h2><p>下一个会议是LINE Puls Blockchain Dev 1 Blockchain Developer的 坂井隆一 撰写的“使用LINE Blockchain Developers轻松快速进行Blockchain dApp开发”。</p><p>在此主题中，通证设置和发行都是实时完成的。在本文中这句话用了很长的篇幅，但是即使示例dApp（代码）已经准备好了，但都在40分钟的会话中完成了，并且很容易开始开发区块链服务。我想指出。至少事实证明，即使非工程人员也可以轻松设置和发行通证。</p><p><img src="/images/lineblockchain/img4.jpg" alt="Line Blockchain history"></p><p>LINE区块链开发人员还提供REST API，控制台（Web UI）和文档。</p><p>LINE区块链旨在允许您通过REST API使用区块链功能，而不是直接访问区块链。工程师可以使用REST API开发dApp，而无需了解很多有关区块链的知识。</p><p>控制台可以通过Web UI进行操作，它是一种工具，可让您设置使用LINE Blockchain Developers开发dApp时所需的区块链。</p><p>此外，文档为使用LINE区块链组织并准备了文档，例如服务教程，API参考和示例代码。</p><p>顺便说一句，LINE Blockchain允许您使用这些工具发行通证。该通证可以大致分为两种类型：<a href="https://docs-blockchain.line.biz/ja/overview/?id=サービストークン" target="_blank" rel="noopener">服务令牌</a>和<a href="https://docs-blockchain.line.biz/ja/overview/?id=アイテムトーク" target="_blank" rel="noopener">项目令牌</a>。服务令牌以每种服务中的货币形式准备（类似于ERC-20）。物品代币用于将非金钱物品和物品视为代币，并进一步分为可替代的精美代币和不可替代的非精美代币（NFT）（类似 以太坊 ERC-1155标准）。</p><h2 id="演示dApp“-LINE-Blockchain-Coffee”中的开发流程"><a href="#演示dApp“-LINE-Blockchain-Coffee”中的开发流程" class="headerlink" title="演示dApp“ LINE Blockchain Coffee”中的开发流程"></a>演示dApp“ LINE Blockchain Coffee”中的开发流程</h2><p>开发演示中介绍的dApp“ LINE Blockchain Coffee”是一个虚拟的在线咖啡店。它旨在在LINE区块链测试网络“ Cashew（カシュー） chain”上运行。LINE Blockchain Coffee使用两种类型的令牌。一种是服务令牌LBCC（LINE区块链咖啡币）。LBCC在服务中用作货币。第二个令牌LBCR（LINE区块链咖啡奖励）将作为NFT发行，并在购买咖啡时用作奖励。</p><p><img src="/images/lineblockchain/img5.jpg" alt="Line Blockchain history"></p><p>LINE Blockchain Coffee由LINE Puls工程师Alan Goo开发，而dApp代码已经<a href="https://github.com/behumble/line-blockchain-coffee" target="_blank" rel="noopener">发布在</a>Alan Goo的GitHub上(<a href="https://github.com/behumble/line-blockchain-coffee)。" target="_blank" rel="noopener">https://github.com/behumble/line-blockchain-coffee)。</a></p><p>本节中的解释将是使用基于LINE Blockchain Coffee的LINE Blockchain Developers进行dApp开发的过程。</p><p>顺便说一下，LINE区块链有一个主网“<a href="https://docs-blockchain.line.biz/ja/overview/?id=structure" target="_blank" rel="noopener">Daphne（ダフネ）chain</a><a href="https://docs-blockchain.line.biz/ja/overview/?id=structure)”和一个测试网“[Cashew（カシュー）" target="_blank" rel="noopener">https://docs-blockchain.line.biz/ja/overview/?id=structure)”和一个测试网“[Cashew（カシュー）</a> chain](<a href="https://docs-blockchain.line.biz/ja/overview/?id=structure)”，其运行方式与主网相同。首先，我们将在测试阶段使用适合于服务开发的免费Cashew" target="_blank" rel="noopener">https://docs-blockchain.line.biz/ja/overview/?id=structure)”，其运行方式与主网相同。首先，我们将在测试阶段使用适合于服务开发的免费Cashew</a> chain进行开发，而在开发全面的业务和服务时，我们将使用有偿的主网。</p><p>根据主网的大小，可以使用<strong>月费</strong>500美元（约50,000日元），2,500美元（约260,000日元）和4,300美元（约450,000日元）。测试网的腰果链是免费的，但是您需要首先申请使用它（它将在1天左右获得批准），因此请提前申请。使用Cashew chain，您<strong>最多可以注册100个测试帐户</strong>。</p><h2 id="LINE登录频道"><a href="#LINE登录频道" class="headerlink" title="LINE登录频道"></a>LINE登录频道</h2><p>在开发时，我们将从为区块链服务<a href="https://developers.line.biz/ja/docs/messaging-api/getting-started/#spy-creating-a-channel" target="_blank" rel="noopener">创建LINE登录通道</a>开始。</p><p><img src="/images/lineblockchain/img6.jpg" alt="Line Blockchain history"></p><p>LINE区块链dApp用户将是<strong>LINE用户</strong>，但dApp需要与BITMAX Wallet（LINE用户的钱包服务）一起使用。为此需要一个<strong>登录通道</strong>。</p><p>要创建一个登录通道，您需要访问<a href="https://www.linksign.jp/" target="_blank" rel="noopener">LINE开发人员</a>门户网站“ <a href="https://www.linksign.jp/" target="_blank" rel="noopener">LINE Developers</a> ”，因此您需要一个LINE Developers帐户。拥有LINE帐户的任何人都可以注册LINE Developers帐户。</p><p>访问LINE Developers后，在控制台中创建“ Providers”。提供者就像GitHub上的组织。将其视为产品名称。在LINE Developers中，我们将在Providers下为区块链服务创建一个Login通道，因此在此处创建一个任意的Providers Name。在演示中，提供者名称为“ LBD聚会”。</p><p><img src="/images/lineblockchain/img7.jpg" alt="Line Blockchain history"></p><p>创建提供者后，创建频道。使用LINE Developers，您还可以创建其他LINE应用程序，但是在这里，选择“<strong>创建区块链服务通道</strong>”以创建区块链通道。</p><p><img src="/images/lineblockchain/img8.jpg" alt="Line Blockchain history"></p><p>渠道类型为区块链服务，提供商为LBD Meetup。通道图标可以在此处注册，但在此演示中省略。接下来，将注册频道名称，但是在演示中，将其设置为“ LBD Meetup”，与提供者相同。最初，可以设置频道描述。</p><p>接下来，将注册服务类别和子类别，这一次将类别设置为“餐厅/餐馆”，并将子类别设置为“咖啡馆/咖啡厅”。从下拉菜单中选择一个类别。</p><p><img src="/images/lineblockchain/img9.jpg" alt="Line Blockchain history"></p><p>然后指定应用程序类型。在此，根据要开发的应用程序选择“ Web应用程序”或“移动应用程序”。顺便说一句，<a href="https://developers.line.biz/ja/" target="_blank" rel="noopener">日语版的控制台</a>是“ Web应用程序”和“本地应用程序”，因此您可以将“移动应用程序”视为智能手机应用程序。顺便说一下，在演示中，我选择了两者都支持。</p><p>电子邮件地址是开发人员的电子邮件地址。您还可以将隐私权政策和使用条款设置为选项，但在此处输入准备好的页面的URL。</p><p>完成上述设置后，检查并同意三种使用条款，例如LINE官方帐户使用条款，然后按频道创建按钮以完成第一步。</p><p>另外，该通道将在几秒钟内创建。之后，它将自动移至LINE Blockchain Developers的控制台，这将是下一步。</p><h2 id="通过LINE区块链开发人员控制台设置dApp"><a href="#通过LINE区块链开发人员控制台设置dApp" class="headerlink" title="通过LINE区块链开发人员控制台设置dApp"></a>通过LINE区块链开发人员控制台设置dApp</h2><p>接下来，通过LINE Blockchain Developers的控制台通过Web UI设置dApp。此处，在区块链上创建了服务，并创建了该服务的钱包。当dApp在区块链上进行某些操作（例如发行令牌）时，将使用此钱包。</p><p><img src="/images/lineblockchain/img10.jpg" alt="Line Blockchain history"></p><p>首先，选择要在“创建服务”中使用的链。指定测试网的Cashew（カシュー） chain。接下来，从下拉菜单中选择服务类别，但是在演示中将其设置为Commerce。可以从日本，日本以外的国家或两者中选择目标国家，这一次我选择了两者。</p><p>此外，<strong>LINE Blockchain禁止将其用于赌博</strong>，并在此处进行确认。同意不将其用于赌博，然后按创建按钮。</p><p>通过以上步骤，完成了创建服务的设置，并创建了与该服务相关的两个API密钥和API Secret参数。当dApp调用LINE Blockchain Developers API时，这些参数是必需的。</p><p>重要的一点是，此后根本不会显示API Secret，因此您需要复制它并在某处做笔记。确认（批准）创建时有必要将API机密保存在安全的地方。按下确认按钮并输入API Secret以完成设置。</p><p>接下来是创建钱包的工作。</p><p>首先设置钱包的名称。尽管在演示中将其设置为“ Admin”，但名称可以是任何易于理解的名称。设置一个名称，然后按创建按钮以创建一个钱包地址。此电子钱包秘密也将仅显示一次，因此请记下并保留。按确认按钮，然后输入Wallet Secret以完成设置。</p><p>至此，准备工作完成。</p><p><img src="/images/lineblockchain/img11.jpg" alt="Line Blockchain history"></p><h2 id="服务通证的创建（发行）"><a href="#服务通证的创建（发行）" class="headerlink" title="服务通证的创建（发行）"></a>服务通证的创建（发行）</h2><p>接下来，使用创建服务通证创建（发布）服务令牌。</p><p><img src="/images/lineblockchain/img12.jpg" alt="Line Blockchain history"></p><p>可以先设置通证图像，但在本演示中将其省略。我决定下一个通证名称。服务通证的名称已经在LBCC上确定，因此请在此处输入它。然后，您可以设置通证符号，但使其与令牌名称相同。</p><p><img src="/images/lineblockchain/img13.jpg" alt="Line Blockchain history"></p><p>随后的初始供应是指<strong>已发行的张数</strong>。在演示中，我将其设置为1000。LINE区块链中的代币在小数点后有固定位数（可以认为是小数点后的位数），因此您需要输入1000，然后再加上6位数字。 .. 换句话说，如果仅输入“ 1”，则表示“ 0.000001张”。</p><p>同样在演示中，在实际输入“ 1000”之后，另外输入了“ 000000”（6位数字的“ 0”）。它似乎是持久的，但请注意，仅输入“ 1000”将得到“ 0.001000”。</p><p>接下来，指定<a href="https://docs-blockchain.line.biz/ja/glossary/?id=owner-wallet" target="_blank" rel="noopener">所有者钱包</a>和<a href="https://docs-blockchain.line.biz/ja/glossary/?id=recipient-wallet" target="_blank" rel="noopener">收件人钱包</a>。所有者钱包是管理此服务令牌的钱包。接收者钱包将指定将作为初始供应生成的令牌发送到哪个钱包。</p><p>这次，我指定了在两种情况下先前创建的钱包管理钱包的地址。您早先写下的电子钱包机密是该规范所必需的。</p><p>通过按下创建按钮并输入钱包密码，将在几秒钟内发出服务通证，并完成设置工作。</p><p>在屏幕上，您可以看到已发行了名为LBCC的服务通证。</p><p><img src="/images/lineblockchain/img14.jpg" alt="Line Blockchain history"></p><p>然后，发布物品通证LBCR。</p><p>在此处，按屏幕上相应令牌的“新建”以发出新令牌。首先，为项目令牌选择“新建”。</p><p><img src="/images/lineblockchain/img15.jpg" alt="Line Blockchain history"></p><p>在“创建项目通证”中，在开头选择幻想或非寓言。由于LBCR是由NFT发行的，因此请选择不匹配按钮。</p><p>输入LBCR作为商品通证名称。您也可以在此处设置通证图像，但是这次将其省略。与服务令牌一样，既需要指定所有者钱包，也必须指定管理员钱包。</p><p>通过按下创建按钮并输入钱包密码来发行物品令牌。</p><p>这样就完成了通证设置。在屏幕上，您可以看到已发行两种类型的通证。</p><p><img src="/images/lineblockchain/img16.jpg" alt="Line Blockchain history"></p><h2 id="dApp本身的开发和dApp的启动"><a href="#dApp本身的开发和dApp的启动" class="headerlink" title="dApp本身的开发和dApp的启动"></a>dApp本身的开发和dApp的启动</h2><p>在使用控制台设置dApp之后，我们最终将开发dApp本身。但是，这次介绍了如何像开发dApp一样操作dApp。</p><p><img src="/images/lineblockchain/img17.jpg" alt="Line Blockchain history"></p><p>此dApp演示LINE Blockchain Coffee的设计目的是，您可以在虚拟的在线咖啡店购买一杯美洲咖啡获得<strong>200 LBCC</strong>，如果购买一杯美洲咖啡作为奖励，则可以获得<strong>1 LBCR</strong>的奖励。</p><p><img src="/images/lineblockchain/img18.jpg" alt="Line Blockchain history"></p><p>实际运行dApp需要进行准备。要启动dApp，请首先指定参数。在这里，传递到目前为止获得的信息，例如LINE登录通道ID，机密，API密钥，API机密和所有者钱包地址（请参阅屏幕以获取必要的参数）。</p><p><img src="/images/lineblockchain/img19.jpg" alt="Line Blockchain history"></p><p>其次，dApp向LINE区块链开发人员注册了回调URL，以通过LINE登录通道接收回调登录。第三，在dApp上创建一个用户，第四，在LINE Blockchain Developers中注册创建的用户。注册用户的工作仅对于测试网络是必需的。由于LINE区块链测试网中的<strong>用户数限制为100</strong>，因此环境是只有<strong>注册用户才能使用dApp</strong>。第五，提前将LBCC发送到用户的钱包，以便用户购物。这是准备工作。</p><p>现在，您终于可以启动dApp。在演示中，我能够看到安全购买咖啡并获得额外奖励的操作。到目前为止，它已经在40分钟内完成。</p><p><img src="/images/lineblockchain/img20.jpg" alt="Line Blockchain history"></p><h2 id="旨在引入自定义智能合约并于2021年在全球发布BITMAX钱包"><a href="#旨在引入自定义智能合约并于2021年在全球发布BITMAX钱包" class="headerlink" title="旨在引入自定义智能合约并于2021年在全球发布BITMAX钱包"></a>旨在引入自定义智能合约并于2021年在全球发布BITMAX钱包</h2><p>LINE的 那須 利将 先生再次上台谈论了LINE Blockchain所设想的未来。关于未来LINE Blockchain Developers的主要新增功能，据透露它将在2021年首先引入自定义智能合约，而BITMAX Wallet的目标也是在2021年全球发布。</p><p><img src="/images/lineblockchain/img21.jpg" alt="Line Blockchain history"></p><p>核心LINE区块链的主网上正在进行进一步的技术开发。<strong>我们正在对用于智能合约的虚拟机进行技术研究，改善共识算法，以及HD钱包和混合以提高隐私性</strong>。这些不会直接影响用户，但是它们使LINE Blockchain Developers和BITMAX Wallet更加易于使用。</p><p>据说，自定义智能合约可以满足希望执行与功能相关联的业务逻辑的开发人员的需求，这些功能包括服务通证，NFT通证和LINE Blockchain Developers已经提供的不可匹配通证。我们计划开发新的业务逻辑，将其部署到LINE准备的虚拟机上，并准备一个使其可执行的环境。</p><p><img src="/images/lineblockchain/img22.jpg" alt="Line Blockchain history"></p><p>至于执行环境，我们计划使用<strong>WASM运行时并将其完全提供为沙箱</strong>。而且，与其他WASM执行环境不同，该公司提供的环境不会照原样执行WASM二进制文件，而是将其编译为要执行的机器代码并提供更好的性能。</p><p>自定义智能合约目前支持Rust作为一种开发语言，但将来也将支持常用的编程语言。</p><p>顺便说一下，这些在将来会被进一步研究，并会进行调整以使其更易于使用。</p><h3 id="与隐私相关的研究也在进行中"><a href="#与隐私相关的研究也在进行中" class="headerlink" title="与隐私相关的研究也在进行中"></a>与隐私相关的研究也在进行中</h3><p><strong>该公司还透露，与隐私相关的研究正在进行中，这是整个区块链行业面临的挑战之一。他说，在PoC的研究阶段，他正在研究一种称为HD Wallet的技术，该技术使自己的地址模糊不清；而一种称为Mix的技术，使交易和地址之间的关系模糊化。</strong></p><p><img src="/images/lineblockchain/img23.jpg" alt="Line Blockchain history"></p><p>HD电子钱包创建自己的子地址，并将其用作交易的发行方或目的地。由于子地址始终是从父地址创建的，因此自己可能会知道子地址，而周围的人可能不会从子地址知道谁是父地址。结果，可以确保发行交易本身的透明性，并且通过使用子地址来确保用户自己的交易历史的私密性。</p><p>然后，通过进一步结合混合技术，将变得更加模糊。混合是一种技术，它收集一定数量的交易，使每个交易变成较小的交易，并使用算法将交易的发行方和目标混合在一起。例如，通过混合，混淆了A向B发送10个硬币的简单交易，包括发行者，目的地和10个硬币。</p><p>顺便说一句，还有一种通过使用中央混合和KYC认证来实现可追溯性的方法。似乎也在进行这项研究。</p><p>由于这些是PoC，因此无法确定它们将用于哪种服务。</p><p>关于LINE区块链，<strong>正在研究一种称为VRF（可验证随机函数）的伪算法</strong>。在这些研究中，LINE区块链目前由私有区块链运营，但在将来，它不会仅由我们自己的网络完成，而是将考虑应用于<strong>财团型区块链和公链型区块链</strong>。我们正在进行研究和开发，说在这种情况下将需要这项技术。此外，他还在进行互操作性和层技术的研究。</p><h3 id="研究它是否可以应用于CBDC"><a href="#研究它是否可以应用于CBDC" class="headerlink" title="研究它是否可以应用于CBDC"></a>研究它是否可以应用于CBDC</h3><p>他还谈到了CBDC（中央银行数字货币）。那須桑 指出，每个国家的中央银行都发表了有关CBDC的声明，并且该领域正在进行两项重大研究。一个就是“批发CBDC”，这是一个CBDC，用于金融机构之间的大量结算。在日本，这是一个全銀系统，但是这些系统已经数字化，并且由于交易量大，费用通常很高。据说正在进行研究，看是否有可能通过将其转换为区块链来显着降低成本。</p><p>另一个是“明细CBDC”，正在研究它作为用于日常付款的普通付款CBDC。那须桑还介绍了当前的CBDC，例如每个国家的努力。关于LINE区块链的主要网络，据说正在研究是否可以将其应用于这些CBDC。</p><p><img src="/images/lineblockchain/img24.jpg" alt="Line Blockchain history"></p><h2 id="旨在为开发人员形成社区"><a href="#旨在为开发人员形成社区" class="headerlink" title="旨在为开发人员形成社区"></a>旨在为开发人员形成社区</h2><p>那須桑 说，这次LINE区块链开发者Meet UP是为了成为开发者社区来支持开发和交换信息的地方而举行的。将来，他希望继续开办这样的Meet UP，并成为一个可以分享各种服务介绍和成果的地方。</p><p>关于为什么它是LINE区块链，他列举了能够基于LINE用户群将其提供给最终用户的优势。易用性对于用户和开发人员都是必要的因素，他强调LINE正是为此而努力的，这是重要的一点。</p><p><img src="/images/lineblockchain/img25.jpg" alt="Line Blockchain history"></p><p>那須桑还说，如果将LINE编写的LINK奖励计划用作激活服务的一种方式，将不胜感激。他说，将来，如果不透露区块链技术以及暴露服务和产品，那就太好了。而到了2020年，LINE区块链开发者大会的帷幕拉开了帷幕，说区块链服务的传播已经奠定了基础。</p><h2 id="大杨评论"><a href="#大杨评论" class="headerlink" title="大杨评论"></a>大杨评论</h2><p>今天上班的第一天，老杨就给分享了这篇文章，看了之后相当兴奋，Line作为日本互联网的巨头，在软银入股之后，拥有更多的资料，在各个领域都有所延伸，对于区块链技术和在线支付的推动也相当的给力。 这次看LINE Blockchain的解决方案，首先解决了企业发币难的问题，其次把LINE的用户直接生成钱包地址，并通过开放平台，让企业接入，支付月费的方式来使用这样的区块链积分服务，这样直接打击了乐天，T-Point等其他的巨头，在技术上拥有了绝对的领先位置。 再则从他们自己开发的公有链平台使用RUST并参考了ETH的理念，这块和前阵子jarvis老板推荐的bitflyer的blockchain平台很类似，日本人还是希望用自己的一套技术来解决商业问题，这块LINE的解决方案还是可行的。 通过LINE的8600万会员的导入和使用，大大推进了区块链的真实落地使用场景，很让人兴奋，虽然说是挂着区块链狗肉的中心化的解决方案（龙哥评价），但是我认为这个不很DEFI的解决方案，还是很适合日本的国情的，毕竟海外用户的付费意识很强烈，而且有付费用户了，这个chain才能持续的开发下去。其他的对于国家使用的区块链技术，还有清算等，这个在自由国家都是一锅粥，就可以略过了。</p><p>刚刚和任兄分享这个文章的过程，也同时获得了GMO日文稳定币在纽约获得通过的消息 <a href="https://techcrunch.com/2020/12/29/new-york-licenses-gmo-internet-to-issue-the-first-jpy-pegged-stablecoin/" target="_blank" rel="noopener">https://techcrunch.com/2020/12/29/new-york-licenses-gmo-internet-to-issue-the-first-jpy-pegged-stablecoin/</a> ，日本和美帝走的相当近，在区块链上还是有领先优势的，中国的DCEP还有待加油，真正的落实到真实的用户场景，而不应该成为当权者的一种手段。</p><p>总之，如果真正的LINE开始推广，那么真正的区块链积分在现实生活中将看到，而且能够得到普及，这个也是利好区块链的真实使用场景，为LINE点赞，为区块链技术开发者点赞。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Apr 21 2021 01:32:54 GMT+0900 (Japan Standard Time) --&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;新年在家休整了2天后，开始继续奋战，在考虑phase 2的和区块链技术整合的阶段，看到日本的IM巨头，Line在Blockchain上做的solution。具体链接在这里 &lt;a href=&quot;https://jp.techcrunch.com/2020/12/31/line-blockchain-developers-meetup-001-part01/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://jp.techcrunch.com/2020/12/31/line-blockchain-developers-meetup-001-part01/&lt;/a&gt; ， 就翻译了下，和大家一起分享，也许未来区块链在日本真正的落地，还得依赖这些巨头，看最近中国的蚂蚁链，推广的也不错。&lt;/p&gt;&lt;p&gt;主要面向用户：&lt;/p&gt;&lt;p&gt;对区块链感兴趣的开发人员&lt;/p&gt;&lt;p&gt;考虑引入 LINE Blockchain 的公司&lt;/p&gt;&lt;p&gt;来介绍LINE区块链未来的发展。&lt;/p&gt;&lt;p&gt;本次文章由Line区块链开发工程团队经理 那須 利将 来发表。&lt;/p&gt;&lt;h3 id=&quot;LINE区块链概述&quot;&gt;&lt;a href=&quot;#LINE区块链概述&quot; class=&quot;headerlink&quot; title=&quot;LINE区块链概述&quot;&gt;&lt;/a&gt;LINE区块链概述&lt;/h3&gt;&lt;p&gt;LINE区块链的口号是“为每个人设计的LINE区块链”。目的是将区块链技术纳入我们的日常生活。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/images/lineblockchain/img1.jpg&quot; alt=&quot;Line Blockchain history&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="blockchain" scheme="http://yangxinqi.com/categories/blockchain/"/>
    
    
      <category term="line, blockchain" scheme="http://yangxinqi.com/tags/line-blockchain/"/>
    
  </entry>
  
  <entry>
    <title>AWS S3配置信息</title>
    <link href="http://yangxinqi.com/2020/12/14/AWS-S3%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF/"/>
    <id>http://yangxinqi.com/2020/12/14/AWS-S3配置信息/</id>
    <published>2020-12-14T03:12:22.000Z</published>
    <updated>2020-12-14T03:18:16.082Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Apr 21 2021 01:32:54 GMT+0900 (Japan Standard Time) --><p>好久没弄AWS S3了，这块的坑还是蛮多，防止忘记了，还是记下来比较好。</p><p>需要关闭S3的公开访问权限，然后使用 cloudfront 来做CDN服务。</p><p>记录下流程：</p><ol><li>开启IAM用户，拿到appkey, secret ，设定本账户需要S3的FullAccess访问权限，然后获取进行配置权限，关闭公开访问，</li><li>cloudfront开一个服务，挂接到上面创建的s3 中即可。</li></ol><p>权限配置的部分，拿到账户的 iam进行设置，配置resource即可。</p><p>以下是配置，先保存下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"Version"</span>: <span class="string">"2012-10-17"</span>,</span><br><span class="line">    <span class="attr">"Statement"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"Sid"</span>: <span class="string">"AddCannedAcl"</span>,</span><br><span class="line">            <span class="attr">"Effect"</span>: <span class="string">"Allow"</span>,</span><br><span class="line">            <span class="attr">"Principal"</span>: &#123;</span><br><span class="line">                <span class="attr">"AWS"</span>: <span class="string">"arn:aws:iam::3631695485**:user/******_s3"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"Action"</span>: [</span><br><span class="line">                <span class="string">"s3:PutObject"</span>,</span><br><span class="line">                <span class="string">"s3:PutObjectAcl"</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">"Resource"</span>: <span class="string">"arn:aws:s3:::******/*"</span>,</span><br><span class="line">            <span class="attr">"Condition"</span>: &#123;</span><br><span class="line">                <span class="attr">"StringEquals"</span>: &#123;</span><br><span class="line">                    <span class="attr">"s3:x-amz-acl"</span>: <span class="string">"public-read"</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"Sid"</span>: <span class="string">"PublicRead"</span>,</span><br><span class="line">            <span class="attr">"Effect"</span>: <span class="string">"Allow"</span>,</span><br><span class="line">            <span class="attr">"Principal"</span>: <span class="string">"*"</span>,</span><br><span class="line">            <span class="attr">"Action"</span>: [</span><br><span class="line">                <span class="string">"s3:GetObject"</span>,</span><br><span class="line">                <span class="string">"s3:GetObjectVersion"</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">"Resource"</span>: <span class="string">"arn:aws:s3:::******/*"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Apr 21 2021 01:32:54 GMT+0900 (Japan Standard Time) --&gt;&lt;p&gt;好久没弄AWS S3了，这块的坑还是蛮多，防止忘记了，还是记下来比较好。&lt;/p&gt;&lt;p&gt;需要关闭S3的公开访问权限，然后使用 
      
    
    </summary>
    
      <category term="devops" scheme="http://yangxinqi.com/categories/devops/"/>
    
    
      <category term="awss3" scheme="http://yangxinqi.com/tags/awss3/"/>
    
  </entry>
  
  <entry>
    <title>每日晨读思考20201127</title>
    <link href="http://yangxinqi.com/2020/11/27/%E6%AF%8F%E6%97%A5%E6%99%A8%E8%AF%BB%E6%80%9D%E8%80%8320201127/"/>
    <id>http://yangxinqi.com/2020/11/27/每日晨读思考20201127/</id>
    <published>2020-11-27T01:30:24.000Z</published>
    <updated>2020-11-27T02:43:02.269Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Apr 21 2021 01:32:54 GMT+0900 (Japan Standard Time) --><h3 id="晨读"><a href="#晨读" class="headerlink" title="晨读"></a>晨读</h3><p>晨读，要养成一个习惯，每天对市场动态进行一个简要的分析，大量的媒体放出来的信息进行过滤，知道市场热点在哪里，扩展知识面，之后在养成做笔记的习惯，把这些记录到文章里面，这样是不是可以养成每天写日记的习惯，同时对当前社会，科技发生的问题，有自己独特的思考和见解，能够记录下来，也算是自己留下来的东西。</p><p><img src="/images/readbook.jpeg" alt="没有聪明人不阅读的"></p><p>晨读，用到的工具是 今日热榜 网页版，需要把自己想看的各个媒体的主要热文和最新热文，展示出来，一个主流媒体10篇文章，总共订阅大概29个媒体聚合热榜，花上30分钟，扫描下290篇文章的主要内容。 看详细内容和思考，需要在花30分钟，每天1小时在阅读上，是很关键的。</p><a id="more"></a><p>我基本关注的如下：</p><p>财经媒体： 格隆汇，新浪财经，富途牛牛，雪球，英为财经，第一财经商业中心，雪球今日话题</p><p>政府政策： 财新网, 见闻VIP，微信24小时热文</p><p>科技媒体： 36KR，虎嗅网</p><p>数字货币： 链闻，星球日报，金色财经，巴比特，火星财经</p><p>社交媒体： 微博热榜，新浪热点帮，微信热词，百度实时热点，知乎热榜</p><p>短视频媒体： 抖音视频榜，快手实时热榜， 微信视频榜， 哔哩哔哩 全站日榜</p><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><p>M1 芯片PR， 不要依赖第三方成为自己关键创新和能力的推动者。 现在计算正在变革，软件是数据的端点，工作靠API实现。 未来，视觉和听觉界面才是关键。 机器学习将会定义未来软件功能。 全部迁移到M家族需要长达2年的时间。 现在生活在一个连线的世界，以网络的规模在移动。 业界通常采用的参数以及不再是任务级别性能表现的很好的特征了，跑分没有意义。 现在大量处理都是在CPU，图形和神经引擎以及图像信号处理器上面进行的。</p><p>财商教育： 微淼商学院，长投学堂，快财学堂等，这块我在 抖音上都加上过， 轻教育模式，采用手机APP+微信课堂（小鹅通）等直播授课模式，以定制化的最终解决方案，满足学员差异化和个性化理财学习需求。 小白韭菜更好收割。 步骤是 9.9 引流课，反复卖焦虑，在兜售数千元的高价课程。 自我介绍，构建用户画像和需求痛点，在优化课程提高完课率。</p><p>ETH 2.0 评论： 昨天ETH直接大跌20%，接下来来看2.0解决网络拥堵和扩容，去中心化是唯一优势。 Phase 1提供数据分片，供rollup使用。 Phase 0, 轻客户端支持，数据分片，合并，并行推进，任一模块好了，就可以推出。 二次方分片，技术不一定能够做的出来，不能实现真正分片的话，性能和1.0美元本质区别。 Layer2从ZK Rollup到Optimistc Rollup 都在部署Uniswap,Synthetix, 比现在的ETH扩容10x。 ETH是金融系统而不是软件，这块影响了ETH的价格，导致影响了ETH的整个社区。</p><p>DODO PR： AMM缺点，低资金利用率，额外的风险敞口，无常损失问题。 DeFi的核心是对效益和收益简单直白的追求。资本永不闲置。 未来的一些点，DEX的专业做市商增多， 允许用户更创新，更有效简单的管理风险，定义链上做市策略，激励他们将流动性转移过来。 散户LP也遵循同样的策略。 交易员在DEFI上销售到和CEX相同的流动性深度。 Defi是个全新的游乐园，DODO和LONGHASH共同发文。</p><p>中国智能电动车暴涨： 经纬将估值和对电动车行业的看法。 低利率时代逼迫投资者追逐有限的优质标的，拥挤的交易更加拥挤。 传统估值方式失效，投资判断越来越前置。 判断企业估值： 现金流，增长，风险。 都是从未来着手，所以估值思路从静态走向动态，从回顾走向前瞻。 公司可能在临界点，都在亏损，一旦突破，就会指数型增长，给资本市场带来革命性变化。 拼多多，特斯拉，SnowFlake（120倍P/S) 痘痕夸张。 对公司估值的定价权，不在公司手里，也不在VC手里，而是在市场手里，估值完全由供需决定。“好价格”以及不复存在，我们需要重新思考安全边际。 对VC来说，核心永远都在“能否投对”。 利率是一切金融资产的基准，利率一边，价格判断和估值的基础也的跟着变。 此时估值理念也要做出相应改变。 各类资产，风险排序，最底层的基石是 国库券（Treasurys). 股票不必便宜就能吸引买家，具备高增长潜力的股票，买家还会蜂拥而入。 要“增长”不要“价值”。 从市场情绪和未来走向，经纬给创业公司一些建议:</p><p>1.不管大环境会不会出现动荡，现在成为头部的回报无疑比以前更高了，一个行业里的前三， 6-3-1格局。 数据笔记，市场占有率，营业收入，净利润规模，团队迭代，自己成长，打法策略思考。</p><ol><li>后疫情时代，很多行业都出现了质变的机会，而不仅仅是量变。 创业者寻找一个量变多增长，软件植入，SaaS，给企业规模带来了质变，需要快速调整。快速思考布局和行业切换，才能最终的胜利。</li><li>早点拿钱，狠狠地拿钱，现在资金已经变成了一个核心竞争力。 不要过分考虑稀释，而是把融资确定性放在第一位，拿到充足的子弹，不要因为大意和错判而断粮。 资本要素排序，一，确定性，二，金额，之后才是估值和条款。</li><li>要更加有立场，中美关系交恶，对中国未来的发展心里打鼓。创始人需要在更多的关键点上有更清晰的立场，不能脚踏2条船，2变市场都有好处，聚焦中国，成为市场头部，在去展望海外。</li><li>现在，创始人个人全方位学习的速度，变得空前重要。 创始人有没有被身边的人脉，资金，自身的学习，格式个样的课程，输入滋养，以三个月为单元，用科学方法加外部反馈，衡量提升质量，持续成长是所有最终做大公司唯一恒大的关键点。</li></ol><p>市场瞬息万变，而人要有包容度。 我们处于一个史无前例的低利率时代，要用新的思想去面对。</p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>看了最后的经纬的文章，他们的公众号也是我很喜欢读的，讲的真心很实在，而且作为创业者很有收获。</p><p>低利率时代，之前陈桑推荐我用公司去贷款，我给拒绝了，思想需要转变，作为公司，没有不负债的，需要加速，扩大规模和增长，就需要预支未来。</p><p>对于融资拿钱，关注确定性并积极推进，之前的项目，我也很消极，这块需要提高自己的积极性，做一定的学习和心态锻炼，置之死地而后生，在多难的情况下都挺过来了，疫情期间，真心体会到难，也都挺过来了，阳光的积极心态，来面对疫情之后的世界，也是挺好的。</p><p>对于更有立场，中国市场打2年，又回日本了，这块是需要坚定立场，因为时间和资源有限，市场的确定性，必须选择好，这个也是值得深入思考的问题。</p><p>最后还是强调个人学习，其实每天一个小时的学习，更能够带来效果，接下来减少笔记量，多从自己的思考出发，控制好起床时间和晚上睡觉时间，最近加班状态身体又扛不住了，把握节奏，自我学习，相当关键，懂得拒绝很多事情，才是关键，钱是赚不完的，做的越多也有可能赔的越多。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Apr 21 2021 01:32:54 GMT+0900 (Japan Standard Time) --&gt;&lt;h3 id=&quot;晨读&quot;&gt;&lt;a href=&quot;#晨读&quot; class=&quot;headerlink&quot; title=&quot;晨读&quot;&gt;&lt;/a&gt;晨读&lt;/h3&gt;&lt;p&gt;晨读，要养成一个习惯，每天对市场动态进行一个简要的分析，大量的媒体放出来的信息进行过滤，知道市场热点在哪里，扩展知识面，之后在养成做笔记的习惯，把这些记录到文章里面，这样是不是可以养成每天写日记的习惯，同时对当前社会，科技发生的问题，有自己独特的思考和见解，能够记录下来，也算是自己留下来的东西。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/images/readbook.jpeg&quot; alt=&quot;没有聪明人不阅读的&quot;&gt;&lt;/p&gt;&lt;p&gt;晨读，用到的工具是 今日热榜 网页版，需要把自己想看的各个媒体的主要热文和最新热文，展示出来，一个主流媒体10篇文章，总共订阅大概29个媒体聚合热榜，花上30分钟，扫描下290篇文章的主要内容。 看详细内容和思考，需要在花30分钟，每天1小时在阅读上，是很关键的。&lt;/p&gt;
    
    </summary>
    
      <category term="other" scheme="http://yangxinqi.com/categories/other/"/>
    
    
      <category term="晨读" scheme="http://yangxinqi.com/tags/%E6%99%A8%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>TDEngine学习笔记</title>
    <link href="http://yangxinqi.com/2020/11/16/TDEngine%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yangxinqi.com/2020/11/16/TDEngine学习笔记/</id>
    <published>2020-11-16T07:00:33.000Z</published>
    <updated>2020-11-17T03:25:14.956Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Apr 21 2021 01:32:54 GMT+0900 (Japan Standard Time) --><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>对于TDEngine从2019年4月，团队就在开始研究，场景是需要获取大量的交易所数据，但是之前使用的influxdb和elasticsearch在同时并发写入大量的ohlcv数据的时候，卡死了，我们一直在寻找好的存储引擎来替代这个大量并发写入和能够进行实时计算的解决方案。 正好这时候TDEngine开源并且发布了1.6x版本，看解决场景中，也有部分金融场景，所以本次我特别针对金融场景下TDEngine的使用，进行了记录，虽然TDengine主要是用在IoT方向上，但是我感觉金融方向更需要一个强大的时序数据库来解决存储和计算的问题。</p><p>作为深入学习TDEngine的过程，本次，从白皮书，到代码，到编译安装以及到实战场景下，来对TDEngine进行深入的了解和试用。</p><a id="more"></a><h3 id="读文档"><a href="#读文档" class="headerlink" title="读文档"></a>读文档</h3><h4 id="大数据场景主要问题及解决方案"><a href="#大数据场景主要问题及解决方案" class="headerlink" title="大数据场景主要问题及解决方案"></a>大数据场景主要问题及解决方案</h4><p>大数据时代的挑战，源源不断的产生海量的实时数据发往云端。 这些数据是企业的宝贵财富，帮助企业实时监控业务或设备运行情况，生成各种报表，通过大数据分析和机器学习，对业务进行预测和预警，帮助企业进行科学决策，节约成本并创造新的价值。</p><p>不管是IoT还是金融交易系统，所产生的数据都是时序的，很多带有位置信息。 有明显的特征如下：</p><ol><li><p>数据是时序的，一定带有时间戳</p></li><li><p>数据是结构化的</p></li><li><p>数据极少的更新或删除</p></li><li><p>无需传统的数据库的事务处理</p></li><li><p>互联网应用写多读少</p></li><li><p>用户公主一段时间的趋势，而不是某一特定时间点的值</p></li><li><p>数据是有保存期限的</p></li><li><p>数据查询分析一定是基于时间段和位置区域的。</p></li><li><p>存储查询外，还需要各种统计和实时计算</p></li><li><p>数据量大，每天采集超过100亿条。</p></li></ol><p>TDEngine解决的问题：</p><ol><li>10X以上的性能提升： 定义创新数据存储，单核每秒就处理2万次请求，插入数百万个数据点，读一千万以上数据点，是现有通用数据库的10倍以上。</li><li>硬件或云服务成本降低1/5: 不到通用大数据存储方案的1/5，通过列式存储和先进的压缩算法，存储空间不到通用数据库的1/10.</li><li>全栈时序数据处理引擎： 将数据库，消息队列，缓存和流式计算等功能融合，降低开发和维护成本。</li><li>强大的分析功能： 时间范围查询，数据在时间轴和多个维度进行聚合，通过多客户端查询。 并于第三方工具无缝集成。</li><li>零运维成本，零学习成本： 安装集群，快速搞定，无需分库分表，实时备份。 标准SQL，支持多客户端，类似MYSQL，零学习成本。</li></ol><p>对于传统的网络爬虫，微博，微信，电商，DRP，CRM等通用类型数据，不适合用TDEngine来存储。</p><h4 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h4><p>采用关系数据库模型，通过创建多个库表。 但是有显著不同点。</p><p>一个数据采集点一张表： 这里对应到金融上，比如一个SYMBOL，1M 的K线数据，一， 能够保证存储介质上是一块一块连续的。 读取的时候大幅减少随机操作，提高查询速度。二，不同的维度数据产生过程完全独立，数据源唯一， 一张表只有一个写入者，采用无锁方式，大幅提升写入速度。 三，对于时序数据，写的操作可用追加的方式实现，提高写入速度和查询速度。</p><p>超级表：（STable）业务需要不同的维度之间聚合操作，聚合的操作也变得复杂，使用超级表，将特定类型的数据集合，同一个维度，结构是一样的，但是每个维度名字和静态属性（标签）是不一样的。 超级表用来代表一组相同类型的数据采集点， 表带有静态标签。</p><h4 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h4><p>在内存，使用SkipList建立索引，按照First In First Out的方式进行管理，在存储时，使用列式存储，提高压缩率和数据读取速度，并且每个数据块都有预计算，提高数据分析速度。</p><p>数据写入WAL日志，同时回维护表索引，保证数据块在文件中的偏移量，起始时间，数据点数，压缩算法等。</p><p>通过数据分区，将新旧数据分开存放，减少一盘随机读取，也能够在廉价的存储设备上有超强性能。</p><p>一个表数据会按照时间段分区，不会跨节点存储，以便于单张表快速高效的插入，查询和计算。 一个节点，一秒产生100字节数据，一年才3G，压缩之后是300M，处理问题不大。</p><h3 id="分布式存储"><a href="#分布式存储" class="headerlink" title="分布式存储"></a>分布式存储</h3><p>按照分布式高可靠架构进行设计的，是完全去中心化的。</p><p>&lt;插入图集群&gt;</p><p>数据节点 dnode: 是运行实例，一个工作系统必须至少有一个数据节点，dnode包含0 to N个 vnode 虚拟节点， 0 to n个 mnode 管理节点。</p><p>虚拟节点的数据以异步复制的方式进行实时同步，并实现数据最终一致性，保证在堕胎物理机上有copy，保证系统高可靠性。</p><p>mnnode 存储节点运行状态及节点负载均衡以及所有的Meta data等信息， 容许多到5个多mnode来管理，无需人工干预。</p><h4 id="TAOSC"><a href="#TAOSC" class="headerlink" title="TAOSC"></a>TAOSC</h4><p>负责处理应用与集群的接口交互，内嵌于JDBC，C，PYTHON，GO等连接库中，模块负责缓存元数据，插入和查询正确节点，把结果返回时，需要负责最后一级的聚合，排序，过滤等操作。</p><h4 id="数据分片，水平扩展"><a href="#数据分片，水平扩展" class="headerlink" title="数据分片，水平扩展"></a>数据分片，水平扩展</h4><p>整个系统水平扩展，手动添加和移除节点，需要人工干预，其他的系统自动完成，使用vnode设计，可以更好的支持硬件异构环境，恢复节点，裁撤节点和新增节点都可以快速迁移。</p><h4 id="高可靠性"><a href="#高可靠性" class="headerlink" title="高可靠性"></a>高可靠性</h4><p>多个虚拟数据节点组成，Replication Factor &gt; 2， vnode之间通过心跳包来通知对方状态，通过连接器去获取 fqdn，保证连接的可靠。 采用Master-Slave异步复制的方式实现多个副本之间的实时数据同步，采取的是最终一致性，而不是强一致性。 当一台主机重启时，版本低的节点停止对外服务，同时进行同步流程。 同步复制的模式实现虚拟管理节点的数据同步，写的操作，只有Slave节点写入成功后，master节点才会返回成功。 Meta数据基本完全保存在哪吃，提高查询效率。 同时也会缓存在本地，</p><h4 id="高效的多表聚合"><a href="#高效的多表聚合" class="headerlink" title="高效的多表聚合"></a>高效的多表聚合</h4><p>先创建超级表，在以超级表为模版，创建具体表，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> m1 (ts <span class="keyword">timestamp</span>, pressure <span class="built_in">int</span>, rpm <span class="built_in">int</span>) tags (<span class="keyword">model</span> <span class="built_in">binary</span>(<span class="number">8</span>), color <span class="built_in">binary</span>(<span class="number">8</span>))</span><br></pre></td></tr></table></figure><p>创建了STable M1 带有标签model和标签color， 在创建具体表t1.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t1 <span class="keyword">using</span> m1 tags(<span class="string">'apple'</span>, <span class="string">'red'</span>)</span><br></pre></td></tr></table></figure><p>插入数据时支持多插入，查询时候，可以基于标签对STable进行聚合查询或者统计</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">avg</span>(pressure) <span class="keyword">from</span> m1 <span class="keyword">where</span> <span class="keyword">model</span>=<span class="string">'apple'</span> <span class="built_in">interval</span>(<span class="number">5</span>m) <span class="keyword">group</span> <span class="keyword">by</span> color</span><br></pre></td></tr></table></figure><p>实现流程：</p><p>App –&gt; taosc –&gt; mnode –&gt; dnode0, dnode1, dnoden —&gt; app</p><p>先在内存中扫描数据，之后在存储中聚合数据。 最后返回给应用。</p><h4 id="实时流式计算"><a href="#实时流式计算" class="headerlink" title="实时流式计算"></a>实时流式计算</h4><p>a v g, dev, count, first, last, least squares , max, min, percentile, sum, diff, div, scale , +-*/</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> d1 <span class="keyword">as</span> <span class="keyword">select</span> <span class="keyword">avg</span>(presure) <span class="keyword">from</span> t1 <span class="built_in">interval</span>(<span class="number">60</span>s) sliding(<span class="number">10</span>s)</span><br></pre></td></tr></table></figure><h4 id="更多亮点"><a href="#更多亮点" class="headerlink" title="更多亮点"></a>更多亮点</h4><p>数据订阅，本身是一个消息队列中间件。 异步插入API，大幅度提高性能。</p><h3 id="参数指标"><a href="#参数指标" class="headerlink" title="参数指标"></a>参数指标</h3><p>数据类型： tinyint, smallint, int ,bigint, float, double,binary, nchar, bool</p><p>单记录最大长度，16K字节， 最大记录条数，仅受存储空间限制，最大表个数，仅受节点个数限制， 最大数据备份数5，单点插入速度 2万/s（单核），节点查询速度： 2000万/s （全内存情况）</p><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>作为一个基础性软件，典型场景如下：</p><p>设备监控， 电力行业，出行行业，通讯行业，金融行业（交易记录，存取记录，ATM，POS机监测），交通行业，石油石化，互联网， 物流行业，环境监测，军工行业，制造页， 公共安全等。</p><h3 id="安装使用"><a href="#安装使用" class="headerlink" title="安装使用"></a>安装使用</h3><p>了解了原理和应用，接下来到安装和具体使用的环节。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Apr 21 2021 01:32:54 GMT+0900 (Japan Standard Time) --&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;对于TDEngine从2019年4月，团队就在开始研究，场景是需要获取大量的交易所数据，但是之前使用的influxdb和elasticsearch在同时并发写入大量的ohlcv数据的时候，卡死了，我们一直在寻找好的存储引擎来替代这个大量并发写入和能够进行实时计算的解决方案。 正好这时候TDEngine开源并且发布了1.6x版本，看解决场景中，也有部分金融场景，所以本次我特别针对金融场景下TDEngine的使用，进行了记录，虽然TDengine主要是用在IoT方向上，但是我感觉金融方向更需要一个强大的时序数据库来解决存储和计算的问题。&lt;/p&gt;&lt;p&gt;作为深入学习TDEngine的过程，本次，从白皮书，到代码，到编译安装以及到实战场景下，来对TDEngine进行深入的了解和试用。&lt;/p&gt;
    
    </summary>
    
      <category term="ai" scheme="http://yangxinqi.com/categories/ai/"/>
    
    
      <category term="big data" scheme="http://yangxinqi.com/tags/big-data/"/>
    
  </entry>
  
  <entry>
    <title>懂得规划自己的生活</title>
    <link href="http://yangxinqi.com/2020/11/13/%E6%87%82%E5%BE%97%E8%A7%84%E5%88%92%E8%87%AA%E5%B7%B1%E7%9A%84%E7%94%9F%E6%B4%BB/"/>
    <id>http://yangxinqi.com/2020/11/13/懂得规划自己的生活/</id>
    <published>2020-11-13T05:36:05.000Z</published>
    <updated>2020-11-13T07:42:26.352Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Apr 21 2021 01:32:54 GMT+0900 (Japan Standard Time) --><p>人生需要改变，经历疫情，人的生活方式都变了。需要一些理财建议，人生需要有一些自己的理想和自己的原则，但是生活的条件不应该有太大的变化，选择是最重要的。</p><p>思考快与慢，一直都想提高自己的效率做更多的事情， 但是其实很多时候，慢慢的处理，更贴近真实的生活。</p><p><img src="/images/fiveyear.png" alt="懂得规划生活"></p><a id="more"></a><h3 id="一些建议自己也应该遵守"><a href="#一些建议自己也应该遵守" class="headerlink" title="一些建议自己也应该遵守"></a>一些建议自己也应该遵守</h3><p>一，预留12个月应急资金。 为了避免所有的债务，之后才能进行投资。 疫情改变了世界，我们不能回到过去的生活方式，特别是使用钱上面。 这次真心体会到，当缺少最基本的保障的时候，很多事情都变得没有意义了。</p><p>二，尽量不用信用卡</p><p>没有信用卡的日子，其实也没有什么太难的东西，尽量少用，只有少用才能避免信贷的恶性循环。</p><p>三，存款会让你感觉良好</p><p>生活成本越低，越容易积攒够一年开支的钱，过度透支会阻碍你实现这个目标。</p><h3 id="心态稳，才能更好的投资"><a href="#心态稳，才能更好的投资" class="headerlink" title="心态稳，才能更好的投资"></a>心态稳，才能更好的投资</h3><p>生活的心态更稳，不用一直担心钱的问题。</p><p>这样你才能成为更好的投资者。</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>不要过度使用信用卡，减少债务，直到降为零，然后在消除所有其他的债务，开源节流，之后建立起12个月的应急现金基金，作为现金缓冲，之后在把多余的钱拿来做投资，这块可以进可攻退可守。</p><p>其实道理很简单，但是很多去赌一赌的亏钱的人，都是很难从这里认识这个道理的。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Apr 21 2021 01:32:54 GMT+0900 (Japan Standard Time) --&gt;&lt;p&gt;人生需要改变，经历疫情，人的生活方式都变了。需要一些理财建议，人生需要有一些自己的理想和自己的原则，但是生活的条件不应该有太大的变化，选择是最重要的。&lt;/p&gt;&lt;p&gt;思考快与慢，一直都想提高自己的效率做更多的事情， 但是其实很多时候，慢慢的处理，更贴近真实的生活。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/images/fiveyear.png&quot; alt=&quot;懂得规划生活&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="other" scheme="http://yangxinqi.com/categories/other/"/>
    
    
      <category term="生活" scheme="http://yangxinqi.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>solidity学习笔记</title>
    <link href="http://yangxinqi.com/2020/11/02/solidity%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yangxinqi.com/2020/11/02/solidity学习笔记/</id>
    <published>2020-11-02T05:06:16.000Z</published>
    <updated>2020-11-02T06:58:48.604Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Apr 21 2021 01:32:54 GMT+0900 (Japan Standard Time) --><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>做区块链相关的创业已经有4年了，都是做ETL方面的，对于真正的合约以及Trading，其实没有真正的使用，技术就是这样，用了就会发现有意思，从最早的没有信仰，到现在的信心满满，虽然BTC的价格还是3年前BTC的价格，但是市场已经今非昔比了，从DEFI的火热，到各种POOL的出现，区块链的运营方式和目标人群都巨大的变化了。在大经济形势周期的转变下，我也从数据，转战到了DEFI，因为DEFI才是代表了未来真正的放下，大环境下，随着疫情，越来越多的政府和国家地区更深入的隔绝，对于崇尚自由的人来说，我们更应该获得真正意义上的金融自由。虽然现在Blockchain还是被美帝把持着。</p><p>闲话不多说，我们开始真正的来玩转合约，合约从Ether起，也和Ether的创始团队息息相关，从V神，还有WOOD博士开始，Ether的出现也带来了Solidity和Vyper,智能合约语言，目前来看Vyper更安全，而Solidity使用更广泛，本文主要讲Solidity的开发和使用。</p><p>Solidity文档： <a href="https://learnblockchain.cn/docs/solidity/introduction-to-smart-contracts.html" target="_blank" rel="noopener">https://learnblockchain.cn/docs/solidity/introduction-to-smart-contracts.html</a></p><p><img src="/images/solidity.jpeg" alt="Solidity"></p><a id="more"></a><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><h4 id="Solidity语法"><a href="#Solidity语法" class="headerlink" title="Solidity语法"></a>Solidity语法</h4><p>Solidity 是一门面向合约的、为实现智能合约而创建的高级编程语言。这门语言受到了 C++，Python 和 Javascript 语言的影响，设计的目的是能在 <a href="https://learnblockchain.cn/2019/04/09/easy-evm/" target="_blank" rel="noopener">以太坊虚拟机（EVM）</a> 上运行。Solidity 是静态类型语言，支持继承、库和复杂的用户定义类型等特性。在部署合约时，应该尽量使用最新版本，因为新版本会有一些重大的新特性以及bug修复。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: GPL-3.0 </span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.4</span><span class="number">.16</span> &lt;<span class="number">0.8</span><span class="number">.0</span>; </span><br><span class="line"></span><br><span class="line">contract SimpleStorage &#123;</span><br><span class="line">  uint storedData;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">set</span>(<span class="params">uint x</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">  storedData = x;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> storedData;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>pragmas（编译指令）是告知编译器如何处理源代码的指令, Solidity中合约的含义就是一组代码（它的 <em>函数</em> )和数据（它的 <em>状态</em> ），它们位于以太坊区块链的一个特定地址上。该合约能完成的事情并不多（由于以太坊构建的基础架构的原因）：它能允许任何人在合约中存储一个单独的数字，并且这个数字可以被世界上任何人访问，且没有可行的办法阻止你发布这个数字。当然，任何人都可以再次调用 <code>set</code> ，传入不同的值，覆盖你的数字，但是这个数字仍会被存储在区块链的历史记录中。随后，我们会看到怎样施加访问限制，以确保只有你才能改变这个数字。 所有的标识符（合约名称，函数名称和变量名称）都只能使用ASCII字符集。UTF-8编码的数据可以用字符串变量的形式存储。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: GPL-3.0</span></span><br><span class="line">pragma solidity  &gt;<span class="number">0.5</span><span class="number">.99</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract Coin &#123;</span><br><span class="line">    <span class="comment">// 关键字“public”让这些变量可以从外部读取</span></span><br><span class="line">    address public minter;</span><br><span class="line">    mapping (<span class="function"><span class="params">address</span> =&gt;</span> uint) public balances;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 轻客户端可以通过事件针对变化作出高效的反应</span></span><br><span class="line">    event Sent(address <span class="keyword">from</span>, address to, uint amount);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这是构造函数，只有当合约创建时运行</span></span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        minter = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 铸币操作</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">mint</span>(<span class="params">address receiver, uint amount</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(msg.sender == minter);</span><br><span class="line">        <span class="built_in">require</span>(amount &lt; <span class="number">1e60</span>);</span><br><span class="line">        balances[receiver] += amount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 转币操作</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">send</span>(<span class="params">address receiver, uint amount</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(amount &lt;= balances[msg.sender], <span class="string">"Insufficient balance."</span>);</span><br><span class="line">        balances[msg.sender] -= amount;</span><br><span class="line">        balances[receiver] += amount;</span><br><span class="line">        emit Sent(msg.sender, receiver, amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>address public minter;</code> 这一行声明了一个可以被公开访问的 <code>address</code> 类型的状态变量。 <code>address</code> 类型是一个160位的值，且不允许任何算数操作。mapping (address =&gt; uint) public balances;` 也创建一个公共状态变量，但它是一个更复杂的数据类型。 该类型将address映射为无符号整数。 Mappings 可以看作是一个 <a href="https://en.wikipedia.org/wiki/Hash_table" target="_blank" rel="noopener">哈希表</a> 它会执行虚拟初始化，以使所有可能存在的键都映射到一个字节表示为全零的值。 但是，这种类比并不太恰当，因为它既不能获得映射的所有键的列表，也不能获得所有值的列表。</p><p><code>event Sent(address from, address to, uint amount);</code> 这行声明了一个所谓的“事件（event）”，它会在 <code>send</code> 函数的最后一行被发出。</p><p>对于程序员来说，区块链这个概念并不难理解，这是因为大多数难懂的东西 (挖矿, <a href="https://en.wikipedia.org/wiki/Cryptographic_hash_function" target="_blank" rel="noopener">哈希</a> ，<a href="https://en.wikipedia.org/wiki/Elliptic_curve_cryptography" target="_blank" rel="noopener">椭圆曲线密码学</a> ，<a href="https://en.wikipedia.org/wiki/Peer-to-peer" target="_blank" rel="noopener">点对点网络（P2P）</a> 等) 都只是用于提供特定的功能和承诺。</p><p><strong>区块，交易，事务</strong></p><p>区块链是全球共享的事务性数据库，这意味着每个人都可加入网络来阅读数据库中的记录。如果你想改变数据库中的某些东西，你必须创建一个被所有其他人所接受的事务。此外，交易总是由发送人（创建者）签名。</p><p>在比特币中，要解决的一个主要难题，被称为“双花攻击 (double-spend attack)”：如果网络存在两笔交易，都想花光同一个账户的钱时（即所谓的冲突）会发生什么情况？交易互相冲突？</p><p><strong>以太仿虚拟机EVM</strong></p><p>以太坊虚拟机 EVM 是智能合约的运行环境。它不仅是沙盒封装的，而且是完全隔离的，也就是说在 EVM 中运行代码是无法访问网络、文件系统和其他进程的。甚至智能合约之间的访问也是受限的。以太坊中有两类账户（它们共用同一个地址空间）： <strong>外部账户</strong> 由公钥-私钥对（也就是人）控制； <strong>合约账户</strong> 由和账户一起存储的代码控制.每个账户都有一个键值对形式的持久化存储。其中 key 和 value 的长度都是256位，我们称之为 <strong>存储</strong> 。此外，每个账户有一个以太币余额（ <strong>balance</strong> ）（单位是“Wei”, <code>1 ether</code> 是 <code>10**18 wei</code>），余额会因为发送包含以太币的交易而改变。交易可以看作是从一个帐户发送到另一个帐户的消息（这里的账户，可能是相同的或特殊的零帐户，请参阅下文）。它能包含一个二进制数据（合约负载）和以太币。如果目标账户含有代码，此代码会被执行，并以 payload 作为入参。如果目标账户是零账户（账户地址为 <code>0</code> )，此交易将创建一个 <strong>新合约</strong> 。 如前文所述，合约的地址不是零地址，而是通过合约创建者的地址和从该地址发出过的交易数量计算得到的（所谓的“nonce”）。 这个用来创建合约的交易的 payload 会被转换为 EVM 字节码并执行。执行的输出将作为合约代码被永久存储。这意味着，为创建一个合约，你不需要发送实际的合约代码，而是发送能够产生合约代码的代码。</p><p>一经创建，每笔交易都收取一定数量的 <strong>gas</strong> ，目的是限制执行交易所需要的工作量和为交易支付手续费。EVM 执行交易时，gas 将按特定规则逐渐耗尽。<strong>gas price</strong> 是交易发送者设置的一个值，发送者账户需要预付的手续费= <code>gas_price * gas</code> 。如果交易执行后还有剩余， gas 会原路返还。无论执行到什么位置，一旦 gas 被耗尽（比如降为负值），将会触发一个 out-of-gas 异常。当前调用帧（call frame）所做的所有状态修改都将被回滚。译者注：调用帧（call frame），指的是下文讲到的EVM的运行栈（stack）中当前操作所需要的若干元素。</p><p>每个账户有一块持久化内存区称为 <strong>存储</strong> 。 存储是将256位字映射到256位字的键值存储区。 在合约中枚举存储是不可能的，且读存储的相对开销很高，修改存储的开销甚至更高。合约只能读写存储区内属于自己的部分。</p><p>第二个内存区称为 <strong>内存</strong> ，合约会试图为每一次消息调用获取一块被重新擦拭干净的内存实例。 内存是线性的，可按字节级寻址，但读的长度被限制为256位，而写的长度可以是8位或256位。当访问（无论是读还是写）之前从未访问过的内存字（word）时（无论是偏移到该字内的任何位置），内存将按字进行扩展（每个字是256位）。扩容也将消耗一定的gas。 随着内存使用量的增长，其费用也会增高（以平方级别）。</p><p>EVM 不是基于寄存器的，而是基于栈的，因此所有的计算都在一个被称为 <strong>栈（stack）</strong> 的区域执行。 栈最大有1024个元素，每个元素长度是一个字（256位）。对栈的访问只限于其顶端，限制方式为：允许拷贝最顶端的16个元素中的一个到栈顶，或者是交换栈顶元素和下面16个元素中的一个。所有其他操作都只能取最顶的两个（或一个，或更多，取决于具体的操作）元素，运算后，把结果压入栈顶。当然可以把栈上的元素放到存储或内存中。但是无法只访问栈上指定深度的那个元素，除非先从栈顶移除其他元素。</p><p>EVM的指令集量应尽量少，以最大限度地避免可能导致共识问题的错误实现。所有的指令都是针对”256位的字（word）”这个基本的数据类型来进行操作。具备常用的算术、位、逻辑和比较操作。也可以做到有条件和无条件跳转。此外，合约可以访问当前区块的相关属性，比如它的编号和时间戳。</p><p>有一种特殊类型的消息调用，被称为 <strong>委托调用(delegatecall)</strong> 。它和一般的消息调用的区别在于，目标地址的代码将在发起调用的合约的上下文中执行，并且 <code>msg.sender</code> 和 <code>msg.value</code> 不变。 这意味着一个合约可以在运行时从另外一个地址动态加载代码。存储、当前地址和余额都指向发起调用的合约，只有代码是从被调用地址获取的。 这使得 Solidity 可以实现”库“能力：可复用的代码库可以放在一个合约的存储上，如用来实现复杂的数据结构的库。</p><p>有一种特殊的可索引的数据结构，其存储的数据可以一路映射直到区块层级。这个特性被称为 <strong>日志(logs)</strong> ，Solidity用它来实现 <strong>事件(events)</strong> 。合约创建之后就无法访问日志数据，但是这些数据可以从区块链外高效的访问。因为部分日志数据被存储在 <a href="https://en.wikipedia.org/wiki/Bloom_filter" target="_blank" rel="noopener">布隆过滤器（Bloom filter)</a> 中，我们可以高效并且加密安全地搜索日志，所以那些没有下载整个区块链的网络节点（轻客户端）也可以找到这些日志。</p><p>合约代码从区块链上移除的唯一方式是合约在合约地址上的执行自毁操作 <code>selfdestruct</code> 。合约账户上剩余的以太币会发送给指定的目标，然后其存储和代码从状态中被移除。移除一个合约听上去不错，但其实有潜在的危险，如果有人发送以太币到移除的合约，这些以太币将永远提丢失。</p><h4 id="安装Solidity"><a href="#安装Solidity" class="headerlink" title="安装Solidity"></a>安装Solidity</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### 最常用的还是通过nodejs来安装</span></span><br><span class="line">npm install -g solc</span><br><span class="line"></span><br><span class="line">docker run ethereum/solc:stable solc --version</span><br><span class="line"></span><br><span class="line">sudo add-apt-repository ppa:ethereum/ethereum</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install solc</span><br><span class="line"></span><br><span class="line"><span class="comment">## 从源码安装</span></span><br><span class="line">sudo xcodebuild -license accept</span><br></pre></td></tr></table></figure><h4 id="Solidity源文件结构"><a href="#Solidity源文件结构" class="headerlink" title="Solidity源文件结构"></a>Solidity源文件结构</h4><p>源文件中可以包含任意多个 <a href="https://learnblockchain.cn/docs/solidity/structure-of-a-contract.html#contract-structure" target="_blank" rel="noopener">合约定义</a> 、<a href="https://learnblockchain.cn/docs/solidity/layout-of-source-files.html#import" target="_blank" rel="noopener">导入源文件指令</a> 、 <a href="https://learnblockchain.cn/docs/solidity/layout-of-source-files.html#pragma" target="_blank" rel="noopener">版本标识</a> 指令、 <a href="https://learnblockchain.cn/docs/solidity/types.html#structs" target="_blank" rel="noopener">结构体</a> , <a href="https://learnblockchain.cn/docs/solidity/types.html#enums" target="_blank" rel="noopener">枚举</a> 和 <a href="https://learnblockchain.cn/docs/solidity/contracts.html#functions" target="_blank" rel="noopener">函数</a> 定义.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.5</span><span class="number">.2</span>;</span><br></pre></td></tr></table></figure><p>这样，源文件将既不允许低于 0.5.2 版本的编译器编译， 也不允许高于（包含） <code>0.6.0</code> 版本的编译器编译（第二个条件因使用 <code>^</code> 被添加）。 这种做法的考虑是，编译器在 0.6.0 版本之前不会有重大变更，所以可确保源代码始终按预期被编译。 上面例子中不固定编译器的具体版本号，因此编译器的补丁版也可以使用。</p><p>Pragma 是 pragmatic information 的简称，微软 Visual C++ <a href="https://msdn.microsoft.com/zh-cn/library/d9x1s805.aspx" target="_blank" rel="noopener">文档</a> 中译为标识。 Solidity 中沿用 C ，C++ 等中的编译指令概念，用于告知编译器 <strong>如何</strong> 编译。 ——译者注</p><p>第2个标注是用来标注实验性阶段的功能，它可以用来启用一些新的编译器功能或语法特性。 当前支持下面的一些实验性标注: ABIEncoderV2</p><p>新的 ABI 编码器可以用来编码和解码嵌套的数组和结构体，当然这部分代码还在优化之中，他没有像之前 ABI 编码器 那样经过严格的测试，我们可以使用下面的语法来启用它</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pragma experimental ABIEncoderV2;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"filename"</span>;</span><br></pre></td></tr></table></figure><p>ES6 即 ECMAScript 6.0，ES6是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布。 ——译者注</p><p>通常使用相对引用 <code>import &quot;./filename.sol&quot;;</code> 并且避免使用 <code>..</code> ，后面这种方式可以使用全局路径并设置映射，下面会有解释。</p><p>可以使用单行注释（<code>//</code>）和多行注释（<code>/*...*/</code>）</p><p>在 Solidity 语言中，合约类似于其他面向对象编程语言中的<strong>类</strong>。</p><p>每个合约中可以包含 <a href="https://learnblockchain.cn/docs/solidity/structure-of-a-contract.html#structure-state-variables" target="_blank" rel="noopener">状态变量</a>、 <a href="https://learnblockchain.cn/docs/solidity/structure-of-a-contract.html#structure-functions" target="_blank" rel="noopener">函数</a>、<a href="https://learnblockchain.cn/docs/solidity/structure-of-a-contract.html#structure-events" target="_blank" rel="noopener">事件 Event</a>、 <a href="https://learnblockchain.cn/docs/solidity/structure-of-a-contract.html#structure-struct-types" target="_blank" rel="noopener">结构体</a>、 和 <a href="https://learnblockchain.cn/docs/solidity/structure-of-a-contract.html#structure-enum-types" target="_blank" rel="noopener">枚举类型</a> 的声明，且合约可以从其他合约继承。</p><p>还有一些特殊的合约，如： <a href="https://learnblockchain.cn/docs/solidity/contracts.html#libraries" target="_blank" rel="noopener">库</a> 和 <a href="https://learnblockchain.cn/docs/solidity/contracts.html#interfaces" target="_blank" rel="noopener">接口</a>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=<span class="number">0.4</span><span class="number">.0</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract TinyStorage &#123;</span><br><span class="line">    uint storedXlbData; <span class="comment">// 状态变量</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: GPL-3.0</span></span><br><span class="line">pragma solidity &gt;<span class="number">0.7</span><span class="number">.0</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract TinyAuction &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Mybid</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">payable</span> </span>&#123; <span class="comment">// 定义函数</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Helper function defined outside of a contract</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">helper</span>(<span class="params">uint x</span>) <span class="title">pure</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=<span class="number">0.4</span><span class="number">.22</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract MyPurchase &#123;</span><br><span class="line">    address public seller;</span><br><span class="line"></span><br><span class="line">    modifier onlySeller() &#123; <span class="comment">// 修改器</span></span><br><span class="line">        <span class="built_in">require</span>(</span><br><span class="line">            msg.sender == seller,</span><br><span class="line">            <span class="string">"Only seller can call this."</span></span><br><span class="line">        );</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">abort</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">onlySeller</span> </span>&#123; <span class="comment">// 修改器用法</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数 修改器modifier 可以用来以声明的方式修改函数语义（参阅合约章节中 <a href="https://learnblockchain.cn/docs/solidity/contracts.html#modifiers" target="_blank" rel="noopener">函数修改器</a>）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=<span class="number">0.4</span><span class="number">.21</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line">contract TinyAuction &#123;</span><br><span class="line">    event HighestBidIncreased(address bidder, uint amount); <span class="comment">// 事件</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bid</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">payable</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        emit HighestBidIncreased(msg.sender, msg.value); <span class="comment">// 触发事件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事件是能方便地调用以太坊虚拟机日志功能的接口。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=<span class="number">0.4</span><span class="number">.0</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract TinyBallot &#123;</span><br><span class="line">    struct Voter &#123; <span class="comment">// 结构体 结构体是可以将几个变量分组的自定义类型</span></span><br><span class="line">        uint weight;</span><br><span class="line">        bool voted;</span><br><span class="line">        address delegate;</span><br><span class="line">        uint vote;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=<span class="number">0.4</span><span class="number">.0</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract Upchain &#123;</span><br><span class="line">    enum State &#123; Created, Locked, InValid &#125; <span class="comment">// 枚举 枚举可用来创建由一定数量的“常量值”构成的自定义类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h4><p><code>bool</code> ：可能的取值为字面常量值 <code>true</code> 和 <code>false</code> 。</p><p>运算符：</p><ul><li><p><code>!</code> （逻辑非）</p></li><li><p><code>&amp;&amp;</code> （逻辑与， “and” ）</p></li><li><p><code>||</code> （逻辑或， “or” ）</p></li><li><p><code>==</code> （等于）</p></li><li><p><code>!=</code> （不等于）</p><p>运算符 <code>||</code> 和 <code>&amp;&amp;</code> 都遵循同样的短路（ short-circuiting ）规则。就是说在表达式 <code>f(x) || g(y)</code> 中， 如果 <code>f(x)</code> 的值为 <code>true</code> ，那么 <code>g(y)</code> 就不会被执行，即使会出现一些副作用。</p></li></ul><p><code>int</code> / <code>uint</code> ：分别表示有符号和无符号的不同位数的整型变量。 支持关键字 <code>uint8</code> 到 <code>uint256</code> （无符号，从 8 位到 256 位）以及 <code>int8</code> 到 <code>int256</code>，以 <code>8</code> 位为步长递增。 <code>uint</code> 和 <code>int</code> 分别是 <code>uint256</code> 和 <code>int256</code> 的别名。</p><p>运算符：</p><ul><li>比较运算符： <code>&lt;=</code> ， <code>&lt;</code> ， <code>==</code> ， <code>!=</code> ， <code>&gt;=</code> ， <code>&gt;</code> （返回布尔值）</li><li>位运算符： <code>&amp;</code> ， <code>|</code> ， <code>^</code> （异或）， <code>~</code> （位取反）</li><li>移位运算符： <code>&lt;&lt;</code> （左移位） ， <code>&gt;&gt;</code> （右移位）</li><li>算数运算符： <code>+</code> ， <code>-</code> ， 一元运算 <code>-</code> ， 一元运算 <code>+</code> ， <code>*</code> ， <code>/</code> ， <code>%</code> （取余或叫模运算） ， <code>**</code> （幂）</li></ul><p>对于整形 <code>X</code>，可以使用 <code>type(X).min</code> 和 <code>type(X).max</code> 去获取这个类型的最小值与最大值。</p><p>加法，减法和乘法具有通常的语义，值用两进制补码表示，意思是比如：<code>uint256（0） - uint256（1）== 2 ** 256 - 1</code> 。 我们在设计和编写智能合约时必须考虑到溢出问题。</p><p>表达式 <code>-x</code> 相当于 <code>(T(0) - x)</code> 这里 <code>T</code> 是指 <code>x</code> 的类型。 这意味着如果 <code>x</code> 的类型的类型是无符号整数类型 <code>-x</code> 不会是负数。 另外，如果 <code>x</code> 为负数， <code>-x</code> 也可以为正数。 由于两进制补码表示还需要小心:</p><p>除法运算结果的类型始终是其中一个操作数的类型，整数除法总是产生整数。 在Solidity中，分数会取零。 这意味着 <code>int256(-5) / int256(2) == int256(-2)</code></p><p>注意在智能合约中，在 <a href="https://learnblockchain.cn/docs/solidity/types.html#rational-literals" target="_blank" rel="noopener">字面常量</a> 上进行除法会保留精度（保留小数位）。</p><p><strong>除以0 会发生错误（assert 类型错误）。</strong></p><p>模运算 <code>a％n</code> 是在操作数 <code>a</code> 的除以 <code>n</code> 之后产生余数 <code>r</code> ，其中 <code>q = int(a / n)</code> 和 <code>r = a - (n * q)</code> 。 这意味着模运算结果与左操作数相同的符号相同（或零）。 对于 负数的a : <code>a % n == -(a % n)</code>， 几个例子：</p><blockquote><ul><li><code>int256(5) % int256(2) == int256(1)</code></li><li><code>int256(5) % int256(-2) == int256(1)</code></li><li><code>int256(-5) % int256(2) == int256(-1)</code></li><li><code>int256(-5) % int256(-2) == int256(-1)</code></li></ul></blockquote><p>注解, 对0取模会发生错误（assert 类型错误）。</p><p><strong>注意 `0</strong>0<code>在EVM中定义为</code>1` 。**</p><p><code>fixed</code> / <code>ufixed</code>：表示各种大小的有符号和无符号的定长浮点型。 在关键字 <code>ufixedMxN</code> 和 <code>fixedMxN</code> 中，<code>M</code> 表示该类型占用的位数，<code>N</code> 表示可用的小数位数。 <code>M</code> 必须能整除 8，即 8 到 256 位。 <code>N</code> 则可以是从 0 到 80 之间的任意数。 <code>ufixed</code> 和 <code>fixed</code> 分别是 <code>ufixed128x19</code> 和 <code>fixed128x19</code> 的别名。</p><p>地址类型有两种形式，他们大致相同：</p><blockquote><ul><li><code>address</code>：保存一个20字节的值（以太坊地址的大小）。</li><li><code>ddress payable</code> ：可支付地址，与 <code>address</code> 相同，不过有成员函数 <code>transfer</code> 和 <code>send</code> 。</li></ul></blockquote><p>这种区别背后的思想是 <strong><code>address payable</code> 可以接受以太币的地址，而一个普通的 <code>address</code> 则不能</strong>。</p><p>可以使用 <code>balance</code> 属性来查询一个地址的余额， 也可以使用 <code>transfer</code> 函数向一个可支付地址（payable address）发送 以太币Ether （以 wei 为单位）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">address x = 0x123;</span><br><span class="line">address myAddress = this;</span><br><span class="line"><span class="keyword">if</span> (x.balance &lt; 10 &amp;&amp; myAddress.balance &gt;= 10) x.transfer(10);</span><br></pre></td></tr></table></figure><p>如果当前合约的余额不够多，则 <code>transfer</code> 函数会执行失败，或者如果以太转移被接收帐户拒绝， <code>transfer</code> 函数同样会失败而进行回退。</p><p>如果 <code>x</code> 是一个合约地址，它的代码（更具体来说是, 如果有receive函数, 执行 <a href="https://learnblockchain.cn/docs/solidity/contracts.html#receive-ether-function" target="_blank" rel="noopener">receive 接收以太函数</a>, 或者存在fallback函数,执行 <a href="https://learnblockchain.cn/docs/solidity/contracts.html#fallback-function" target="_blank" rel="noopener">Fallback 回退函数</a> 函数）会跟 <code>transfer</code> 函数调用一起执行（这是 EVM 的一个特性，无法阻止）。 如果在执行过程中用光了 gas 或者因为任何原因执行失败，以太币Ether 交易会被打回，当前的合约也会在终止的同时抛出异常。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">警告⚠️：</span><br><span class="line">在使用 send 的时候会有些风险：如果调用栈深度是 1024 会导致发送失败（这总是可以被调用者强制），如果接收者用光了 gas 也会导致发送失败。 所以为了保证 以太币Ether 发送的安全，一定要检查 send 的返回值，使用 transfer 或者更好的办法： 使用接收者自己取回资金的模式。</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bytes memory payload = abi.encodeWithSignature(<span class="string">"register(string)"</span>, <span class="string">"MyName"</span>);</span><br><span class="line">(bool success, bytes memory returnData) = address(nameReg).call(payload);</span><br><span class="line"><span class="built_in">require</span>(success);</span><br><span class="line"></span><br><span class="line">address nameReg = <span class="number">0x72ba7d8e73fe8eb666ea66babc8116a41bfb10e2</span>;</span><br><span class="line">nameReg.call(<span class="string">"register"</span>, <span class="string">"MyName"</span>);</span><br><span class="line">nameReg.call(bytes4(keccak256(<span class="string">"fun(uint256)"</span>)), a);</span><br></pre></td></tr></table></figure><p>所有这些函数都是低级函数，应谨慎使用。 具体来说，任何未知的合约都可能是恶意的，我们在调用一个合约的同时就将控制权交给了它，而合约又可以回调合约，所以要准备好在调用返回时改变相应的状态变量（可参考 <a href="https://learnblockchain.cn/docs/solidity/security-considerations.html#re-entance" target="_blank" rel="noopener">可重入</a> )， 与其他合约交互的常规方法是在合约对象上调用函数（x.f()）。</p><p>所有三个函数 <code>call</code> ，<code>delegatecall</code> 和 <code>staticcall</code> 都是非常低级的函数，应该只把它们当作 <em>最后一招</em> 来使用，因为它们破坏了 Solidity 的类型安全性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">uint128 a = <span class="number">1</span>;</span><br><span class="line">uint128 b = <span class="number">2.5</span> + a + <span class="number">0.5</span>;</span><br><span class="line"></span><br><span class="line">bytes32 samevar = <span class="string">"stringliteral"</span>;</span><br><span class="line">string memory a = unicode<span class="string">"Hello 😃"</span>;</span><br><span class="line">hex<span class="string">"0011223344556677"</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: GPL-3.0</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.4</span><span class="number">.16</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract test &#123;</span><br><span class="line">    enum ActionChoices &#123; GoLeft, GoRight, GoStraight, SitStill &#125;</span><br><span class="line">    ActionChoices choice;</span><br><span class="line">    ActionChoices constant defaultChoice = ActionChoices.GoStraight;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setGoStraight</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        choice = ActionChoices.GoStraight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于枚举类型不属于 |ABI| 的一部分，因此对于所有来自 Solidity 外部的调用，</span></span><br><span class="line">    <span class="comment">// "getChoice" 的签名会自动被改成 "getChoice() returns (uint8)"。</span></span><br><span class="line">    <span class="comment">// 整数类型的大小已经足够存储所有枚举类型的值，随着值的个数增加，</span></span><br><span class="line">    <span class="comment">// 可以逐渐使用 `uint16` 或更大的整数类型。</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getChoice</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">ActionChoices</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> choice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getDefaultChoice</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> uint(defaultChoice);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">&lt;parameter types&gt;</span>) </span>&#123;internal|external&#125; [pure|constant|view|payable] [returns (&lt;return types&gt;)]</span><br></pre></td></tr></table></figure><ul><li><p>内存memory 即数据在内存中，因此数据仅在其生命周期内（函数调用期间）有效。不能用于外部调用。</p></li><li><p>存储storage 状态变量保存的位置，只要合约存在就一直存储．</p></li><li><p>调用数据calldata 用来保存函数参数的特殊数据位置，是一个只读位置。</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: GPL-3.0</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.5</span><span class="number">.0</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract Tiny &#123;</span><br><span class="line">    uint[] x; <span class="comment">// x 的数据存储位置是 storage，　位置可以忽略</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// memoryArray 的数据存储位置是 memory</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">uint[] memory memoryArray</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        x = memoryArray; <span class="comment">// 将整个数组拷贝到 storage 中，可行</span></span><br><span class="line">        uint[] storage y = x;  <span class="comment">// 分配一个指针（其中 y 的数据存储位置是 storage），可行</span></span><br><span class="line">        y[<span class="number">7</span>]; <span class="comment">// 返回第 8 个元素，可行</span></span><br><span class="line">        y.pop(); <span class="comment">// 通过 y 修改 x，可行</span></span><br><span class="line">        <span class="keyword">delete</span> x; <span class="comment">// 清除数组，同时修改 y，可行</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面的就不可行了；需要在 storage 中创建新的未命名的临时数组，</span></span><br><span class="line">        <span class="comment">// 但 storage 是“静态”分配的：</span></span><br><span class="line">        <span class="comment">// y = memoryArray;</span></span><br><span class="line">        <span class="comment">// 下面这一行也不可行，因为这会“重置”指针，</span></span><br><span class="line">        <span class="comment">// 但并没有可以让它指向的合适的存储位置。</span></span><br><span class="line">        <span class="comment">// delete y;</span></span><br><span class="line"></span><br><span class="line">        g(x); <span class="comment">// 调用 g 函数，同时移交对 x 的引用</span></span><br><span class="line">        h(x); <span class="comment">// 调用 h 函数，同时在 memory 中创建一个独立的临时拷贝</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params">uint[] storage </span>) <span class="title">internal</span> <span class="title">pure</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">h</span>(<span class="params">uint[] memory</span>) <span class="title">public</span> <span class="title">pure</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=<span class="number">0.6</span><span class="number">.99</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="built_in">Proxy</span> &#123;</span><br><span class="line">    <span class="comment">/// 被当前合约管理的 客户端合约地址</span></span><br><span class="line">    address client;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(address _client) &#123;</span><br><span class="line">        client = _client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 在进行参数验证之后，转发到由client实现的 "setOwner(address)"</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">forward</span>(<span class="params">bytes calldata _payload</span>) <span class="title">external</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 由于 ABI 解码要求填充的数据（padded data）不能使用</span></span><br><span class="line">        <span class="comment">// abi.decode(_payload[:4], (bytes4)).</span></span><br><span class="line">        bytes4 sig =</span><br><span class="line">            _payload[<span class="number">0</span>] |</span><br><span class="line">            (bytes4(_payload[<span class="number">1</span>]) &gt;&gt; <span class="number">8</span>) |</span><br><span class="line">            (bytes4(_payload[<span class="number">2</span>]) &gt;&gt; <span class="number">16</span>) |</span><br><span class="line">            (bytes4(_payload[<span class="number">3</span>]) &gt;&gt; <span class="number">24</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sig == bytes4(keccak256(<span class="string">"setOwner(address)"</span>))) &#123;</span><br><span class="line">            address owner = abi.decode(_payload[<span class="number">4</span>:], (address));</span><br><span class="line">            <span class="built_in">require</span>(owner != address(<span class="number">0</span>), <span class="string">"Address of owner cannot be zero."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        (bool status,) = client.delegatecall(_payload);</span><br><span class="line">        <span class="built_in">require</span>(status, <span class="string">"Forwarded call failed."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: GPL-3.0</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.4</span><span class="number">.0</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract MappingExample &#123;</span><br><span class="line">    mapping(<span class="function"><span class="params">address</span> =&gt;</span> uint) public balances;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params">uint newBalance</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        balances[msg.sender] = newBalance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract MappingLBC &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">        MappingExample m = <span class="keyword">new</span> MappingExample();</span><br><span class="line">        m.update(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">return</span> m.balances(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: GPL-3.0</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.4</span><span class="number">.22</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract MappingExample &#123;</span><br><span class="line"></span><br><span class="line">    mapping (<span class="function"><span class="params">address</span> =&gt;</span> uint256) private _balances;</span><br><span class="line">    mapping (<span class="function"><span class="params">address</span> =&gt;</span> mapping (<span class="function"><span class="params">address</span> =&gt;</span> uint256)) private _allowances;</span><br><span class="line"></span><br><span class="line">    event Transfer(address indexed <span class="keyword">from</span>, address indexed to, uint256 value);</span><br><span class="line">    event Approval(address indexed owner, address indexed spender, uint256 value);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">allowance</span>(<span class="params">address owner, address spender</span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">uint256</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _allowances[owner][spender];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">transferFrom</span>(<span class="params">address sender, address recipient, uint256 amount</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">bool</span>) </span>&#123;</span><br><span class="line">        _transfer(sender, recipient, amount);</span><br><span class="line">        approve(sender, msg.sender, amount);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">approve</span>(<span class="params">address owner, address spender, uint256 amount</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">bool</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(owner != address(<span class="number">0</span>), <span class="string">"ERC20: approve from the zero address"</span>);</span><br><span class="line">        <span class="built_in">require</span>(spender != address(<span class="number">0</span>), <span class="string">"ERC20: approve to the zero address"</span>);</span><br><span class="line"></span><br><span class="line">        _allowances[owner][spender] = amount;</span><br><span class="line">        emit Approval(owner, spender, amount);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">_transfer</span>(<span class="params">address sender, address recipient, uint256 amount</span>) <span class="title">internal</span> </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(sender != address(<span class="number">0</span>), <span class="string">"ERC20: transfer from the zero address"</span>);</span><br><span class="line">        <span class="built_in">require</span>(recipient != address(<span class="number">0</span>), <span class="string">"ERC20: transfer to the zero address"</span>);</span><br><span class="line"></span><br><span class="line">        _balances[sender] -= amount;</span><br><span class="line">        _balances[recipient] += amount;</span><br><span class="line">        emit Transfer(sender, recipient, amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: GPL-3.0</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.6</span><span class="number">.0</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">struct IndexValue &#123; uint keyIndex; uint value; &#125;</span><br><span class="line">struct KeyFlag &#123; uint key; bool deleted; &#125;</span><br><span class="line"></span><br><span class="line">struct itmap &#123;</span><br><span class="line">    mapping(<span class="function"><span class="params">uint</span> =&gt;</span> IndexValue) data;</span><br><span class="line">    KeyFlag[] keys;</span><br><span class="line">    uint size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">library IterableMapping &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params">itmap storage self, uint key, uint value</span>) <span class="title">internal</span> <span class="title">returns</span> (<span class="params">bool replaced</span>) </span>&#123;</span><br><span class="line">        uint keyIndex = self.data[key].keyIndex;</span><br><span class="line">        self.data[key].value = value;</span><br><span class="line">        <span class="keyword">if</span> (keyIndex &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            keyIndex = self.keys.length;</span><br><span class="line"></span><br><span class="line">            self.keys.push();</span><br><span class="line">            self.data[key].keyIndex = keyIndex + <span class="number">1</span>;</span><br><span class="line">            self.keys[keyIndex].key = key;</span><br><span class="line">            self.size++;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params">itmap storage self, uint key</span>) <span class="title">internal</span> <span class="title">returns</span> (<span class="params">bool success</span>) </span>&#123;</span><br><span class="line">        uint keyIndex = self.data[key].keyIndex;</span><br><span class="line">        <span class="keyword">if</span> (keyIndex == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">delete</span> self.data[key];</span><br><span class="line">        self.keys[keyIndex - <span class="number">1</span>].deleted = <span class="literal">true</span>;</span><br><span class="line">        self.size --;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">contains</span>(<span class="params">itmap storage self, uint key</span>) <span class="title">internal</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">bool</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> self.data[key].keyIndex &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">iterate_start</span>(<span class="params">itmap storage self</span>) <span class="title">internal</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">uint keyIndex</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> iterate_next(self, uint(<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">iterate_valid</span>(<span class="params">itmap storage self, uint keyIndex</span>) <span class="title">internal</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">bool</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> keyIndex &lt; self.keys.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">iterate_next</span>(<span class="params">itmap storage self, uint keyIndex</span>) <span class="title">internal</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">uint r_keyIndex</span>) </span>&#123;</span><br><span class="line">        keyIndex++;</span><br><span class="line">        <span class="keyword">while</span> (keyIndex &lt; self.keys.length &amp;&amp; self.keys[keyIndex].deleted)</span><br><span class="line">            keyIndex++;</span><br><span class="line">        <span class="keyword">return</span> keyIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">iterate_get</span>(<span class="params">itmap storage self, uint keyIndex</span>) <span class="title">internal</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">uint key, uint value</span>) </span>&#123;</span><br><span class="line">        key = self.keys[keyIndex].key;</span><br><span class="line">        value = self.data[key].value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如何使用</span></span><br><span class="line">contract User &#123;</span><br><span class="line">    <span class="comment">// Just a struct holding our data.</span></span><br><span class="line">    itmap data;</span><br><span class="line">    <span class="comment">// Apply library functions to the data type.</span></span><br><span class="line">    using IterableMapping <span class="keyword">for</span> itmap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Insert something</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params">uint k, uint v</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">uint size</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// This calls IterableMapping.insert(data, k, v)</span></span><br><span class="line">        data.insert(k, v);</span><br><span class="line">        <span class="comment">// We can still access members of the struct,</span></span><br><span class="line">        <span class="comment">// but we should take care not to mess with them.</span></span><br><span class="line">        <span class="keyword">return</span> data.size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Computes the sum of all stored data.</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">uint s</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (</span><br><span class="line">            uint i = data.iterate_start();</span><br><span class="line">            data.iterate_valid(i);</span><br><span class="line">            i = data.iterate_next(i)</span><br><span class="line">        ) &#123;</span><br><span class="line">            (, uint value) = data.iterate_get(i);</span><br><span class="line">            s += value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>映射本身是无法遍历的，即无法枚举所有的键。不过，可以在它们之上实现一个数据结构来进行迭代。 例如，以下代码实现了 <code>IterableMapping</code> 库，然后　<code>User</code> 合约可以添加数据，　<code>sum</code>　函数迭代求和所有值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: GPL-3.0</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.4</span><span class="number">.0</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract DeleteLBC &#123;</span><br><span class="line">    uint data;</span><br><span class="line">    uint[] dataArray;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        uint x = data;</span><br><span class="line">        <span class="keyword">delete</span> x; <span class="comment">// 将 x 设为 0，并不影响数据</span></span><br><span class="line">        <span class="keyword">delete</span> data; <span class="comment">// 将 data 设为 0，并不影响 x，因为它仍然有个副本</span></span><br><span class="line">        uint[] storage y = dataArray;</span><br><span class="line">        <span class="keyword">delete</span> dataArray;</span><br><span class="line">        <span class="comment">// 将 dataArray.length 设为 0，但由于 uint[] 是一个复杂的对象，y 也将受到影响，</span></span><br><span class="line">        <span class="comment">// 因为它是一个存储位置是 storage 的对象的别名。</span></span><br><span class="line">        <span class="comment">// 另一方面："delete y" 是非法的，引用了 storage 对象的局部变量只能由已有的 storage 对象赋值。</span></span><br><span class="line">        assert(y.length == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">uint8 y;</span><br><span class="line">uint16 z;</span><br><span class="line">uint32 x = y + z;</span><br><span class="line">int8 y = <span class="number">-3</span>;</span><br><span class="line">uint x = uint(y);</span><br><span class="line">uint32 a = <span class="number">0x12345678</span>;</span><br><span class="line">uint16 b = uint16(a); <span class="comment">// 此时 b 的值是 0x5678</span></span><br><span class="line">uint16 a = <span class="number">0x1234</span>;</span><br><span class="line">uint32 b = uint32(a); <span class="comment">// b 为 0x00001234 now</span></span><br><span class="line">assert(a == b);</span><br></pre></td></tr></table></figure><h4 id="单位和全局变量"><a href="#单位和全局变量" class="headerlink" title="单位和全局变量"></a>单位和全局变量</h4><p>以太币Ether 单位之间的换算就是在数字后边加上 <code>wei</code>、<code>gwei</code> 或 <code>ether</code> 来实现的，如果后面没有单位，缺省为 wei。例如 <code>2 ether == 2000 finney</code> 的逻辑判断值为 <code>true</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">assert(<span class="number">1</span> wei == <span class="number">1</span>);</span><br><span class="line">assert(<span class="number">1</span> gwei == <span class="number">1e9</span>);</span><br><span class="line">assert(<span class="number">1</span> ether == <span class="number">1e18</span>);</span><br></pre></td></tr></table></figure><p>这些后缀不能直接用在变量后边。如果想用时间单位（例如 days）来将输入变量换算为时间，你可以用如下方式来完成：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> == <span class="number">1</span> seconds</span><br><span class="line"><span class="number">1</span> minutes == <span class="number">60</span> seconds</span><br><span class="line"><span class="number">1</span> hours == <span class="number">60</span> minutes</span><br><span class="line"><span class="number">1</span> days == <span class="number">24</span> hours</span><br><span class="line"><span class="number">1</span> weeks == <span class="number">7</span> days</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">uint start, uint daysAfter</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (block.timestamp &gt;= start + daysAfter * <span class="number">1</span> days) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这些编码函数可以用来构造函数调用数据，而不用实际进行调用。此外，keccak256(abi.encodePacked(a, b)) 是一种计算结构化数据的哈希值（尽管我们也应该关注到：使用不同的函数参数类型也有可能会引起“哈希冲突” ）的方式，不推荐使用的 keccak256(a, b) 。</span><br></pre></td></tr></table></figure><h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>可以参阅专门的章节 <a href="https://learnblockchain.cn/docs/solidity/control-structures.html#assert-and-require" target="_blank" rel="noopener">assert and require</a> 参阅有关错误处理以及何时使用哪个函数的更多详细信息。</p><ul><li><p><code>assert(bool condition)</code></p><p>如果不满足条件，则会导致无效的操作码，则撤销状态更改 - 用于检查内部错误。</p></li><li><p><code>require(bool condition)</code></p><p>如果条件不满足则撤销状态更改 - 用于检查由输入或者外部组件引起的错误。</p></li><li><p><code>require(bool condition, string memory message)</code></p><p>如果条件不满足则撤销状态更改 - 用于检查由输入或者外部组件引起的错误，可以同时提供一个错误消息。</p></li><li><p><code>revert()</code></p><p>终止运行并撤销状态更改。</p></li><li><p><code>revert(string memory reason)</code></p><p>终止运行并撤销状态更改，可以同时提供一个解释性的字符串。</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=<span class="number">0.5</span><span class="number">.0</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    uint index;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">uint, bool, uint</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">7</span>, <span class="literal">true</span>, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="comment">//基于返回的元组来声明变量并赋值</span></span><br><span class="line">        (uint x, bool b, uint y) = f();</span><br><span class="line">        <span class="comment">//交换两个值的通用窍门——但不适用于非值类型的存储 (storage) 变量。</span></span><br><span class="line">        (x, y) = (y, x);</span><br><span class="line">        <span class="comment">//元组的末尾元素可以省略（这也适用于变量声明）。</span></span><br><span class="line">        (index,,) = f(); <span class="comment">// 设置 index 为 7</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=<span class="number">0.5</span><span class="number">.0</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract Sharer &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sendHalf</span>(<span class="params">address addr</span>) <span class="title">public</span> <span class="title">payable</span> <span class="title">returns</span> (<span class="params">uint balance</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(msg.value % <span class="number">2</span> == <span class="number">0</span>, <span class="string">"Even value required."</span>);</span><br><span class="line">        uint balanceBeforeTransfer = <span class="keyword">this</span>.balance;</span><br><span class="line">        addr.transfer(msg.value / <span class="number">2</span>);</span><br><span class="line">                    <span class="comment">//由于转移函数在失败时抛出异常并且不能在这里回调，因此我们应该没有办法仍然有一半的钱。</span></span><br><span class="line">        assert(<span class="keyword">this</span>.balance == balanceBeforeTransfer - msg.value / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在内部， Solidity 对一个 <code>require</code> 式的异常执行回退操作（指令 <code>0xfd</code> ）并执行一个无效操作（指令 <code>0xfe</code> ）来引发 <code>assert</code> 式异常。 在这两种情况下，都会导致 EVM 回退对状态所做的所有更改。回退的原因是不能继续安全地执行，因为没有实现预期的效果。</p><p>在这两种情况下，调用者都可以使用 <code>try</code>/<code>catch</code> 来应对此类失败（在<code>assert</code>类型的异常中,仅在剩余足够gas的情况下才行 ），但是调用者中的更改将始终被还原。</p><p>请注意， <code>assert</code> 式异常消耗了所有可用的调用 gas ，<strong>而从 Metropolis 版本起 <code>require</code> 式的异常不会消耗任何 gas。 </strong>这里还是尽量使用require.</p><h4 id="合约"><a href="#合约" class="headerlink" title="合约"></a>合约</h4><h4 id="Solidity-合约类似于面向对象语言中的类。合约中有用于数据持久化的状态变量，和可以修改状态变量的函数。-调用另一个合约实例的函数时，会执行一个-EVM-函数调用，这个操作会切换执行时的上下文，这样，前一个合约的状态变量就不能访问了。"><a href="#Solidity-合约类似于面向对象语言中的类。合约中有用于数据持久化的状态变量，和可以修改状态变量的函数。-调用另一个合约实例的函数时，会执行一个-EVM-函数调用，这个操作会切换执行时的上下文，这样，前一个合约的状态变量就不能访问了。" class="headerlink" title="Solidity 合约类似于面向对象语言中的类。合约中有用于数据持久化的状态变量，和可以修改状态变量的函数。 调用另一个合约实例的函数时，会执行一个 EVM 函数调用，这个操作会切换执行时的上下文，这样，前一个合约的状态变量就不能访问了。"></a>Solidity 合约类似于面向对象语言中的类。合约中有用于数据持久化的状态变量，和可以修改状态变量的函数。 调用另一个合约实例的函数时，会执行一个 EVM 函数调用，这个操作会切换执行时的上下文，这样，前一个合约的状态变量就不能访问了。</h4><p>可以通过以太坊交易“从外部”或从 Solidity 合约内部创建合约。</p><p>一些集成开发环境，例如 <a href="https://remix.ethereum.org/" target="_blank" rel="noopener">Remix</a>, 通过使用一些UI用户界面使创建合约的过程更加顺畅。 在以太坊上通过编程创建合约最好使用 JavaScript API <a href="https://github.com/ethereum/web3.js" target="_blank" rel="noopener">web3.js</a>。 现在，我们已经有了一个叫做 <a href="https://web3js.readthedocs.io/en/1.0/web3-eth-contract.html#new-contract" target="_blank" rel="noopener">web3.eth.Contract</a> 的方法能够更容易的创建合约。</p><p>创建合约时， 合约的 <a href="https://learnblockchain.cn/docs/solidity/contracts.html#constructor" target="_blank" rel="noopener">构造函数</a> (一个用关键字 <code>constructor</code> 声明的函数)会执行一次。 构造函数是可选的。只允许有一个构造函数，这意味着不支持重载。</p><p>构造函数执行完毕后，合约的最终代码将部署到区块链上。此代码包括所有公共和外部函数以及所有可以通过函数调用访问的函数。 部署的代码没有 包括构造函数代码或构造函数调用的内部函数。</p><p>在内部，构造函数参数在合约代码之后通过 <a href="https://learnblockchain.cn/docs/solidity/abi-spec.html#abi" target="_blank" rel="noopener">ABI 编码</a> 传递，但是如果你使用 <code>web3.js</code> 则不必关心这个问题。</p><p>如果一个合约想要创建另一个合约，那么创建者必须知晓被创建合约的源代码(和二进制代码)。 这意味着不可能循环创建依赖项。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=<span class="number">0.4</span><span class="number">.22</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract OwnedToken &#123;</span><br><span class="line">    <span class="comment">// TokenCreator 是如下定义的合约类型.</span></span><br><span class="line">    <span class="comment">// 不创建新合约的话，也可以引用它。</span></span><br><span class="line">    TokenCreator creator;</span><br><span class="line">    address owner;</span><br><span class="line">    bytes32 name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这是注册 creator 和设置名称的构造函数。</span></span><br><span class="line">    <span class="keyword">constructor</span>(bytes32 _name) &#123;</span><br><span class="line">        <span class="comment">// 状态变量通过其名称访问，而不是通过例如 this.owner 的方式访问。</span></span><br><span class="line">        <span class="comment">// 这也适用于函数，特别是在构造函数中，你只能像这样（“内部地”）调用它们，</span></span><br><span class="line">        <span class="comment">// 因为合约本身还不存在。</span></span><br><span class="line">        owner = msg.sender;</span><br><span class="line">        <span class="comment">// 从 `address` 到 `TokenCreator` ，是做显式的类型转换</span></span><br><span class="line">        <span class="comment">// 并且假定调用合约的类型是 TokenCreator，没有真正的方法来检查这一点。</span></span><br><span class="line">        creator = TokenCreator(msg.sender);</span><br><span class="line">        name = _name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">changeName</span>(<span class="params">bytes32 newName</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 只有 creator （即创建当前合约的合约）能够更改名称 —— 因为合约是隐式转换为地址的，</span></span><br><span class="line">        <span class="comment">// 所以这里的比较是可行的。</span></span><br><span class="line">        <span class="keyword">if</span> (msg.sender == address(creator))</span><br><span class="line">            name = newName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">transfer</span>(<span class="params">address newOwner</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 只有当前所有者才能发送 token。</span></span><br><span class="line">        <span class="keyword">if</span> (msg.sender != owner) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 我们也想询问 creator 是否可以发送。</span></span><br><span class="line">        <span class="comment">// 请注意，这里调用了一个下面定义的合约中的函数。</span></span><br><span class="line">        <span class="comment">// 如果调用失败（比如，由于 gas 不足），会立即停止执行。</span></span><br><span class="line">        <span class="keyword">if</span> (creator.isTokenTransferOK(owner, newOwner))</span><br><span class="line">            owner = newOwner;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract TokenCreator &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">createToken</span>(<span class="params">bytes32 name</span>)</span></span><br><span class="line"><span class="function">       <span class="title">public</span></span></span><br><span class="line"><span class="function">       <span class="title">returns</span> (<span class="params">OwnedToken tokenAddress</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个新的 Token 合约并且返回它的地址。</span></span><br><span class="line">        <span class="comment">// 从 JavaScript 方面来说，返回类型是简单的 `address` 类型，因为</span></span><br><span class="line">        <span class="comment">// 这是在 ABI 中可用的最接近的类型。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OwnedToken(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">changeName</span>(<span class="params">OwnedToken tokenAddress, bytes32 name</span>)  <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 同样，`tokenAddress` 的外部类型也是 `address` 。</span></span><br><span class="line">        tokenAddress.changeName(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">isTokenTransferOK</span>(<span class="params">address currentOwner, address newOwner</span>)</span></span><br><span class="line"><span class="function">        <span class="title">public</span></span></span><br><span class="line"><span class="function">        <span class="title">view</span></span></span><br><span class="line"><span class="function">        <span class="title">returns</span> (<span class="params">bool ok</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 检查一些任意的情况。</span></span><br><span class="line">        address tokenAddress = msg.sender;</span><br><span class="line">        <span class="keyword">return</span> (keccak256(newOwner) &amp; <span class="number">0xff</span>) == (bytes20(tokenAddress) &amp; <span class="number">0xff</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 Solidity 有两种函数调用（内部调用不会产生实际的 EVM 调用或称为“消息调用”，而外部调用则会产生一个 EVM 调用）， 函数和状态变量有四种可见性类型。 函数可以指定为 <code>external</code> ，<code>public</code> ，<code>internal</code> 或者 <code>private</code>。 对于状态变量，不能设置为 <code>external</code> ，默认是 <code>internal</code> 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">external</span><br></pre></td></tr></table></figure><p>外部函数作为合约接口的一部分，意味着我们可以从其他合约和交易中调用。 一个外部函数 <code>f</code> 不能从内部调用（即 <code>f</code> 不起作用，但 <code>this.f()</code> 可以）。 当收到大量数据的时候，外部函数有时候会更有效率，因为数据不会从calldata复制到内存.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public</span><br></pre></td></tr></table></figure><p>public 函数是合约接口的一部分，可以在内部或通过消息调用。对于 public 状态变量， 会自动生成一个 getter 函数（见下面）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">internal</span><br></pre></td></tr></table></figure><p>这些函数和状态变量只能是内部访问（即从当前合约内部或从它派生的合约访问），不使用 <code>this</code> 调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private</span><br></pre></td></tr></table></figure><p>private 函数和状态变量仅在当前定义它们的合约中使用，并且不能被派生合约使用。</p><p><strong>合约中的所有内容对外部观察者都是可见的。设置一些 <code>private</code> 类型只能阻止其他合约访问和修改这些信息， 但是对于区块链外的整个世界它仍然是可见的。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: GPL-3.0</span></span><br><span class="line">pragma solidity &gt;<span class="number">0.7</span><span class="number">.0</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract owned &#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123; owner = msg.sender; &#125;</span><br><span class="line"></span><br><span class="line">    address owner;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个合约只定义一个修改器，但并未使用： 它将会在派生合约中用到。</span></span><br><span class="line">    <span class="comment">// 修改器所修饰的函数体会被插入到特殊符号 _; 的位置。</span></span><br><span class="line">    <span class="comment">// 这意味着如果是 owner 调用这个函数，则函数会被执行，否则会抛出异常。</span></span><br><span class="line">    modifier onlyOwner &#123;</span><br><span class="line">        <span class="built_in">require</span>(</span><br><span class="line">            msg.sender == owner,</span><br><span class="line">            <span class="string">"Only owner can call this function."</span></span><br><span class="line">        );</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract destructible is owned &#123;</span><br><span class="line">    <span class="comment">// 这个合约从 `owned` 继承了 `onlyOwner` 修饰符，并将其应用于 `destroy` 函数，</span></span><br><span class="line">    <span class="comment">// 只有在合约里保存的 owner 调用 `destroy` 函数，才会生效。</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">destroy</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">onlyOwner</span> </span>&#123;</span><br><span class="line">        selfdestruct(owner);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract priced &#123;</span><br><span class="line">    <span class="comment">// 修改器可以接收参数：</span></span><br><span class="line">    modifier costs(uint price) &#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.value &gt;= price) &#123;</span><br><span class="line">            _;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Register is priced, destructible &#123;</span><br><span class="line">    mapping (<span class="function"><span class="params">address</span> =&gt;</span> bool) registeredAddresses;</span><br><span class="line">    uint price;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(uint initialPrice) &#123; price = initialPrice; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在这里也使用关键字 `payable` 非常重要，否则函数会自动拒绝所有发送给它的以太币。</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">register</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">payable</span> <span class="title">costs</span>(<span class="params">price</span>) </span>&#123;</span><br><span class="line">        registeredAddresses[msg.sender] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">changePrice</span>(<span class="params">uint _price</span>) <span class="title">public</span> <span class="title">onlyOwner</span> </span>&#123;</span><br><span class="line">        price = _price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Mutex &#123;</span><br><span class="line">    bool locked;</span><br><span class="line">    modifier noReentrancy() &#123;</span><br><span class="line">        <span class="built_in">require</span>(</span><br><span class="line">            !locked,</span><br><span class="line">            <span class="string">"Reentrant call."</span></span><br><span class="line">        );</span><br><span class="line">        locked = <span class="literal">true</span>;</span><br><span class="line">        _;</span><br><span class="line">        locked = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个函数受互斥量保护，这意味着 `msg.sender.call` 中的重入调用不能再次调用  `f`。</span></span><br><span class="line">    <span class="comment">// `return 7` 语句指定返回值为 7，但修改器中的语句 `locked = false` 仍会执行。</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">noReentrancy</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">        (bool success,) = msg.sender.call(<span class="string">""</span>);</span><br><span class="line">        <span class="built_in">require</span>(success);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">7</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: GPL-3.0</span></span><br><span class="line">pragma solidity &gt;<span class="number">0.6</span><span class="number">.99</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    uint constant X = <span class="number">32</span>**<span class="number">22</span> + <span class="number">8</span>;</span><br><span class="line">    string constant TEXT = <span class="string">"abc"</span>;</span><br><span class="line">    bytes32 constant MY_HASH = keccak256(<span class="string">"abc"</span>);</span><br><span class="line">    uint immutable decimals;</span><br><span class="line">    uint immutable maxBalance;</span><br><span class="line">    address immutable owner = msg.sender;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(uint _decimals, address _reference) &#123;</span><br><span class="line">        decimals = _decimals;</span><br><span class="line">        <span class="comment">// Assignments to immutables can even access the environment.</span></span><br><span class="line">        maxBalance = _reference.balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">isBalanceTooHigh</span>(<span class="params">address _other</span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">bool</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _other.balance &gt; maxBalance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果状态变量声明为 <code>constant</code> (常量)。在这种情况下，只能使用那些在编译时有确定值的表达式来给它们赋值。 任何通过访问 storage，区块链数据（例如 <code>block.timestamp</code>, <code>address(this).balance</code> 或者 <code>block.number</code>）或执行数据（ <code>msg.value</code> 或 <code>gasleft()</code> ） 或对外部合约的调用来给它们赋值都是不允许的。</p><p>允许可能对内存分配产生副作用（side-effect）的表达式，但那些可能对其他内存对象产生副作用的表达式则不允许。</p><p>内建（built-in）函数 <code>keccak256</code> ， <code>sha256</code> ， <code>ripemd160</code> ， <code>ecrecover</code> ， <code>addmod</code> 和 <code>mulmod</code> 是允许的（即使他们确实会调用外部合约， <code>keccak256</code> 除外）。</p><p>允许内存分配器的副作用的原因是它可以构造复杂的对象，例如： 查找表（lookup-table）。 此功能尚不完全可用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: GPL-3.0</span></span><br><span class="line">pragma solidity &gt;<span class="number">0.8</span><span class="number">.0</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">uint[] memory _arr</span>) <span class="title">pure</span> <span class="title">returns</span> (<span class="params">uint s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; _arr.length; i++)</span><br><span class="line">        s += _arr[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract ArrayExample &#123;</span><br><span class="line">    bool found;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">uint[] memory _arr</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="comment">// This calls the free function internally.</span></span><br><span class="line">        <span class="comment">// The compiler will add its code to the contract.</span></span><br><span class="line">        uint s = sum(_arr);</span><br><span class="line">        <span class="built_in">require</span>(s &gt;= <span class="number">10</span>);</span><br><span class="line">        found = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=<span class="number">0.4</span><span class="number">.16</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract Simple &#123;</span><br><span class="line">    uint sum;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">taker</span>(<span class="params">uint _a, uint _b</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        sum = _a + _b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pragma solidity &gt;=<span class="number">0.4</span><span class="number">.16</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract Simple &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">arithmetic</span>(<span class="params">uint _a, uint _b</span>)</span></span><br><span class="line"><span class="function">        <span class="title">public</span></span></span><br><span class="line"><span class="function">        <span class="title">pure</span></span></span><br><span class="line"><span class="function">        <span class="title">returns</span> (<span class="params">uint o_sum, uint o_product</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        o_sum = _a + _b;</span><br><span class="line">        o_product = _a * _b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity  &gt;=<span class="number">0.5</span><span class="number">.0</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">uint a, uint b</span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a * (b + <span class="number">42</span>) + block.timestamp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Getter 方法自动被标记为 <code>view</code>。<code>constant</code> 之前是 <code>view</code> 的别名，不过在0.5.0之后移除了。函数可以声明为 <code>pure</code> ，在这种情况下，承诺不读取也不修改状态。</p><p>一个合约最多有一个 <code>receive</code> 函数, 声明函数为： <code>receive() external payable { ... }</code></p><p>不需要 <code>function</code> 关键字，也没有参数和返回值并且必须是　<code>external</code>　可见性和　<code>payable</code> 修饰． 在对合约没有任何附加数据调用（通常是对合约转账）是会执行 <code>receive</code> 函数．　例如　通过 <code>.send()</code> or <code>.transfer()</code> 如果 <code>receive</code> 函数不存在，　但是有payable　的 <a href="https://learnblockchain.cn/docs/solidity/contracts.html#fallback-function" target="_blank" rel="noopener">fallback 回退函数</a> 那么在进行纯以太转账时，fallback 函数会调用．</p><p>如果两个函数都没有，这个合约就没法通过常规的转账交易接收以太（会抛出异常）．</p><p>更糟的是，fallback函数可能只有 2300 gas 可以使用（如，当使用 <code>send</code> 或 <code>transfer</code> 时）， 除了基础的日志输出之外，进行其他操作的余地很小。下面的操作消耗会操作 2300 gas :</p><ul><li><p>写入存储</p></li><li><p>创建合约</p></li><li><p>调用消耗大量 gas 的外部函数</p></li><li><p>发送以太币</p></li></ul><p>一个没有定义 fallback 函数或　 receive 函数的合约，直接接收以太币（没有函数调用，即使用 <code>send</code> 或 <code>transfer</code>）会抛出一个异常， 并返还以太币（在 Solidity v0.4.0 之前行为会有所不同）。 所以如果你想让你的合约接收以太币，必须实现receive函数（使用 payable　fallback 函数不再推荐，因为它会让借口混淆）。 这个之前调试老版本的合约中出现过异常的情况。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=<span class="number">0.6</span><span class="number">.2</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    <span class="comment">// 发送到这个合约的所有消息都会调用此函数（因为该合约没有其它函数）。</span></span><br><span class="line">    <span class="comment">// 向这个合约发送以太币会导致异常，因为 fallback 函数没有 `payable` 修饰符</span></span><br><span class="line">    fallback() external &#123; x = <span class="number">1</span>; &#125;</span><br><span class="line">    uint x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个合约会保留所有发送给它的以太币，没有办法返还。</span></span><br><span class="line">contract TestPayable &#123;</span><br><span class="line">    <span class="comment">// 除了纯转账外，所有的调用都会调用这个函数．</span></span><br><span class="line">    <span class="comment">// (因为除了 receive 函数外，没有其他的函数).</span></span><br><span class="line">    <span class="comment">// 任何对合约非空calldata 调用会执行回退函数(即使是调用函数附加以太).</span></span><br><span class="line">    fallback() external payable &#123; x = <span class="number">1</span>; y = msg.value; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 纯转账调用这个函数，例如对每个空empty calldata的调用</span></span><br><span class="line">    receive() external payable &#123; x = <span class="number">2</span>; y = msg.value; &#125;</span><br><span class="line">    uint x;</span><br><span class="line">    uint y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Caller &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">callTest</span>(<span class="params">Test test</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">bool</span>) </span>&#123;</span><br><span class="line">        (bool success,) = address(test).call(abi.encodeWithSignature(<span class="string">"nonExistingFunction()"</span>));</span><br><span class="line">        <span class="built_in">require</span>(success);</span><br><span class="line">        <span class="comment">//  test.x 结果变成 == 1。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// address(test) 不允许直接调用 ``send`` ,  因为 ``test`` 没有 payable 回退函数</span></span><br><span class="line">        <span class="comment">//  转化为 ``address payable`` 类型 , 然后才可以调用 ``send``</span></span><br><span class="line">        address payable testPayable = payable(address(test));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以下将不会编译，但如果有人向该合约发送以太币，交易将失败并拒绝以太币。</span></span><br><span class="line">        <span class="comment">// test.send(2 ether）;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">callTestPayable</span>(<span class="params">TestPayable test</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">bool</span>) </span>&#123;</span><br><span class="line">        (bool success,) = address(test).call(abi.encodeWithSignature(<span class="string">"nonExistingFunction()"</span>));</span><br><span class="line">        <span class="built_in">require</span>(success);</span><br><span class="line">        <span class="comment">// 结果 test.x 为 1  test.y 为 0.</span></span><br><span class="line">        (success,) = address(test).call&#123;<span class="attr">value</span>: <span class="number">1</span>&#125;(abi.encodeWithSignature(<span class="string">"nonExistingFunction()"</span>));</span><br><span class="line">        <span class="built_in">require</span>(success);</span><br><span class="line">        <span class="comment">// 结果test.x 为1 and test.y 为 1.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送以太币, TestPayable 的 receive　函数被调用．</span></span><br><span class="line">        <span class="built_in">require</span>(address(test).send(<span class="number">2</span> ether));</span><br><span class="line">        <span class="comment">// 结果 in test.x 为 2 and test.y 为 2 ether.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">    fromBlock: <span class="number">0</span>,</span><br><span class="line">    address: web3.eth.defaultAccount,</span><br><span class="line">    topics: [<span class="string">"0x0000000000000000000000000000000000000000000000000000000000000000"</span>, <span class="literal">null</span>, <span class="literal">null</span>]</span><br><span class="line">&#125;;</span><br><span class="line">web3.eth.subscribe(<span class="string">'logs'</span>, options, <span class="function"><span class="keyword">function</span> (<span class="params">error, result</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!error)</span><br><span class="line">        <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;)</span><br><span class="line">    .on(<span class="string">"data"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">log</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(log);</span><br><span class="line">    &#125;)</span><br><span class="line">    .on(<span class="string">"changed"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">log</span>) </span>&#123;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>关于web3 subscribe的描述</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=<span class="number">0.4</span><span class="number">.10</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">payable</span> </span>&#123;</span><br><span class="line">        bytes32 _id = <span class="number">0x420042</span>;</span><br><span class="line">        log3(</span><br><span class="line">            bytes32(msg.value),</span><br><span class="line">            bytes32(<span class="number">0x50cb9fe53daa9737b786ab3646f04d0150dc50ef4e75f59509d83667ad5adb20</span>),</span><br><span class="line">            bytes32(msg.sender),</span><br><span class="line">            _id</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>日志的底层接口</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// SPDX-License-Identifier: GPL-3.0</span></span><br><span class="line">   pragma solidity &gt;<span class="number">0.6</span><span class="number">.99</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">   contract Owned &#123;</span><br><span class="line">       <span class="keyword">constructor</span>() public &#123; owner = msg.sender; &#125;</span><br><span class="line">       address payable owner;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 使用 is 从另一个合约派生。派生合约可以访问所有非私有成员，包括内部（internal）函数和状态变量，</span></span><br><span class="line">   <span class="comment">// 但无法通过 this 来外部访问。</span></span><br><span class="line">   contract Destructible is Owned &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关键字`virtual`表示该函数可以在派生类中“overriding”。</span></span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">function</span> <span class="title">destroy</span>(<span class="params"></span>) <span class="title">virtual</span> <span class="title">public</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (msg.sender == owner) selfdestruct(owner);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 这些抽象合约仅用于给编译器提供接口。</span></span><br><span class="line">   <span class="comment">// 注意函数没有函数体。</span></span><br><span class="line">   <span class="comment">// 如果一个合约没有实现所有函数，则只能用作接口。</span></span><br><span class="line">   abstract contract Config &#123;</span><br><span class="line">       <span class="function"><span class="keyword">function</span> <span class="title">lookup</span>(<span class="params">uint id</span>) <span class="title">public</span> <span class="title">virtual</span> <span class="title">returns</span> (<span class="params">address adr</span>);</span></span><br><span class="line"><span class="function">   &#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">   <span class="title">abstract</span> <span class="title">contract</span> <span class="title">NameReg</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">function</span> <span class="title">register</span>(<span class="params">bytes32 name</span>) <span class="title">public</span> <span class="title">virtual</span>;</span></span><br><span class="line"><span class="function">       <span class="title">function</span> <span class="title">unregister</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">virtual</span>;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">   // 可以多重继承。请注意，<span class="title">owned</span> 也是 <span class="title">Destructible</span> 的基类，</span></span><br><span class="line"><span class="function">   // 但只有一个 <span class="title">owned</span> 实例（就像 <span class="title">C</span>++ 中的虚拟继承）。</span></span><br><span class="line"><span class="function">   <span class="title">contract</span> <span class="title">Named</span> <span class="title">is</span> <span class="title">Owned</span>, <span class="title">Destructible</span> </span>&#123;</span><br><span class="line">       <span class="keyword">constructor</span>(bytes32 name) &#123;</span><br><span class="line">           Config config = Config(<span class="number">0xD5f9D8D94886E70b06E474c3fB14Fd43E2f23970</span>);</span><br><span class="line">           NameReg(config.lookup(<span class="number">1</span>)).register(name);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 函数可以被另一个具有相同名称和相同数量/类型输入的函数重载。</span></span><br><span class="line">       <span class="comment">// 如果重载函数有不同类型的输出参数，会导致错误。</span></span><br><span class="line">       <span class="comment">// 本地和基于消息的函数调用都会考虑这些重载。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果要覆盖函数，则需要使用 `override` 关键字。 如果您想再次覆盖此函数，则需要再次指定`virtual`关键字。</span></span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">function</span> <span class="title">destroy</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">virtual</span> <span class="title">override</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (msg.sender == owner) &#123;</span><br><span class="line">               Config config = Config(<span class="number">0xD5f9D8D94886E70b06E474c3fB14Fd43E2f23970</span>);</span><br><span class="line">               NameReg(config.lookup(<span class="number">1</span>)).unregister();</span><br><span class="line">               <span class="comment">// 仍然可以调用特定的重载函数。</span></span><br><span class="line">               Destructible.destroy();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果构造函数接受参数，</span></span><br><span class="line">   <span class="comment">// 则需要在声明（合约的构造函数）时提供，</span></span><br><span class="line">   <span class="comment">// 或在派生合约的构造函数位置以修改器调用风格提供（见下文）。</span></span><br><span class="line">   contract PriceFeed is Owned, Destructible, Named(<span class="string">"GoldFeed"</span>) &#123;</span><br><span class="line">       <span class="function"><span class="keyword">function</span> <span class="title">updateInfo</span>(<span class="params">uint newInfo</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (msg.sender == owner) info = newInfo;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Here, we only specify `override` and not `virtual`.</span></span><br><span class="line">       <span class="comment">// This means that contracts deriving from `PriceFeed`</span></span><br><span class="line">       <span class="comment">// cannot change the behaviour of `destroy` anymore.</span></span><br><span class="line">       <span class="function"><span class="keyword">function</span> <span class="title">destroy</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">override</span>(<span class="params">Destructible, Named</span>) </span>&#123; Named.destroy(); &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span>(<span class="params">uint r</span>) </span>&#123; <span class="keyword">return</span> info; &#125;</span><br><span class="line"></span><br><span class="line">       uint info;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>父合约标记为 <code>virtual</code> 函数可以在继承合约里重写(overridden)以更改他们的行为。重写的函数需要使用关键字 <code>override</code> 修饰。</p><p>重写函数只能将覆盖函数的可见性从 <code>external</code> 更改为 <code>public</code> 。</p><p>可变性可以按照以下顺序更改为更严格的一种： <code>nonpayable</code> 可以被 <code>view</code> 和 <code>pure</code> 覆盖。 <code>view</code> 可以被 <code>pure</code> 覆盖。 <code>payable</code> 是一个例外，不能更改为任何其他可变性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: GPL-3.0</span></span><br><span class="line">pragma solidity &gt;<span class="number">0.6</span><span class="number">.99</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) <span class="title">virtual</span> <span class="title">external</span> <span class="title">view</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Middle is Base &#123;&#125;</span><br><span class="line"></span><br><span class="line">contract Inherited is Middle</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) <span class="title">override</span> <span class="title">public</span> <span class="title">pure</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pragma solidity &gt;=<span class="number">0.6</span><span class="number">.0</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract Base1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) <span class="title">virtual</span> <span class="title">public</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Base2</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) <span class="title">virtual</span> <span class="title">public</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Inherited is Base1, Base2</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 继承自两个基类合约定义的foo(), 必须显示的指定 override</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">override</span>(<span class="params">Base1, Base2</span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口类似于抽象合约，但是它们不能实现任何函数。还有进一步的限制：</p><ul><li>无法继承其他合约,不过可以继承其他接口。</li><li>所有的函数都需要是 external</li><li>无法定义构造函数。</li><li>无法定义状态变量。</li></ul><p>将来可能会解除这里的某些限制。</p><p>接口基本上基本上仅限于合约 ABI 可以表示的内容，并且 ABI 和接口之间的转换应该不会丢失任何信息。</p><p>接口由它们自己的关键字表示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=<span class="number">0.6</span><span class="number">.2</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">interface Token &#123;</span><br><span class="line">    enum TokenType &#123; Fungible, NonFungible &#125;</span><br><span class="line">    struct Coin &#123; string obverse; string reverse; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">transfer</span>(<span class="params">address recipient, uint amount</span>) <span class="title">external</span>;</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">//-------</span></span><br><span class="line"><span class="function"><span class="title">pragma</span> <span class="title">solidity</span> &gt;=0.6.2 &lt;0.8.0;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">interface</span> <span class="title">ParentA</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) <span class="title">external</span> <span class="title">returns</span> (<span class="params">uint256</span>);</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">interface</span> <span class="title">ParentB</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) <span class="title">external</span> <span class="title">returns</span> (<span class="params">uint256</span>);</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">interface</span> <span class="title">SubInterface</span> <span class="title">is</span> <span class="title">ParentA</span>, <span class="title">ParentB</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 必须重新定义 test 函数，以表示兼容父合约含义</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) <span class="title">external</span> <span class="title">override</span>(<span class="params">ParentA, ParentB</span>) <span class="title">returns</span> (<span class="params">uint256</span>);</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>就像继承其他合约一样，合约可以继承接口。接口中的函数都会隐式的标记为 <code>virtual</code> ，意味着他们会被重写。 但是不表示重写（overriding）函数可以再次重写，仅仅当重写的函数标记为 <code>virtual</code> 才可以再次重写。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=<span class="number">0.6</span><span class="number">.0</span> &lt;<span class="number">0.7</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 我们定义了一个新的结构体数据类型，用于在调用合约中保存数据。</span></span><br><span class="line">  struct Data &#123;</span><br><span class="line">    mapping(<span class="function"><span class="params">uint</span> =&gt;</span> bool) flags;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">library <span class="built_in">Set</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注意第一个参数是“storage reference”类型，因此在调用中参数传递的只是它的存储地址而不是内容。</span></span><br><span class="line">  <span class="comment">// 这是库函数的一个特性。如果该函数可以被视为对象的方法，则习惯称第一个参数为 `self` 。</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params">Data storage self, uint value</span>)</span></span><br><span class="line"><span class="function">      <span class="title">public</span></span></span><br><span class="line"><span class="function">      <span class="title">returns</span> (<span class="params">bool</span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (self.flags[value])</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 已经存在</span></span><br><span class="line">      self.flags[value] = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params">Data storage self, uint value</span>)</span></span><br><span class="line"><span class="function">      <span class="title">public</span></span></span><br><span class="line"><span class="function">      <span class="title">returns</span> (<span class="params">bool</span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!self.flags[value])</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 不存在</span></span><br><span class="line">      self.flags[value] = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">contains</span>(<span class="params">Data storage self, uint value</span>)</span></span><br><span class="line"><span class="function">      <span class="title">public</span></span></span><br><span class="line"><span class="function">      <span class="title">view</span></span></span><br><span class="line"><span class="function">      <span class="title">returns</span> (<span class="params">bool</span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> self.flags[value];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    Data knownValues;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">register</span>(<span class="params">uint value</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 不需要库的特定实例就可以调用库函数，</span></span><br><span class="line">        <span class="comment">// 因为当前合约就是“instance”。</span></span><br><span class="line">        <span class="built_in">require</span>(<span class="built_in">Set</span>.insert(knownValues, value));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果我们愿意，我们也可以在这个合约中直接访问 knownValues.flags。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个我们没咋个看到过</p><h4 id="合约元数据"><a href="#合约元数据" class="headerlink" title="合约元数据"></a>合约元数据</h4><p>Solidity编译器自动生成JSON文件，即合约的元数据，其中包含了当前合约的相关信息。 它可以用于查询编译器版本，所使用的源代码，<a href="https://learnblockchain.cn/docs/solidity/metadata.html#id5" target="_blank" rel="noopener">|ABI|</a> 和 <a href="https://learnblockchain.cn/docs/solidity/metadata.html#id7" target="_blank" rel="noopener">|natspec|</a> 文档，以便更安全地与合约进行交互并验证其源代码。</p><p>编译器会将元数据文件的 Swarm 哈希值附加到每个合约的字节码末尾（详情请参阅下文）， 以便你可以以认证的方式获取该文件，而不必求助于中心化的数据提供者。</p><p>当然，你必须将元数据文件发布到 Swarm （或其他服务），以便其他人可以访问它。 该文件可以通过使用 <code>solc --metadata</code> 来生成，并被命名为 <code>ContractName_meta.json</code> 。 它将包含源代码的在 Swarm 上的引用，因此你必须上传所有源文件和元数据文件。</p><p>元数据文件具有以下格式。 下面的例子将以人类可读的方式呈现。 正确格式化的元数据应正确使用引号，将空白减少到最小，并对所有对象的键值进行排序以得到唯一的格式。 代码注释当然也是不允许的，这里仅用于解释目的。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // 必选：元数据格式的版本</span><br><span class="line">  version: "1",</span><br><span class="line">  // 必选：源代码的编程语言，一般会选择规范的“子版本”</span><br><span class="line">  language: "Solidity",</span><br><span class="line">  // 必选：编译器的细节，内容视语言而定。</span><br><span class="line">  compiler: &#123;</span><br><span class="line">    // 对 Solidity 来说是必须的：编译器的版本</span><br><span class="line">    version: "0.4.6+commit.2dabbdf0.Emscripten.clang",</span><br><span class="line">    // 可选： 生成此输出的编译器二进制文件的哈希值</span><br><span class="line">    keccak256: "0x123..."</span><br><span class="line">  &#125;,</span><br><span class="line">  // 必选：编译的源文件／源单位，键值为文件名</span><br><span class="line">  sources:</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"myFile.sol"</span>: &#123;</span><br><span class="line">      // 必选：源文件的 keccak256 哈希值</span><br><span class="line">      "keccak256": "0x123...",</span><br><span class="line">      // 必选（除非定义了“content”，详见下文）：</span><br><span class="line">      // 已排序的源文件的URL，URL的协议可以是任意的，但建议使用 Swarm 的URL</span><br><span class="line">      "urls": [ "bzzr://56ab..." ]</span><br><span class="line">      // Optional: 在源文件中定义的 SPDX license 标识</span><br><span class="line">      "license": "MIT"</span><br><span class="line">    &#125;,</span><br><span class="line">    "mortal": &#123;</span><br><span class="line">      // 必选：源文件的 keccak256 哈希值</span><br><span class="line">      "keccak256": "0x234...",</span><br><span class="line">      // 必选（除非定义了“urls”）： 源文件的字面内容</span><br><span class="line">      "content": "contract mortal is owned &#123; function kill() &#123; if (msg.sender == owner) selfdestruct(owner); &#125; &#125;"</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  // 必选：编译器的设置</span><br><span class="line">  settings:</span><br><span class="line">  &#123;</span><br><span class="line">    // 对 Solidity 来说是必须的： 已排序的重定向列表</span><br><span class="line">    remappings: [ ":g/dir" ],</span><br><span class="line">    // 可选： 优化器的设置（ enabled 默认设为 false ）</span><br><span class="line">    optimizer: &#123;</span><br><span class="line">      enabled: true,</span><br><span class="line">      runs: 500,</span><br><span class="line">      details: &#123;</span><br><span class="line">        // peephole defaults to "true"</span><br><span class="line">        peephole: true,</span><br><span class="line">        // jumpdestRemover defaults to "true"</span><br><span class="line">        jumpdestRemover: true,</span><br><span class="line">        orderLiterals: false,</span><br><span class="line">        deduplicate: false,</span><br><span class="line">        cse: false,</span><br><span class="line">        constantOptimizer: false,</span><br><span class="line">        yul: true,</span><br><span class="line">        // Optional: Only present if "yul" is "true"</span><br><span class="line">        yulDetails: &#123;</span><br><span class="line">          stackAllocation: false,</span><br><span class="line">          optimizerSteps: "dhfoDgvulfnTUtnIf..."</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  metadata: &#123;</span><br><span class="line">      // Reflects the setting used in the input json, defaults to false</span><br><span class="line">      useLiteralContent: true,</span><br><span class="line">      // Reflects the setting used in the input json, defaults to "ipfs"</span><br><span class="line">      bytecodeHash: "ipfs"</span><br><span class="line">    &#125;</span><br><span class="line">    // Required for Solidity: File and name of the contract or library this</span><br><span class="line">    // metadata is created for.</span><br><span class="line">    compilationTarget: &#123;</span><br><span class="line">      "myFile.sol": "MyContract"</span><br><span class="line">    &#125;,</span><br><span class="line">    // Required for Solidity: Addresses for libraries used</span><br><span class="line">    libraries: &#123;</span><br><span class="line">      "MyLib": "0x123123..."</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  // 必选：合约的生成信息</span><br><span class="line">  output:</span><br><span class="line">  &#123;</span><br><span class="line">    // 必选：合约的 ABI 定义</span><br><span class="line">    abi: [ ... ],</span><br><span class="line">    // 必选：合约的 NatSpec 用户文档</span><br><span class="line">    userdoc: [ ... ],</span><br><span class="line">    // 必选：合约的 NatSpec 开发者文档</span><br><span class="line">    devdoc: [ ... ],</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于生成的合约的字节码包含元数据的哈希值，因此对元数据的任何更改都会导致字节码的更改。 此外，由于元数据包含所有使用的源代码的哈希值，所以任何源代码中的， 哪怕是一个空格的变化都将导致不同的元数据，并随后产生不同的字节代码。需注意，上面的 ABI 没有固定的顺序，随编译器的版本而不同。尽管从 Solidity 0.5.12 开始，数组保持了一定的顺序。</p><h4 id="源代码验证方法"><a href="#源代码验证方法" class="headerlink" title="源代码验证方法"></a>源代码验证方法</h4><p>为了验证编译，可以通过元数据文件中的链接从 Swarm 中获取源代码。 获取到的源码，会根据元数据中指定的设置，被正确版本的编译器（应该为“官方”编译器之一）所处理。 处理得到的字节码会与创建交易的数据或者 <code>CREATE</code> 操作码使用的数据进行比较。 这会自动验证元数据，因为它的哈希值是字节码的一部分。 而额外的数据，则是与基于接口进行编码并展示给用户的构造输入数据相符的。</p><h4 id="ABI"><a href="#ABI" class="headerlink" title="ABI"></a>ABI</h4><p>在 以太坊Ethereum 生态系统中， 应用二进制接口Application Binary Interface(ABI) 是从区块链外部与合约进行交互以及合约与合约间进行交互的一种标准方式。 数据会根据其类型按照这份手册中说明的方法进行编码。这种编码并不是可以自描述的，而是需要一种特定的概要（schema）来进行解码。</p><p>除了 元组tuple 以外，Solidity 支持以上所有类型的名称。ABI 元组tuple 是利用 Solidity 的 <code>structs</code> 编码得到的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.16</span>;</span><br><span class="line"></span><br><span class="line">contract Foo &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">bytes3[<span class="number">2</span>]</span>) <span class="title">public</span> <span class="title">pure</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params">uint32 x, bool y</span>) <span class="title">public</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">bool r</span>) </span>&#123; r = x &gt; <span class="number">32</span> || y; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">sam</span>(<span class="params">bytes, bool, uint[]</span>) <span class="title">public</span> <span class="title">pure</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，对于我们的例子 <code>Foo</code>，如果我们想用 <code>69</code> 和 <code>true</code> 做参数调用 <code>baz</code>，我们总共需要传送 68 字节，可以分解为：</p><ul><li><code>0xcdcd77c0</code>：方法ID。这源自ASCII格式的 <code>baz(uint32,bool)</code> 签名的 Keccak 哈希的前 4 字节。</li><li><code>0x0000000000000000000000000000000000000000000000000000000000000045</code>：第一个参数，一个被用 0 值字节补充到 32 字节的 uint32 值 <code>69</code>。</li><li><code>0x0000000000000000000000000000000000000000000000000000000000000001</code>：第二个参数，一个被用 0 值字节补充到 32 字节的 boolean 值 <code>true</code>。</li></ul><p>合起来就是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0xcdcd77c000000000000000000000000000000000000000000000000000000000000000450000000000000000000000000000000000000000000000000000000000000001</span><br></pre></td></tr></table></figure><p>它返回一个 <code>bool</code>。比如它返回 <code>false</code>，那么它的输出将是一个字节数组 <code>0x0000000000000000000000000000000000000000000000000000000000000000</code>，一个bool值。</p><p>事件，是 以太坊Ethereum 的日志/事件监视协议的一个抽象。日志项提供了合约的地址、一系列的主题（最高 4 项）和一些任意长度的二进制数据。为了使用合适的类型数据结构来演绎这些功能（与接口定义一起），事件沿用了既存的 ABI 函数。</p><p>给定了事件名称和事件参数之后，我们将其分解为两个子集：已索引的和未索引的。已索引的部分，最多有 3 个，被用来与事件签名的 Keccak 哈希一起组成日志项的主题。未索引的部分就组成了事件的字节数组。</p><p>一个事件描述是一个有极其相似字段的 JSON 对象：</p><ul><li><p><code>type</code>：总是 <code>&quot;event&quot;</code>；</p></li><li><p><code>name</code>：事件名称；</p></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inputs</span><br></pre></td></tr></table></figure><p>：对象数组，每个数组对象会包含：</p><ul><li><code>name</code>：参数名称；</li><li><code>type</code>：参数的权威类型（相见下文）；</li><li><code>components</code>：供 元组tuple 类型使用（详见下文）；</li><li><code>indexed</code>：如果此字段是日志的一个主题，则为 <code>true</code>；否则为 <code>false</code>。</li></ul></li><li><p><code>anonymous</code>：如果事件被声明为 <code>anonymous</code>，则为 <code>true</code>。</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: GPL-3.0</span></span><br><span class="line">pragma solidity &gt;<span class="number">0.6</span><span class="number">.99</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123; b = <span class="number">0x12345678901234567890123456789012</span>; &#125;</span><br><span class="line">  event Event(uint indexed a, bytes32 b);</span><br><span class="line">  event Event2(uint indexed a, bytes32 b);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">uint a</span>) <span class="title">public</span> </span>&#123; Event(a, b); &#125;</span><br><span class="line">  bytes32 b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[&#123;</span><br><span class="line"><span class="attr">"type"</span>:<span class="string">"event"</span>,</span><br><span class="line"><span class="attr">"inputs"</span>: [&#123;<span class="attr">"name"</span>:<span class="string">"a"</span>,<span class="attr">"type"</span>:<span class="string">"uint256"</span>,<span class="attr">"indexed"</span>:<span class="literal">true</span>&#125;,&#123;<span class="attr">"name"</span>:<span class="string">"b"</span>,<span class="attr">"type"</span>:<span class="string">"bytes32"</span>,<span class="attr">"indexed"</span>:<span class="literal">false</span>&#125;],</span><br><span class="line"><span class="attr">"name"</span>:<span class="string">"Event"</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line"><span class="attr">"type"</span>:<span class="string">"event"</span>,</span><br><span class="line"><span class="attr">"inputs"</span>: [&#123;<span class="attr">"name"</span>:<span class="string">"a"</span>,<span class="attr">"type"</span>:<span class="string">"uint256"</span>,<span class="attr">"indexed"</span>:<span class="literal">true</span>&#125;,&#123;<span class="attr">"name"</span>:<span class="string">"b"</span>,<span class="attr">"type"</span>:<span class="string">"bytes32"</span>,<span class="attr">"indexed"</span>:<span class="literal">false</span>&#125;],</span><br><span class="line"><span class="attr">"name"</span>:<span class="string">"Event2"</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line"><span class="attr">"type"</span>:<span class="string">"function"</span>,</span><br><span class="line"><span class="attr">"inputs"</span>: [&#123;<span class="attr">"name"</span>:<span class="string">"a"</span>,<span class="attr">"type"</span>:<span class="string">"uint256"</span>&#125;],</span><br><span class="line"><span class="attr">"name"</span>:<span class="string">"foo"</span>,</span><br><span class="line"><span class="attr">"outputs"</span>: []</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>Solidity的合约开始真正的意义上的普及还需要一些时间，但是对于真正的使用，还是相当的有意思。</p><p>接下来的使用中，在一步一步更新这个文档，感觉solidity蛮有意思的。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Apr 21 2021 01:32:54 GMT+0900 (Japan Standard Time) --&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;做区块链相关的创业已经有4年了，都是做ETL方面的，对于真正的合约以及Trading，其实没有真正的使用，技术就是这样，用了就会发现有意思，从最早的没有信仰，到现在的信心满满，虽然BTC的价格还是3年前BTC的价格，但是市场已经今非昔比了，从DEFI的火热，到各种POOL的出现，区块链的运营方式和目标人群都巨大的变化了。在大经济形势周期的转变下，我也从数据，转战到了DEFI，因为DEFI才是代表了未来真正的放下，大环境下，随着疫情，越来越多的政府和国家地区更深入的隔绝，对于崇尚自由的人来说，我们更应该获得真正意义上的金融自由。虽然现在Blockchain还是被美帝把持着。&lt;/p&gt;&lt;p&gt;闲话不多说，我们开始真正的来玩转合约，合约从Ether起，也和Ether的创始团队息息相关，从V神，还有WOOD博士开始，Ether的出现也带来了Solidity和Vyper,智能合约语言，目前来看Vyper更安全，而Solidity使用更广泛，本文主要讲Solidity的开发和使用。&lt;/p&gt;&lt;p&gt;Solidity文档： &lt;a href=&quot;https://learnblockchain.cn/docs/solidity/introduction-to-smart-contracts.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://learnblockchain.cn/docs/solidity/introduction-to-smart-contracts.html&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/images/solidity.jpeg&quot; alt=&quot;Solidity&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="blockchain" scheme="http://yangxinqi.com/categories/blockchain/"/>
    
    
      <category term="solidity" scheme="http://yangxinqi.com/tags/solidity/"/>
    
  </entry>
  
  <entry>
    <title>梯子教程简版</title>
    <link href="http://yangxinqi.com/2020/11/02/%E6%A2%AF%E5%AD%90%E6%95%99%E7%A8%8B%E7%AE%80%E7%89%88/"/>
    <id>http://yangxinqi.com/2020/11/02/梯子教程简版/</id>
    <published>2020-11-02T02:51:44.000Z</published>
    <updated>2020-11-02T03:00:23.294Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Apr 21 2021 01:32:54 GMT+0900 (Japan Standard Time) --><p>本篇文章，详细写了关于在海外如何翻回看片，以及如何在国内翻出去自由上网的过程。 希望大家一个便宜且安全的私有梯子。 这篇是欠商神的文章，还上。</p><p>又到1年一度的双11，其他的没有买，买和续费VPS是当务之急，在买中，如何搭建自己私有的梯子，也是蛮好玩的。 对于娃翻墙回国学习，还是大人看国内的节目，或者是翻出来找资料，看youtube等等，都需要，所以本次做了分享，其实就是很简单的docker启动，以及配置防火墙的过程，其实对于IT认识而言，非常的简单。 可以尝试下，推荐使用。</p><p><img src="/images/v2ray-logo.jpg" alt="V2 ra y"></p><a id="more"></a><h4 id="GFW的认识"><a href="#GFW的认识" class="headerlink" title="GFW的认识"></a>GFW的认识</h4><p>首先，需要对GFW要有强大的认识，因为有了GFW，才能保证稳定，还有就是基于版权的保护，会有地域性质的版权限制，但是对于大部分的海外国人来说，希望身在海外也能够看到国内的内容， 那么我们应该如何解决呢？</p><h4 id="梯子服务商"><a href="#梯子服务商" class="headerlink" title="梯子服务商"></a>梯子服务商</h4><p>对于服务商，一定要选择网络快而价格低的，本次给大家推荐：</p><p>C2O： 中国翻海外，第一推荐： Google Cloud , Region选择 taiwan ， 台湾节点是目前在国内最稳定和最快速的海外访问节点。</p><p>O2C: 海外翻中国， 第一推荐： ALi Cloud, region选择 qingdao， 青岛是国内3大光仟出口之一，其他的2个上海和广州那边早已人满为患了，青岛作为还未开发的一个口，目前来看速度最快，而且稳定。 强烈推荐。</p><h4 id="购买时机"><a href="#购买时机" class="headerlink" title="购买时机"></a>购买时机</h4><p>一，Google Cloud: 对于Google Cloud 本身有免费的300美元的额度，可以先使用信用卡开试用账户，然后免费用3个月，之后自动会被转成收费的账户。 系统配置的话，使用</p><p>2core 2G 的足够了，每个月费用在$10以内，速度和性能都还不错，可惜只能免费3个月，之后就是收费的了。</p><p>二，Ali Cloud: 阿里云，正直双11又要到了，可以一次性买3年的， 2Core 4G 的共享5M，3年的价格在1200 左右，不知道今年的价格是多少？ 平均每年在400左右，而且速度很稳定，需要使用阿里云的新账户去抢购。 一个机器解决3年的使用也蛮好。经过速度测试，5M的基本看国内的爱奇艺，腾讯视频，4K基本也不卡, 强烈推荐。</p><h4 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h4><p>梯子买好了之后，需要开始部署，这里推荐使用 V2Ray来搭建。</p><p>Mac 下客户端，使用 V2RayU ， Windows上，还是推荐使用官方的V2Ray相关客户端，手机上 SuperWingy （iOS），v2RayNG (Android).</p><p>搭建步骤：</p><p>1.登录机器安装docker和docker-compose,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ssh ubuntu@xxxx.xxxx.xxx.xxx </span><br><span class="line"></span><br><span class="line">sudo apt-get install -y docker.io</span><br><span class="line">sudo curl -L &quot;https://github.com/docker/compose/releases/download/1.26.2/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose</span><br><span class="line">sudo chmod +x /usr/local/bin/docker-compose</span><br><span class="line">sudo usermod -aG docker $USER</span><br></pre></td></tr></table></figure><p>2.克隆项目到机器上，并修改自己的端口和 uuid 码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/ </span><br><span class="line"><span class="built_in">pwd</span>  <span class="comment">### 这里显示 /home/ubuntu/freeman/ 这里路径不对的话，需要修改docker-compose.yml中的配置文件的位置。 </span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/xinqiyang/freeman</span><br><span class="line"><span class="built_in">cd</span> freemain/docker</span><br><span class="line"></span><br><span class="line">vi v2ray/config.json    <span class="comment">### 这里修改你自己的端口和密码 </span></span><br><span class="line"><span class="comment">### 修改的配置的内容</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"inbounds"</span>: [&#123;</span><br><span class="line">    <span class="string">"port"</span>: 32026,  <span class="comment">### 这里是你的端口号，推荐修改到10000 以上的，降低被ban的概率</span></span><br><span class="line">    <span class="string">"protocol"</span>: <span class="string">"vmess"</span>,</span><br><span class="line">    <span class="string">"settings"</span>: &#123;</span><br><span class="line">      <span class="string">"clients"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">"id"</span>: <span class="string">"4dde0eaf-9e30-442a-b29e-7eb29837b802"</span>,  <span class="comment">#### 自己的唯一的UUID </span></span><br><span class="line">          <span class="string">"level"</span>: 1,</span><br><span class="line">          <span class="string">"alterId"</span>: 64</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;],</span><br><span class="line">  <span class="string">"outbounds"</span>: [&#123;</span><br><span class="line">    <span class="string">"protocol"</span>: <span class="string">"freedom"</span>,</span><br><span class="line">    <span class="string">"settings"</span>: &#123;&#125;</span><br><span class="line">  &#125;,&#123;</span><br><span class="line">    <span class="string">"protocol"</span>: <span class="string">"blackhole"</span>,</span><br><span class="line">    <span class="string">"settings"</span>: &#123;&#125;,</span><br><span class="line">    <span class="string">"tag"</span>: <span class="string">"blocked"</span></span><br><span class="line">  &#125;],</span><br><span class="line">  <span class="string">"routing"</span>: &#123;</span><br><span class="line">    <span class="string">"rules"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"type"</span>: <span class="string">"field"</span>,</span><br><span class="line">        <span class="string">"ip"</span>: [<span class="string">"geoip:private"</span>],</span><br><span class="line">        <span class="string">"outboundTag"</span>: <span class="string">"blocked"</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">### 修改配置结束 :q 退出</span></span><br></pre></td></tr></table></figure><p>3.启动docker，开始服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d </span><br><span class="line">docker ps </span><br><span class="line"><span class="comment">### 看到以下的在跑着，说明启动成功， 这里使用32026 端口，需要去开启防火墙配置</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                      NAMES</span><br><span class="line">8a541b029756        jrohy/v2ray         <span class="string">"./run.sh"</span>          2 months ago        Up 7 days           0.0.0.0:32026-&gt;32026/tcp   v2ray_mritdv2ray_1</span><br></pre></td></tr></table></figure><p>4.打开VPS的安全设置的防火墙端口，即可配置客户端开始使用。</p><p>这里根据自己的账户，在网络设置里面 启动 32026 端口的防火墙，修改状态为 开启状态 即可。</p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>配置客户端的链接,我这里选用v2rayU的配置文件，大家在其他客户端中，只要提供 ip, uuid , level , alterId即可。</p><p>连上之后，打开 ipip.net 查看自己的ip是否为当前的代理ip，看看能否成功。</p><h4 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h4><p>其实国内的在线教育资源，学习资源都超级好，我个人感觉有娃的更应该搭建一个，方便孩子学习中文及英语相关内容。</p><p>对于互联网上的各位，要翻墙出来的，也推荐下。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Apr 21 2021 01:32:54 GMT+0900 (Japan Standard Time) --&gt;&lt;p&gt;本篇文章，详细写了关于在海外如何翻回看片，以及如何在国内翻出去自由上网的过程。 希望大家一个便宜且安全的私有梯子。 这篇是欠商神的文章，还上。&lt;/p&gt;&lt;p&gt;又到1年一度的双11，其他的没有买，买和续费VPS是当务之急，在买中，如何搭建自己私有的梯子，也是蛮好玩的。 对于娃翻墙回国学习，还是大人看国内的节目，或者是翻出来找资料，看youtube等等，都需要，所以本次做了分享，其实就是很简单的docker启动，以及配置防火墙的过程，其实对于IT认识而言，非常的简单。 可以尝试下，推荐使用。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/images/v2ray-logo.jpg&quot; alt=&quot;V2 ra y&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="other" scheme="http://yangxinqi.com/categories/other/"/>
    
    
      <category term="other, v2ray" scheme="http://yangxinqi.com/tags/other-v2ray/"/>
    
  </entry>
  
  <entry>
    <title>Oracle协议比较分析-Band vs Chainlink</title>
    <link href="http://yangxinqi.com/2020/10/20/Oracle%E5%8D%8F%E8%AE%AE%E6%AF%94%E8%BE%83%E5%88%86%E6%9E%90-Band-vs-Chainlink/"/>
    <id>http://yangxinqi.com/2020/10/20/Oracle协议比较分析-Band-vs-Chainlink/</id>
    <published>2020-10-20T02:26:02.000Z</published>
    <updated>2020-10-20T04:52:57.542Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Apr 21 2021 01:32:54 GMT+0900 (Japan Standard Time) --><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近项目中需要使用到Oracle,对价格进行更新，找了一圈市面上的，发现Band和Chainlink，对Chainlink的比价深有体会，遂开始深入研究下Oracle的实现机制，以及如何讲现实世界中的数据和API链接到智能合约中。 以下主要是翻译了SmartContent写的Band协议和Chainlink的对比分析的文章， 原文地址： <a href="https://medium.com/@smartcontentpublication/a-comparative-analysis-of-band-protocol-and-chainlink-54b7d14823b5" target="_blank" rel="noopener">https://medium.com/@smartcontentpublication/a-comparative-analysis-of-band-protocol-and-chainlink-54b7d14823b5</a> ，对文章进行了翻译和补充，基本使用Google翻译进行简要的翻译，可以当成一篇PR稿文章，主要从几个维度，比如 数据质量，随机性以来，采纳指标，资源效率和网络设计，团队，去中心化和多链支持等各个方面，对Band和Chainlink进行了比较，结果都是Chainlink胜出了。</p><p>大杨个人意见，看过Band的创始团队和背后的投资机构，都是相当有前景，而且Oracle语言机的盈利模式上都是平台方来撮合数据需求方和提供方调用，然后支付方式都是用平台的虚拟币支付，这样的方式其实也带来了很大不确定性，随着平台方币价的上涨，也带来了需求方很大的调用成本，本身现在公开的调用方式，实时性也不好，如果采用较为实时的解决方案，那么使用LINK代币来支付的费用，换算成法币的话，也是非常高的。从文章从可以看到的是Band协议V2，依赖于与Cosmos, 而且很区块链化，对于用户的直接引入也很不友好，此外Chainlink VRF作为一个显著的重大热点，为NFT提供服务，Band目前还没有什么亮点仅仅挂个Oracle的竞争者。整体来看，Band还是比较困难的，推荐大家使用Chainlink.</p><p><img src="/images/oracle/oracle.png" alt="Oracle Analysis"></p><a id="more"></a><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>Band Protocol是一个Oracle平台，旨在将现实世界的数据和API聚合并连接到智能合约。 Band v1最初于2019年9月在Ethereum上使用了Bonding Curve设计，但开发人员的兴趣不大，最终没有在主网上获得采用。 核心开发团队在不到一年的时间内就放弃了它, 开始开发V2版本。<br>Band v2，被称为BandChain，是一个在自己的基于Tendermint的区块链上运行的Oracle网络（使用Cosmos SDK）。 BandChain已经启动了两个网络，第一个是Wenchang网络-一个原型主网络，它不具有任何Oracle功能，只生成基本上是空的块。第二个网络是Guan Ya测试网，但是，在底层Cosmos SDK中出现严重的内存泄漏和状态修剪错误之后，该网络最近不得不重新启动。在正式主网之前，其目的是启动一个授权证明网络，该网络由七个属于Band基金会和私有选择验证者节点组成。<br>在本文中，我们将首先从高层次探讨BandChain的工作方式，从而为进行比较分析奠定基础，该分析详细说明了BandChain与Chainlink的堆叠方式。比较的主要重点如下：</p><h4 id="数据质量"><a href="#数据质量" class="headerlink" title="数据质量"></a>数据质量</h4><p>Band：在发布时，BandChain最初将仅支持免费的低质量API，而付费的受密码保护的API支持在很大程度上仍是理论上的。 因此，开发人员不能只调用他们想要的任何受密码保护的API。 他们提出的计划是要求数据提供者更改其整个业务模型，以接受数据的链上加密货币支付。</p><p>Chainlink：本机支持连接到当今任何实时生产环境中的数据源API，包括免费的开放API，付费的经过身份验证的API和专有的私有API。 所有这些都可以通过模块化的外部适配器实现，任何人都可以创建和托管这些适配器，而无需Chainlink团队或数据提供商本身的任何其他支持。</p><h4 id="随机性依赖"><a href="#随机性依赖" class="headerlink" title="随机性依赖"></a>随机性依赖</h4><p>Band：将随机性作为协议的核心组成部分； 这是选择oracle节点的必需方法，尽管该功能不受任何原始学术研究的支持。 这不仅严重限制了数据的可访问性（每个节点都必须有权访问相同的数据）和网络安全性（必须信任每个节点），而且该团队在此主题上无能为力，因为他们在尝试复制Chainlink VRF在他们自己的github repo上的时候，被发现了(<a href="https://twitter.com/chainlink_alert/status/1267133567764758533)。" target="_blank" rel="noopener">https://twitter.com/chainlink_alert/status/1267133567764758533)。</a><br>Chainlink：不将随机性作为协议的核心部分，以确保用户具有高度的灵活性和质量控制机制，可以选择节点并连接到数据。 他们建立了Chainlink可验证随机性功能（VRF），作为一种新颖的方法，以领先的和原创的学术研究为后盾，<strong>为区块链游戏和NFT dApp创建可证明的公平的随机性源</strong>。</p><h4 id="采纳指标"><a href="#采纳指标" class="headerlink" title="采纳指标"></a>采纳指标</h4><p>Band：尽管Band v1在以太坊上存在了将近一年，但主网上目前没有正在使用的产品。 Band v2尚未完成（没有oracle功能），完全未经验证，并且缺少能够支持生产中的真实用户的任何案例研究。<br>Chainlink：目前，通过其众多实时价格参考供稿，对于排名靠前的DeFi项目，其在Mainnet上的价值超过$ 10B。 由于其在VRF方面的开创性工作，它是整个DeFi，跨区块链，游戏中使用最广泛的Oracle，并拥有240多个项目集成管道。</p><h4 id="资源效率与网络设计"><a href="#资源效率与网络设计" class="headerlink" title="资源效率与网络设计"></a>资源效率与网络设计</h4><p>Band：他们的Oracle建立在自己的区块链上，需要Oracle节点执行作为BandChain的块生产者/验证者的辅助工作，这对Oracle的数据交付工作没有任何价值。 这样，由于状态膨胀越来越大，并且随着时间的推移，同步时间较长，因此节点将承受较高的运营成本。<br>Chainlink：Chainlink不是，以后也不会是一个区块链网络，因此节点仅充当仅专注于数据交付的预言家，而不会阻止生产/验证。 节点非常轻巧，不需要状态处理或同步，因此可以将节点旋转并立即使用。</p><h4 id="团队"><a href="#团队" class="headerlink" title="团队"></a>团队</h4><p>Band：Band团队规模很小，没有进行过任何原始的学术研究，也缺乏构建分布式系统和Oracle的经验，尤其是那些能够确保真实价值的产品。 他们还放弃了原始设计，并多次更改了协议。<br>Chainlink：40+ Chainlink团队成员自2014年以来一直在建立Oracle预言机并发表原创学术研究，并得到了顶级顾问的支持，例如Ari Juels（RSA的前首席科学家），Tom Gonser（DocuSign的创始人），Evan Cheng（工程总监） 在Facebook）等等。 他们坚持原始设计并对其进行扩展以改善用户体验。</p><h4 id="去中心化"><a href="#去中心化" class="headerlink" title="去中心化"></a>去中心化</h4><p>Brand：所有数据查询/响应必须通过单个区块链BandChain处理，从而限制了最大吞吐量。 由于Tendermint BFT共识的可扩展性有限，因此上限为100个节点。<br>Chainlink：无限数量的Oracle网络可以并行运行，并且可以在任何区块链，DLT或Layer 2解决方案上本地运行，从而无需通过任何一条链来进行数据查询/响应。 即将到来的阈值签名和链外聚合升级的节点没有上限。</p><h4 id="多链支持"><a href="#多链支持" class="headerlink" title="多链支持"></a>多链支持</h4><p>Brand：依靠尚未发布的Cosmos IBC将数据本地桥接到其他区块链。 因此，它目前仅支持精简客户端，精简客户端要求数据由协议之外的未知第三方交付，这些第三方对其性能的奖励或处罚为零。<br>Chainlink：通过模块化的外部适配器，外部发起程序，核心合约部署和令牌桥接，以本地方式支持任意区块链。 节点将数据直接传递到任何区块链上的请求合约，从而最大程度地减少网络跳转并确保及时传递。</p><p><img src="/images/oracle/chainlink1.png" alt="chainlink1"></p><h3 id="怎么运行的"><a href="#怎么运行的" class="headerlink" title="怎么运行的"></a>怎么运行的</h3><p>Band Protocol v2（BandChain）是基于Bender（DPoS）共识算法的基于Tendermint的区块链，并在Cosmos生态系统中运行。 BandChain当前在主网上不支持oracle，仅产生大部分为空的块。本节介绍了BandChain一旦完全发挥作用后将如何运行，但请记住，主网中尚不存在许多这些功能。<br>BandChain节点必须既充当区块链的验证器（产生块，验证和订购交易），又充当服务外部数据请求的预言家。拥有最多代币的前100名验证者成为BandChain的验证者。该网络的年通胀率将从13.5％开始，目标是占总供应量的66％。如果抵押率低于66％，通货膨胀率最高将上升到20％。如果抵押率高于66％，通货膨胀率将至少降低7％。另外，虽然尚不清楚这些资金将如何分配以及分配给谁，但每个区块奖励的2%会转入社区资金池。</p><p>可以大幅度削减验证者的本金，以使停机时间过多，超过30,000个区块（0.01％罚款），双重签名区块（5％罚款）或无响应（百分比不清楚）。如果大幅减少停机时间，节点将无法参与对任何块的签名，直到它们在BandChain上发送交易证明其在线。重要的是要注意，BAND赌注和所有这些削减条件仅用于维护区块链验证和区块生产，而不是用于确保任何oracle服务的可靠性或数据准确性。尽管Band团队建议在将来共同投票以惩罚执行错误的Oracle服务的验证者（这将受到鲸鱼的操纵），但这尚待开发，并且仍然完全是理论上的。</p><p>用户可以通过调用可用的“ Oracle Script”智能合约将数据请求发送到BandChain，这些智能合约是对数据请求详细信息进行编码的链上可执行程序，例如要调用的数据源API以及将验证程序响应聚合为单个响应的方法。选择响应数据请求的节点由随机权益加权算法决定。验证者投入的BAND令牌越多，将它们分配给数据请求的可能性就越大。因此，数据请求者无法控制将使用哪些节点来完成其数据查询。</p><p>选定的验证器通过获取链下数据并在链上（到BandChain）传递响应来完成数据请求。然后，将来自每个参与节点的数据汇总以形成最终响应。创建了一个oracle数据证明（Merkle证明），并显示最终结果的存在以及oracle脚本哈希，输入参数，执行时间等。该证明可以发送到其他区块链上的智能合约以验证其证明由BandChain验证者。证明也可以被解码，以便智能合约可以使用数据结果。</p><p>Band Protocol的目标是与区块链无关，其中Oracle请求在BandChain的环境中处理并桥接到其他链上。他们计划利用Cosmos正在开发的未发布的跨区块链通信（IBC）协议来将数据桥接到其他链，尽管目前尚不清楚IBC是否以及何时准备投入生产。因此，要求用户使用lite客户端协议将数据手动桥接到其他区块链，直到IBC启动。这要求用户依赖BandChain协议之外的外部第三方将数据实际传递到另一个区块链（例如，以太坊上的DeFi应用程序）上正在使用的智能合约中。这些第三方没有动力可靠地提供数据，也没有因此而受到惩罚。</p><p>现在您对BandChain的工作方式有了一些了解，我们可以逐点深入进行比较，以了解Band如何与Chainlink抗衡。</p><h4 id="数据质量和Oracle连接范围"><a href="#数据质量和Oracle连接范围" class="headerlink" title="数据质量和Oracle连接范围"></a>数据质量和Oracle连接范围</h4><h4 id="Band-Protocol"><a href="#Band-Protocol" class="headerlink" title="Band Protocol"></a>Band Protocol</h4><p>Band协议仅支持免费的开放API。目前，他们对付费的受密码保护的API的支持完全是理论上的。当前的提议将要求数据提供商单独上岗，并修改其业务模型以加密货币支付。 Chainlink原生支持当今的所有数据源，包括通过模块化外部适配器的开放式和经过身份验证的API，这些适配器不需要数据提供商更改其现有业务模型。</p><p>编写本文时，Oracle功能在主网上尚不可用，但一旦上线，它将仅支持免费的低质量API，这些API通常每隔10分钟或更长时间更新一次，精度不超过小数点后1位点。从一开始就无法支持高质量数据，这使人们严重怀疑DeFi协议是否会感到满意，依靠Band来保护数百万美元的用户存款，尤其是当几乎所有高质量数据都存在于付费专区且仅发生一次Oracle攻击时由于数据质量低劣，最终可能导致破产并破坏应用程序的整体声誉。</p><p>Band表示BandChain将无法支持经过身份验证（受密码保护）的API，直到第2阶段（时间表尚不清楚）。密码保护的API如何实施的细节几乎不存在，在他们的文档中减去一句话，即” API提供者通过BandChain的链上支付结算来通过数据获利”。尽管这种模型不太可能已经准备好投入生产，但从整体上考虑它会暴露出逻辑上的一些缺陷。</p><p>首先，数据提供者将需要改变其现有业务模型以支持加密货币支付，这意味着Band将不得不携带成百上千的特定于应用程序的，经过身份验证的利基数据源，数据请求者需要这些数据源来构建其dApp。这既不切实际又不可扩展，将严重限制开发人员访问绝大多数数据源。</p><p>其次，它们的随机权益加权节点选择机制意味着可以潜在地选择网络中的每个节点来服务数据请求，这导致每个节点都需要访问每个潜在的数据源。这将需要与数据提供商进行激烈的协商，以达成整个区块链都可以访问的交易，以及节点之间缓慢，复杂的链外协调/治理，以共同添加新数据源并为其提供资金，这使其非常不切实际或完全不可行。</p><p>扩展性上，由于采用了这种设计选择，Band仅是所有节点都可以平等访问的唯一数据类型，因此它仅非常适合支持开放的API。这将阻止开发人员访问他们所需的特定外部数据，尤其是以任何快速无摩擦的方式。这也将消除绝大多数数据提供商永远无法加入网络，因为他们不能（出于法律原因）和/或不希望（出于商业原因）接受加密货币支付。鉴于缺乏利用BandChain生产的应用程序，任何数据提供商花费时间，资源和金钱来重新设计其业务模型以支持BandChain几乎没有意义。他们也从未详细说明过如何保护数据隐私的功能，这将进一步使BandChain不再受到希望保护其IP的数据提供商和需要保护敏感信息的企业的支持。</p><h4 id="Chainlink"><a href="#Chainlink" class="headerlink" title="Chainlink"></a>Chainlink</h4><p>Chainlink已经通过其价格参考合约利用了凭据数据源，这些参考数据是由分散的oracle网络保护的30多种DeFi价格摘要的集合，这些摘要使任何智能合约都可以在单个交易中同步提取外部数据。</p><p>Chainlink可以灵活地提供高质量的数据，因为节点始终具有内置的凭据管理功能，这些功能使它们可以使用模块化外部适配器访问任何受密码保护的API。可以使用任何编程语言编写Chainlink外部适配器，并与Chainlink节点本身分开托管。这打开了API的整个世界，例如高级数据提供商，Web API，企业系统，云提供商，IoT设备，支付系统，其他区块链（公共和私有）等等。<br>数据提供商无需更改其核心业务模型或后端基础结构即可通过智能合约访问，因为Chainlink节点可以处理外部适配器中的API密码密钥。因此，他们可以为今天使用的法定订阅模型中的已认证API付费，然后只需将其API密码密钥放在外部适配器中，然后立即开始在链上传递该数据。数据提供商更喜欢这种模型，尤其是在最初，因为它们可以在不花费任何时间，资源或金钱进行复杂区块链集成的情况下获得更多收入。</p><p>这极大地减少了开发人员的负担，因为节点可以在无需任何许可或需要所有其他节点获得相同访问权限的情况下，快速构建对任何链外数据资源的支持。它只需要一个节点或开发人员为该数据源API编写一个外部适配器，使其可用于任何区块链。然后，节点可以通过专门提供特定的数据集来区分自己。同样，如果数据提供者希望直接在链上获得报酬，则他们可以自己运行节点并直接向市场出售。实际上，一些数据提供者已经在Chainlink上这样做了，例如Huobi，Kaiko，Alpha Vantage等。重要的是，外部适配器模型可确保数据提供商始终获得报酬，而企业系统仅授权经过验证的用户。</p><p>Chainlink还高度了解Oracle隐私的必要性，因此他们在可信赖的硬件解决方案（如Town Crier）上的完善工作已得到广泛认可。企业可以使用该技术来满足隐私法规，同时在执行智能合约时仍使用其专有数据。最重要的是，企业可以准确选择哪些oracle节点满足其数据问题，这在确保机密数据（PII）即使经过加密的情况下也仅位于特定地理区域内以确保遵守诸如GDPR –许多全球企业和机构的基本要求。</p><p>Chainlink网络是一种资本主义的自由市场经济，任何人都可以运行自己的节点，开始在任何区块链上提供智能合约，并可以访问任何链下数据源API。这促进了健康的竞争，并允许节点建立自己的业务模型，而无需其他所有节点的外部依赖。相反，BandChain采取的是共产主义的，中央计划的经济方法，该方法要求网络中的每个节点都经过标准化，并支持与网络中每个其他节点相同的功能和连接，最终限制了创新，竞争和采用。</p><p>哪些开发人员或用户将信任那些不了解其核心功能到其协议中，没有学术研究或安全审核支持，并要求复制竞争对手解决方案的开发人员大量价值？ 这是BandChain如何利用现有技术，区块链和随机性功能，并试图迫使它们成为基于错误假设的Oracle解决方案的又一个示例。</p><p>Chainlink允许数据请求者准确选择他们要使用的预言软件，从而为智能合约开发人员带来最大的灵活性。 Chainlink团队已经构建了Chainlink VRF，可以用作可证明是公平的随机性源，作为区块链游戏和NFT行业的输入，而不是Chainlink协议本身的核心部分。他们理解并避免了强迫数据请求者使用随机性选择节点的严重危险，特别是无法获得高质量或许可的数据集（如数据质量部分中所述）以及无法在网络上获得确定性保证的巨大安全风险。节点运营商的可靠性或基础架构安全性。<br>Chainlink VRF已被广泛采用，在启动后的短时间内便进行了许多集成，包括：PoolTogether，Digitix，Get Protocol，Blocklords，Polyient Games，BlockPegnio，Vibe，Texel，Tiny Boxes，Cargo，Wildcards，FaceGolf和更多。 Chainlink的VRF建立在行业专家多年的学术研究基础之上，这些专家在分布式系统和高级密码学领域拥有数十年的经验，例如Ari Juels，Andrew Miller，Evan Cheng，Alex Coventry等（在下面的部分中进行详细介绍）。 Chainlink VRF不仅是由世界上一些最聪明的人内部开发的，而且还经过了顶级安全公司的审核，并经过了无数次审查才能投入生产。</p><h3 id="发展与网络效应"><a href="#发展与网络效应" class="headerlink" title="发展与网络效应"></a>发展与网络效应</h3><p>Band团队缺乏在分布式系统，高级密码学和构建oracle方面的经验，已经放弃了最初的v1版本启动，无法捕获任何网络影响，并且Band v2完全未经验证，没有在生产中使用。 自2014年以来，Chainlink团队一直在建立Oracle，其团队由40多人组成，其中包括顶级学术和业务顾问。 Chainlink还为市场领先的DeFi项目确保了Mainnet上超过$ 10B的价值，并且集成管道中有240多个项目（包括60多个区块链）。</p><p>Band v1在开发方面完全被放弃了，并且没有看到任何外部项目在生产中的使用。缺乏任何主网采用以及其价格信息的更新不频繁就证明了这一点，其中许多经常表现出较大的偏差。Band协议在设计上也进行了多次更改，包括放弃了其双令牌绑定曲线设计，等离子L2，Gas，稳定币费用支持，用户驱动的数据治理等。v1的性能不佳以及协议的不断变化质疑Band团队是否真的考虑了他们的Oracle机制的设计，以及是否可以信任他们以确保从其他用户的资金中获得数百万美元的价值。<br>Band v2（BandChain）也未经Oracle系统的完全验证，尚不支持其原始主网上的任何Oracle功能。 BandChain的大部分与区块链相关的工作都外包给了Cosmos SDK和Tendermint。对于任何现实价值而言，都缺乏经过时间考验的安全性，这意味着Band仍需要证明自己是一种可靠的解决方案，然后任何项目才能放心地相信其oracle实现来保护核心协议功能。请务必记住，甲骨文负责其他dApp的关键任务功能，例如发放贷款和执行清算。</p><p>当其他人正在考虑是否可以将整个协议的正确功能委托给您的外部Oracle机制时，成为一个好人或在您的墙上获得学位是毫无意义的。考虑到Band没有获得生产中的用户，已经进行了多次设计变更，并且仅使用提取了所有艰巨工作的SDK推出了区块链，因此任何希望使用BandChain的dApp都承担着严重的风险并且对其鲁their地进行粗鲁用户的资金。</p><p>Band团队由三位创始人组成，他们在构建区块链基础架构，oracle机制或任何处理实际价值的关键任务系统方面<strong>没有经验</strong>。他们在软件开发方面的唯一经验是在2015年创建了基于加密的手机游戏，此游戏已被放弃。为儿童构建手机游戏与构建复杂的分布式系统并不遥不可及，后者不仅为Band令牌持有者确保价值，而且最终也希望确保其他应用程序的价值。这种经验几乎没有甚至没有交叉，因为建立一个区块链的甲骨文网络是一个具有挑战性的指数难题，并且存在许多明显的陷阱和攻击媒介。他们不仅缺乏经验，而且没有学术或商业顾问来指导他们。所有这些都表明Band团队处于顶峰，<strong>这将给使用它的任何人带来巨大风险，并在不可避免地发现和利用漏洞时打开Mt Gox类型的内爆。</strong></p><p>Chainlink,至少从2014年SmartContract LTD成立（以太坊推出之前）开始，Chainlink的联合创始人一直在研究和构建外部连接的智能合约和区块链Oracle技术。该团队直接与需要区块链Oracle的顶级开发人员和企业合作，他们通过开发已在生产中使用的可靠解决方案，了解了如何满足各种不同用例的安全性，隐私性和可扩展性需求，以及应用程序。他们从未放弃过自己的初衷，而是继续在创建的坚实基础上进行创新，包括TownCrier，Threshold签名，Mixicles等原始研究开发。<br>Chainlink的40多人开发团队由区块链，甲骨文，密码学，机器学习，人工智能和业务开发方面的资深专家组成。其中包括众多学术和商业顾问，这对于Chainlink的技术和国防深度方法至关重要。</p><p>Chainlink于一年前在主网上推出，并已迅速实现大型网络效应，目前已从许多领先的DeFi项目（包括Synthetix，Aave，Loopring，Nexus Mutual，Set Protocol，bZx，Kava， 和更多。 Chainlink还拥有240多个集成开发项目，从区块链和加密货币初创企业到Google，Oracle和SWIFT等全球企业以及Hyperledger，IC3，EEA，Baseline，InterWork等企业联盟/标准化组织等等。</p><p>最终的结果是一个非常有经验和知识渊博的团队，他们有能力以加密初创公司，全球企业和顶尖学者的支持方式来解决甲骨文的难题。 开发人员拥有案例研究和明确的证明，Chainlink是一个安全可靠的Oracle解决方案，可通过在生产中的实际使用来确保高价值合同。 它的采用已经在推动一个积极的反馈循环，在该循环中，使用网络的用户，数据提供者和节点越多，对于新的和现有的利益相关者来说，作为Oracle解决方案的功能更强大，价值更高的Chainlink也就变得如此。 鉴于缺乏主网使用以及合作伙伴数量非常有限（大多数是验证者或交易所列表），Band无法实现任何网络效果。 此外，开发人员除了缺乏活力的v1版本外，还没有任何关于Band的预言的信息。</p><h3 id="资源效率与网络设计-1"><a href="#资源效率与网络设计-1" class="headerlink" title="资源效率与网络设计"></a>资源效率与网络设计</h3><p>BandChain使用自己的区块链，这对于Oracle的工作是完全不必要的-将数据传送到智能合约。 Band团队正在使用区块链解决方案来解决一个根本不同的问题，这会导致许多问题，例如状态膨胀，同步时间长和强制随机节点选择。 Chainlink并非现在也永远不会是其专有的区块链，而是真正的与区块链无关的中间件，这使得它可以灵活地支持所有DLT网络和数据资源，并为节点运营商提供轻量级的支持。<br>带<br>BandChain区块链背后的设计选择（即两个秒的块时间）导致所有节点的状态膨胀迅速增长，而新节点或重新连接的节点的同步时间更长。运行Band节点比诸如Bitcoin和Ethereum之类的区块链要昂贵得多，并且要消耗大量资源，这些区块链已针对降低硬件要求进行了优化，以增加分散性。与完全不运行专有区块链的Chainlink oracle节点相比，它的成本和资源消耗也成倍增加。</p><p>随着时间的流逝，BandChain的设计决策很可能自然导致集中度的提高，而节点大多由资本雄厚的验证者在几个数据中心中运行。这些问题与EOS和BSV等区块链受到的影响相同。为了支付运行节点的成本，如果用户费用没有增加到足够高的水平，BandChain将需要更高的新铸造令牌的通货膨胀率来维持相同级别的安全性。<br>由于Band的预言机也是块生产者，因此，块生产的失败（例如最近Cosmos SDK中的内存泄漏和状态修剪问题）也会导致预兆机制的失败。将oracle机制直接集成到区块链的基础层中也将强制执行单个整体网络设计，这由于强制实施的标准化而阻碍了oracle的创新，并极大地限制了oracle在支持各种用例方面的概括（如数据质量部分）。</p><p>BandChain通过隐秘方法通过一种安全措施有效地运作，其中验证者无需透露其身份或可靠性。 这与随机的股权加权选择相结合，意味着数据请求者必须信任在BandChain上运行的所有节点，因为他们无法控制最终将被选中的匿名或非匿名节点，从而给用户带来了很高的信任障碍。 这远非理想，因为大多数安全专家普遍认为通过模糊性来实现安全性是设计基本健壮的系统或网络的不良方法。</p><p>由于Chainlink不是区块链，因此不会遭受状态膨胀或同步时间问题。 Chainlink节点重量轻，对硬件的要求极低，可以通过一个简单的Docker容器在任何计算环境中运行。甚至将节点设置为在Raspberry Pi等极低规格的设备上运行，从而使IoT设备可以直接运行Chainlink节点以减少智能合约的跳数。由于缺乏资源需求而导致的低进入门槛极大地增加了Chainlink网络整体的分散性。</p><p>与BandChain不同，不需要所有活动Chainlink节点之间的整体全局共识，而是选择水平可伸缩性，即无限数量的oracle网络并行并行运行。 Chainlink节点不需要创建或验证任何专有区块链的块，因此不依赖于任何一个特定区块链的功能操作。对于每个单独的Oracle网络，Chainlink的安全性都是完全自主的。它没有做任何实现假设，而是提供了使用任何区块链所需的节点，数据源或参数来创建任何类型的oracle网络所需的工具。它是高度通用的，这意味着它不会对用户强加任何一种类型的oracle设计模式（推送或拉动，允许或不允许，集中或分散，开放或列入白名单，偏差阈值和/或心跳更新等），允许无限在新的Oracle模型上进行创新。<br>当前在主网上运行的Chainlink网络通过透明性原理使用安全性进行操作，其中价格参考数据网络仅由经过安全审查的节点组成，这些节点由经验丰富的区块链DevOps和分布在全球数据中心和现场裸机中的安全团队操作服务器。此外，许多独立的团队创建了多种分析服务，使最终用户和开发人员都可以直接查看每个Oracle网络的性能和历史记录。这样，任何人都可以使用以简单易用的方式呈现的历史索引链上数据来确切地知道特定的Chainlink网络或节点是否可靠。这包括feeds.chain.link（由Chainlink创建），market.link（由LinkPool创建），reputation.link（由Secure Data Links创建），honeycomb.market（由CLCG创建）等。</p><h3 id="去中心化和加密经济安全"><a href="#去中心化和加密经济安全" class="headerlink" title="去中心化和加密经济安全"></a>去中心化和加密经济安全</h3><p>由于Tendermint BFT的可伸缩性有限，BandChain使用具有100个节点上限的单个整体共识机制。验证器仅放样产生块，而对于操作或无效的外部数据则不加砍刀。 Chainlink是独立的分散式Oracle网络的集合，这些Oracle网络在众多区块链上并行运行，其阈值签名和链外聚合升级没有每个网络中节点数量的上限。 LINK放样将涉及绑定服务协议，并在数据质量，可靠性，准确性等方面采用预先定义的削减条件。</p><p>由于BandChain使用Tendermint BFT共识进行操作，因此最多只能扩展到几百个验证器，然后通信带宽才成为问题和每秒事务（TPS）池。因此，Band在任何给定时间点的验证器数量有限，最多100个节点。这是使用整体式区块链作为处理数据请求和响应的唯一共识机制的另一个缺点。它极大地限制了BandChain将能够达到的最大分散级别，除非对整个网络模型进行根本性的重新设计。<br>还需要注意的是，BandChain验证程序只有在充当糟糕的区块生产者（停机，双重签名，无响应）的情况下，才可以削减其BAND股份。充当不良或恶意的Oracle（操纵数据，Oracle网络攻击，串通）不会造成任何重大的惩罚。 BandChain中的验证者可能更专注于成为一个好的区块生产者，而不是成为一个好的预言家，因为这是决定他们是否被削减的原因。<br>尽管零售业者已经讨论了BandChain Token，但现实是，验证者的零售股份并没有为BandChain作为Oracle网络提供任何真正的价值。将来，BandChain可能会对通过链上投票传递不良数据的节点实施大幅削减，但目前很少有细节，因为仅提一个小建议，因为它们已弃用的D3N规范中只有一句话。此后，有关该主题的信息已从其github wiki上的当前文档中删除，表明他们可能对该主题几乎没有积极的开发。</p><p>尽管这个想法可能也已经被抛弃（就像许多其他以前的核心功能一样），但他们过去曾指出，零售BAND令牌涉众将有助于将数据提供者作为信誉系统机制进行管理。这代表了执行质量控制的一种非常脆弱和临界的危险形式，尤其是在考虑到它应该为价值数百万美元或更多的合同提供安全性时。散户投资者不太可能进行任何认真的尽职调查，而只会选择即时投资回报率最高的数据提供商。</p><h4 id="区块链不可知论的方法"><a href="#区块链不可知论的方法" class="headerlink" title="区块链不可知论的方法"></a>区块链不可知论的方法</h4><p>BandChain依靠尚未发布的Cosmos IBC将数据本地桥接到其他链。 当前，它仅支持lite客户端，在这些客户端中，数据必须由协议外部的未付费和可能未知的外部方传送。 Chainlink本机支持当今最领先的区块链，并将通过其自适应且易于集成的设计继续支持未来的链。</p><p>由于BandChain是其自己的区块链，因此另一个要使用Band oracles的区块链上的去中心化应用程序完全依赖于跨链通信桥。 <strong>BandChain的主要跨链功能取决于Cosmos区块链内部通信（IBC）协议</strong>，该协议不是由其团队构建的，距离全面运行和经过时间考验还需要数月甚至数年的时间，尤其是对于不信任的数据传输而言从一个区块链环境到另一个。</p><p>在此之前，将通过部署在每个集成区块链上的BandChain lite客户端执行区块链互操作性。使用Band作为预言的其他区块链上的智能合约将完全依赖于一些外部非激励性第三方向该链上的精简版客户合约提供证明。 BandChain验证器不会将这些证明提供给其他链（直到IBC为止），这意味着当前始终需要第三方在链之间中继数据。这种方法很难扩展，因为每个受支持的区块链将需要托管自己的lite客户合同，并需要Band协议之外的外部实体来提供证明并保持lite客户同步。<br>关于将数据传递给精简客户的动机存在主要问题，尤其是在网络拥挤的情况下，当交易费用在外部区块链上飙升时。需要特别注意的是，即使BandChain在其自己的区块链上聚合数据，但将数据本身广播到其他区块链也将受使用链的本机速度和延迟的影响。 Bandchain当前仅支持少数几个Testnet区块链。</p><p>Chainlink与区块链无关，但是以与BandChain根本不同的方式实现了此类功能。 Chainlink不是运行自己的专有区块链，而是一个框架，用于在任何区块链上为智能合约构建异构的分散式Oracle网络。通过模块化的外部适配器和外部启动器，Chainlink节点能够监视数据请求并将链外数据直接传递到任何区块链环境，这意味着不依赖具有可疑激励/问责制的精简客户或外部第三方。因此，Chainlink节点能够本地支持当前或将来存在的任何区块链，DLT或layer2解决方案，包括智能合约功能有限的链，例如无法托管此类lite客户端的比特币。这还包括非IBC兼容的许可链和非区块链系统，例如企业ERP / CRM后端和旧数据库，这些系统希望从加密经济保护的分散式Oracle网络中创建和使用外部数据。</p><p>Chainlink网络上受支持的区块链包括以太坊，比特币，Polkadot，Ava，NEAR，Kava，Tezos，Binance Smart Chain，BSN，IRIS，基于EVM的链，基于基质的链，Harmony，Zilliqa，本体论，Kadena，Klaytn，CasperLabs， Solana，Hdac，ICON，Conflux，Hedera Hashgraph，Matic等。有60多个区块链被集成到Chainlink协议中。最初在以太坊区块链上启动时，Chainlink的合同系统被重写为可以在其他众多区块链上本地运行，而LINK令牌则通过跨链桥包装。因此，每个Chainlink甲骨文网络仅需遵循其所运行的特定链的吞吐量和安全性假设。</p><p>即使有IBC支持（Chainlink也可以支持），Chainlink的区块链不可知论形式的规模可以远远超过BandChain。代替Bandchain通过单个区块链传递数据请求和节点响应的方法，Chainlink网络可以并行且彼此完全独立地处理数据请求和节点响应，从而提供理论上无限的水平可扩展性。 Chainlink在每个词义上都是与区块链无关的，因为它不是区块链，而是在所有区块链网络上同时运行的抽象层。</p><p><img src="/images/oracle/chainlink2.png" alt="chainlink1"></p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>Chainlink与区块链行业中最著名的研究人员一起进行两次测量并进行一次切割，以进行敏捷开发，以保持在新的前沿技术和创新之上。团队认识到了考虑周到且端到端的安全Oracle框架的重要性，该框架可以提前缓解复杂的攻击媒介。Band的做法更像是将意大利面条扔在墙上，看看遵循“快速行动并打破事物”的理念的实质，换句话说。尽管此方法可以在某些行业中使用，但绝对不是绝对必要的解决方案，它可以解决oracle问题，因为绝对安全是必须的，实际价值很容易受到无法逆转的操纵。<br>经过全面比较，<strong>Band协议将采用基于区块链的方法，通过使用整体共识来解决oracle问题</strong>，这将强制执行节点的标准化并对其分散有上限。这种僵化的模式是Band努力以可扩展的方式支持经过身份验证的API的原因，因为如果不从头开始重新设计整个数据行业，几乎所有节点都无法在其框架中支持凭据数据。他们的大多数原始开发和设计规范已被放弃，未来的功能集几乎完全是理论上的，极其模糊的或根本不存在的。虽然探索和更改有时可能会很好，但它们也可能表明有人在他们的头顶上，这尤其应与构建oracle协议时所面临的风险有关。</p><p>另外，Chainlink已确定Oracle问题与区块链问题是分开的，它采用了高度模块化的自由市场框架，该框架支持无限数量的并行Oracle网络，这些网络达成共识并保持彼此完全独立的安全性。 Chainlink用户可以在多个方面访问高级定制，包括节点选择，数据类型，安全性方法，抵押抵押，隐私支持等等。 Chainlink团队证明了其能够支持主网上DeFi项目的大型生态系统，确保超过10亿美元的用户资金的能力。 Chainlink已经在建立公益的Oracle网络，其中多个用户贡献相同的价格，从而降低了每个用户的成本。</p><p>尽管竞争是健康的，每个人都应该尽自己的努力，但真正检查用于直接保护大量用户资金的预言机机制很重要。如果智能合约经济有望扩大规模，并被风险偏好更为保守，对灵活性和质量控制有更高要求的传统机构所利用，那么，Oracle可以轻而易举。Oracle的“足够好”方法恰恰是遭到黑客入侵并失去用户资金的开发人员的心态。这与部署未经审计的智能合约没有什么不同，智能合约面临着巨大的未知安全风险，这些风险可能会使项目及其用户完全破产。同样，非通用解决方案可能会在短期内服务于一个细分市场，但会像许多高科技行业一样被通用标准所吞并。</p><p>出于这些原因，需要通过智能合约的价值和通用性来扩大安全性，以增强卓越的网络效果，我们认为，与Band Protocol相比，Chainlink迄今为止是一个非常出色的oracle解决方案。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Apr 21 2021 01:32:54 GMT+0900 (Japan Standard Time) --&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;最近项目中需要使用到Oracle,对价格进行更新，找了一圈市面上的，发现Band和Chainlink，对Chainlink的比价深有体会，遂开始深入研究下Oracle的实现机制，以及如何讲现实世界中的数据和API链接到智能合约中。 以下主要是翻译了SmartContent写的Band协议和Chainlink的对比分析的文章， 原文地址： &lt;a href=&quot;https://medium.com/@smartcontentpublication/a-comparative-analysis-of-band-protocol-and-chainlink-54b7d14823b5&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://medium.com/@smartcontentpublication/a-comparative-analysis-of-band-protocol-and-chainlink-54b7d14823b5&lt;/a&gt; ，对文章进行了翻译和补充，基本使用Google翻译进行简要的翻译，可以当成一篇PR稿文章，主要从几个维度，比如 数据质量，随机性以来，采纳指标，资源效率和网络设计，团队，去中心化和多链支持等各个方面，对Band和Chainlink进行了比较，结果都是Chainlink胜出了。&lt;/p&gt;&lt;p&gt;大杨个人意见，看过Band的创始团队和背后的投资机构，都是相当有前景，而且Oracle语言机的盈利模式上都是平台方来撮合数据需求方和提供方调用，然后支付方式都是用平台的虚拟币支付，这样的方式其实也带来了很大不确定性，随着平台方币价的上涨，也带来了需求方很大的调用成本，本身现在公开的调用方式，实时性也不好，如果采用较为实时的解决方案，那么使用LINK代币来支付的费用，换算成法币的话，也是非常高的。从文章从可以看到的是Band协议V2，依赖于与Cosmos, 而且很区块链化，对于用户的直接引入也很不友好，此外Chainlink VRF作为一个显著的重大热点，为NFT提供服务，Band目前还没有什么亮点仅仅挂个Oracle的竞争者。整体来看，Band还是比较困难的，推荐大家使用Chainlink.&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/images/oracle/oracle.png&quot; alt=&quot;Oracle Analysis&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="blockchain" scheme="http://yangxinqi.com/categories/blockchain/"/>
    
    
      <category term="oracle, band, chainlink" scheme="http://yangxinqi.com/tags/oracle-band-chainlink/"/>
    
  </entry>
  
  <entry>
    <title>DEFI深入浅出实战编程一入门篇</title>
    <link href="http://yangxinqi.com/2020/09/24/DEFI%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%AE%9E%E6%88%98%E7%BC%96%E7%A8%8B%E4%B8%80%E5%85%A5%E9%97%A8%E7%AF%87/"/>
    <id>http://yangxinqi.com/2020/09/24/DEFI深入浅出实战编程一入门篇/</id>
    <published>2020-09-24T10:47:25.000Z</published>
    <updated>2020-11-02T03:01:35.640Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Apr 21 2021 01:32:54 GMT+0900 (Japan Standard Time) --><p>翻译者： 大杨， 链因智能CEO， 一家初创区块链技术公司，DEFI布道者。</p><p>技术点： DEFI，ETH，NODEJS，SOLIDITY</p><p>今天抽出了一些时间，翻译了CoinBase的<a href="https://twitter.com/petejkim" target="_blank" rel="noopener"><em>Pete Kim</em></a> 写的【<a href="https://blog.coinbase.com/introduction-to-building-on-defi-with-ethereum-and-usdc-part-1-ea952295a6e2" target="_blank" rel="noopener">Introduction to Building on DeFi with Ethereum and USDC — Part 1</a>】DEFI编程入门学习的文章。</p><p>翻了下Pete Kim的twitter和他的github，发现是个全栈高手和社区活跃者，看上去应该是韩国人，技术很不错，人也很帅 😂。</p><p>最为美系的第一交易所CoinBase对整个Crypto生态的贡献是巨大的，本篇DEFI编程的入门文章也非常适合新手，看了有很想翻译的冲动，就花了2小时做了下整理，并在kovan的网络上实战了一把，对很多细节的地方做了补充，强烈推荐给大家。 经历DEFI，后续链因智能3年积累的相关技术都会进行开源，通过开源促进技术发展。</p><a id="more"></a><p><strong>以下是文章的内容：</strong></p><p>首先介绍 CoinBase 的价值观和愿景。</p><p>在Coinbase，我们的任务是建立一个开放的财务系统。我们坚信，促进经济自由将使世界变得更美好。分布式金融，简称DeFi-一种开放，无边界和可编程的金融-是我们伟大愿景不可分割的一部分。</p><h3 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h3><p>DeFi由运行在分布式网络（例如以太坊（“区块链”））上的数字货币（如美元代币（USDC））智能合约组成。智能合约的想法由来实际上很简单。数字货币和密码学的先驱尼克·萨博（Nick Szabo）最初在1997年提出了这个想法，他将<strong>自动售货机</strong>描述为<strong>智能合约的始祖</strong>。</p><p>自动售货机是合同的自动化版本，以电子硬件的形式表示：<br>您通过向机器中投入钱来支付显示的价格，机器将为您分配饮料<br>您不支付显示的价格，也不分配饮料<br>如果您支付了显示的价格但机器没有分配饮料，或者即使您没有支付显示的价格也分配了饮料，则违反了合同<br>自动售货机无需人工干预即可完全自主地管理其合同义务。<br>现代智能合约的工作方式相同，但是合约条款被表示为可执行的计算机代码，而不是在硬件中实现。在其上运行智能合约的网络的分散性确保了它们以书面形式执行，并且没有任何单个实体能够弯曲规则或操纵结果。一个重要的警告是，因为网络逐字执行代码，所以错误的智能合约代码可能会导致意外的后果（“代码就是法律”）。</p><h3 id="没有比现在更好的时机"><a href="#没有比现在更好的时机" class="headerlink" title="没有比现在更好的时机"></a><strong>没有比现在更好的时机</strong></h3><p>许多人发现基于加密技术构建的区块链非常令人生畏，并认为只有坚韧的计算机科学家才能使用它。尽管就在几年前，情况确实如此，但自那时以来，工具和开发人员用户体验已有了显着改善，任何具有基本编程技能的人都可以开始构建。<br>DeFi生态系统目前正在爆炸性增长。 USDC在不到2年的时间里达到了$1B的市值，并且在不到3年的时间内，存储在各种DeFi服务中的资产总值超过$2B。确实没有一个哪个领域有这么好的时机快速发展。</p><p><img src="/images/defi/defi_1.png" alt="DeFi Pulse"><br>来源：DeFi Pulse</p><p>以下教程是开始开发自己的DeFi智能合约的简单指南。<br>我们希望，<strong>这样的指南将有助于建立全球开放的民主化金融体系</strong>。</p><h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><p>本教程系列假定您具有JavaScript的经验，JavaScript是世界上使用最广泛的编程语言。您也可能被介绍过Solidity，这是一种在以太坊上使用的智能合约编程语言，这是世界上使用最广泛的智能合约区块链编程语言。最后，您将与DeFi应用常用稳定币USDC进行交互（这里我们Fake了一个USDC，不是真实USDC）。</p><h3 id="搭建开发环境"><a href="#搭建开发环境" class="headerlink" title="搭建开发环境"></a>搭建开发环境</h3><p>首先，我们需要一个类似Unix的环境，并在其上安装Node.js v12.x（最新的LTS版本）。 MacOS本质上是Unix环境，Windows用户可以通过从Microsoft Store在WSL上安装Ubuntu来获得它。在MacOS和Windows中可以找到更详细的步骤。对于代码编辑器，强烈建议使用 <strong>Visual Studio Code</strong>，因为您要使用的项目模板已经预先配置好了，但是从技术上讲，您可以使用任何编辑器。哦，我更喜欢Vim而不是Emacs。</p><h3 id="设置项目"><a href="#设置项目" class="headerlink" title="设置项目"></a>设置项目</h3><p>设置Solidity项目需要一些工作，老实说，分心对于这个阶段的学习不是很有用，因此已经为您准备了一个预先配置的模板。</p><p>这块作者提供了一个很好的模版来跑，原地址： <a href="https://github.com/CoinbaseStablecoin/solidity-tutorial" target="_blank" rel="noopener">https://github.com/CoinbaseStablecoin/solidity-tutorial</a> ，这里我做了一些修改，FORK了一个项目地址，大家需要看代码的可以用下面的地址，作者提供的模版非常方便，可以让动手，推荐使用作者的地址。</p><p>在终端中运行以下命令以下载并设置模板：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/CoinbaseStablecoin/solidity-tutorial.git <span class="comment"># 作者原模版地址</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/chaininout/solidity-tutorial.git  <span class="comment"># 这个是包含了最新代码的地址</span></span><br><span class="line"><span class="built_in">cd</span> solidity-tutorial</span><br><span class="line">npm install -g yarn        <span class="comment"># Install yarn package manager 安装包管理器</span></span><br><span class="line">yarn                       <span class="comment"># Install project dependencies 安装依赖</span></span><br></pre></td></tr></table></figure><p>当yarn尝试构建本机扩展时，您可能会看到一些编译错误。这些是可选的，可以忽略这些错误。只要您最后看到“完成”消息，就可以继续。</p><h3 id="在Visual-Studio-Code中打开项目"><a href="#在Visual-Studio-Code中打开项目" class="headerlink" title="在Visual Studio Code中打开项目"></a>在Visual Studio Code中打开项目</h3><p>在Visual Studio Code中打开项目文件夹（solidity-tutorial）。第一次打开项目时，Visual Studio Code可能会提示您安装扩展。继续并单击“全部安装”，这将向编辑器添加各种有用的扩展，例如自动代码格式和Solidity语法突出显示。</p><h3 id="在以太坊上创建账户"><a href="#在以太坊上创建账户" class="headerlink" title="在以太坊上创建账户"></a>在以太坊上创建账户</h3><p>在以太坊上进行任何操作之前，您需要拥有一个帐户。帐户通常称为“钱包”，因为它们可以包含ETH和USDC等数字资产。最终用户通常使用Coinbase Wallet或Metamask等以太坊钱包应用程序创建帐户，但是使用模板随附的出色的ethers.js库，以编程方式创建帐户也非常简单。</p><p>在src文件夹中创建一个名为createWallet.js的新JavaScript文件，然后输入以下代码：</p><p>保存文件，并使用Node执行代码，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ethers = <span class="built_in">require</span>(<span class="string">"ethers"</span>);</span><br><span class="line"><span class="keyword">const</span> wallet = ethers.Wallet.createRandom();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`Mnemonic: <span class="subst">$&#123;wallet.mnemonic.phrase&#125;</span>`</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`Address: <span class="subst">$&#123;wallet.address&#125;</span>`</span>);</span><br></pre></td></tr></table></figure><p>在shell命令行状态下执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node src/createWallet.js</span><br></pre></td></tr></table></figure><p>执行后生成如下结果, 生成助记词和地址：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mnemonic: viable glow tone pole input series weather slam blouse embark achieve position</span><br><span class="line">Address: 0x6598f11d48Da2bfA897d5Eb3968223f98dabc008</span><br></pre></td></tr></table></figure><p>刚才发生了什么？ <strong>好吧，您拥有了一个全新的以太坊账户。</strong> “助记符”或可能更普遍地称为“恢复短语”是从帐户执行操作所需的密钥的人类可读表示，并且地址是帐户的名称和标识符。将它们复制到某个地方。附带说明一下，<strong>本文中显示的助记符已稍作更改，以阻止您使用它，请使用您自己的助记符</strong>！</p><p>可以将它们视为银行帐户的密码和帐号，只需要几秒钟即可创建一个，并且不必填写申请表或共享任何个人信息。您也可以在任何地方运行此代码。<br>⚠️<strong>注意该帐户的记忆符号必须保密。如果丢失，您将永远无法访问您的帐户以及该帐户中存储的所有资产，没有人能够为您提供帮助！妥善保管！</strong><br>从技术上讲，您本身并没有真正“创建”帐户。相反，您创建的是<strong>私钥/公钥对</strong>。如果您对引擎盖下实际发生的事情感到好奇，请阅读椭圆曲线密码学以及比特币和以太坊规范BIP39，BIP32，EIP55及其在此项目中的实现。</p><h2 id="关于Gas燃料和挖矿"><a href="#关于Gas燃料和挖矿" class="headerlink" title="关于Gas燃料和挖矿"></a>关于Gas燃料和挖矿</h2><p>以太坊是一个分布式网络，由世界各地成千上万的计算机组成，它们并非完全免费。要在区块链上执行任何状态更改（例如存储和更新数据），您必须向网络运营商支付以太坊（ETH）的交易费，在以太坊上也称为“ GAS”。这与运营商为在链中添加新区块而获得的奖励一样，也激励着他们保持计算机正常运行。此过程称为“挖矿”，而网络运营商称为“矿工”。我们将在本教程的后面部分（GAS，GAS价格和GAS限制）再次讨论这一点。</p><h3 id="获取测试网ETH"><a href="#获取测试网ETH" class="headerlink" title="获取测试网ETH"></a>获取测试网ETH</h3><p>现在您已经有一个帐户，您应该存入一些ETH。我们不想在开发时浪费真钱，因此我们将获得一些假的ETH，用于在测试网络（“ testnet”）上进行开发和测试。有许多不同的以太坊测试网，但由于容易获得测试Token，因此我们将使用Kovan。首先，让我们使用以太坊的区块浏览器Etherscan检查当前余额。为此，您可以在浏览器中输入以下网址，然后用您之前创建的地址（从0x开始）替换 0x6598f11d48Da2bfA897d5Eb3968223f98dabc008。<br><a href="https://kovan.etherscan.io/address/0x6598f11d48Da2bfA897d5Eb3968223f98dabc008" target="_blank" rel="noopener">https://kovan.etherscan.io/address/0x6598f11d48Da2bfA897d5Eb3968223f98dabc008</a><br>您应该看到您的余额为0 ETH。保持此选项卡处于打开状态，然后在其他选项卡中打开Kovan Ethereum Faucet 地址： <a href="https://faucet.kovan.network。在页面中，输入您的地址，然后单击“发送给我”按钮。交易可能只需要几秒钟到一分钟或一两分钟即可完成。再次检查Etherscan，您应该在列表中看到1" target="_blank" rel="noopener">https://faucet.kovan.network。在页面中，输入您的地址，然后单击“发送给我”按钮。交易可能只需要几秒钟到一分钟或一两分钟即可完成。再次检查Etherscan，您应该在列表中看到1</a> ETH的新余额和一笔传入交易。</p><p><img src="/images/defi/defi_2.png" alt="DeFi Pulse"><br>资料来源：<a href="https://faucet.kovan.network" target="_blank" rel="noopener">https://faucet.kovan.network</a></p><h2 id="以编程方式获取ETH余额"><a href="#以编程方式获取ETH余额" class="headerlink" title="以编程方式获取ETH余额"></a>以编程方式获取ETH余额</h2><p>连接以太坊，使用Etherscan查看余额非常有用，但是也可以通过代码轻松查看余额。但是，在回到代码之前，我们需要一种连接到以太坊的方法。有很多方法可以做到这一点，包括自己在计算机上运行网络节点，但是到目前为止，最快，最简单的方法是通过诸如INFURA或Alchemy之类的托管节点提供程序来实现，也可以自建节点。前往INFURA，创建一个免费帐户并创建一个新项目以获取API密钥（项目ID），链接这里： <a href="https://infura.io/dashboard/ethereum" target="_blank" rel="noopener">https://infura.io/dashboard/ethereum</a> 注册后在面板中创建自己的Project，然后拿到APIKEY。如果要自己搭建节点，也可以使用Go Ethereum（“ geth”）和Open Ethereum（以前称为Parity Ethereum）是两种使用最广泛的以太坊节点软件，这里后续我会在后续章节中列举节点搭建。</p><h4 id="用代码查看ETH余额"><a href="#用代码查看ETH余额" class="headerlink" title="用代码查看ETH余额"></a>用代码查看ETH余额</h4><p>首先，让我们编写代码以从助记符中读取并获取帐户。在src文件夹中创建一个名为wallet.js的新JavaScript文件，然后输入以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ethers = <span class="built_in">require</span>(<span class="string">"ethers"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Replace the following with your own mnemonic 这里输入刚刚生成的助记词</span></span><br><span class="line"><span class="keyword">const</span> mnemonic =</span><br><span class="line">  <span class="string">"rabbit enforce proof always embrace tennis version reward scout shock license wing"</span>;</span><br><span class="line"><span class="keyword">const</span> wallet = ethers.Wallet.fromMnemonic(mnemonic);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`Mnemonic: <span class="subst">$&#123;wallet.mnemonic.phrase&#125;</span>`</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`Address: <span class="subst">$&#123;wallet.address&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = wallet;</span><br></pre></td></tr></table></figure><p>用您自己的代码替换助记符字符串。<strong>请注意，在生产代码中，助记符不应该这样硬编码</strong>。相反，应从配置文件或环境变量中读取它，以免例如由于将其检入源代码存储库而意外泄漏。<br>执行代码，您应该能够看到与之前获得的地址相同的地址：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  solidity-tutorial git:(master) ✗ node src/wallet.js</span><br><span class="line">Mnemonic: viable glow tone pole input series weather slam blouse embark achieve position</span><br><span class="line">Address: 0x6598f11d48Da2bfA897d5Eb3968223f98dabc008</span><br></pre></td></tr></table></figure><p>看到生成的地址：0x6598f11d48Da2bfA897d5Eb3968223f98dabc008<br>接下来，在同一文件夹中创建一个名为provider.js的新文件。在此文件中，我们将使用我们先前获得的INFURA API密钥初始化提供者对象。确保将API密钥字符串替换为您自己的字符串：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const ethers = require("ethers");</span><br><span class="line">// 注意这里我们使用的kovan的网络，下面是infura上申请的key</span><br><span class="line">const provider = ethers.getDefaultProvider("kovan", &#123;</span><br><span class="line">  // Replace the following with your own INFURA API key</span><br><span class="line">  infura: "c844845b06f84d379ba3fb3bba5a1f99",</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">module.exports = provider;</span><br></pre></td></tr></table></figure><p>注意这里需要在truffle-config.js进行网络配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">networks: &#123;</span><br><span class="line">    development: &#123;</span><br><span class="line">      host: <span class="string">"localhost"</span>,</span><br><span class="line">      port: <span class="number">8545</span>,</span><br><span class="line">      network_id: <span class="string">"*"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    mainnet: infuraProvider(<span class="string">"mainnet"</span>, <span class="number">1</span>),</span><br><span class="line">    ropsten: infuraProvider(<span class="string">"ropsten"</span>, <span class="number">3</span>),</span><br><span class="line">    kovan: infuraProvider(<span class="string">"kovan"</span>, <span class="number">42</span>), <span class="comment">//这个是我们加上的测试网络，因为比较快</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>最后，我们将使用在同一文件夹中新建名为getBalance.js的新文件，并通过wallet.js和provider.js来获取ETH余额：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const ethers = require("ethers");</span><br><span class="line">const wallet = require("./wallet");</span><br><span class="line">const provider = require("./provider");</span><br><span class="line"></span><br><span class="line">async function main() &#123;</span><br><span class="line">  const account = wallet.connect(provider);</span><br><span class="line">  const balance = await account.getBalance();</span><br><span class="line">  console.log(`ETH Balance: $&#123;ethers.utils.formatUnits(balance, 18)&#125;`);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main();</span><br></pre></td></tr></table></figure><p>运行代码，您将看到ETH余额！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">node src/getBalance.js</span><br><span class="line">Mnemonic: viable glow tone pole input series weather slam blouse embark achieve position</span><br><span class="line">Address: 0x6598f11d48Da2bfA897d5Eb3968223f98dabc008</span><br><span class="line">ETH Balance: 1.0</span><br></pre></td></tr></table></figure><h4 id="代币计价"><a href="#代币计价" class="headerlink" title="代币计价"></a>代币计价</h4><p>我们刚刚创建的代码很容易解释，但是您可能想知道ethers.utils.formatUnits（balance，18）的作用。好吧，ETH实际上可以整除到小数点后18位，最小的面额单位称为“ wei”（发音为“ way”）。换句话说，一个ETH等于1,000,000,000,000,000,000 wei。另一个常见的面额是Gwei（发音为“ Giga-way”），为10亿魏。 getBalance方法碰巧以wei返回结果，因此我们必须通过将结果乘以10⁸将其转换回ETH。可以在这里找到所有面额的清单。<br>您还可以使用ethers.utils.formatEther（balance），这是ethers.utils.formatUnits（balance，18）的简写。</p><h4 id="获取Testnet-USDC"><a href="#获取Testnet-USDC" class="headerlink" title="获取Testnet USDC"></a>获取Testnet USDC</h4><p>您帐户中的ETH感到有些孤单，所以我们也想获取其中的USDC。我在Kovan测试网上部署了一个FakeUSDC智能合约。它没有专门的水龙头网站，但合同包含一项功能，在调用该功能时，您将获得一些免费的Kovan测试网USDC。如果您导航到Etherscan中的合同代码选项卡，并在合同源代码中搜索gimmeSome。这就是我们要调用的功能，用于将一些USDC发送到我们的帐户。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity <span class="number">0.6</span><span class="number">.12</span>;</span><br><span class="line"></span><br><span class="line">contract FakeUSDC is Ownable, ERC20 &#123;</span><br><span class="line">    <span class="keyword">constructor</span>() public Ownable() ERC20("FakeUSDC", "USDC") &#123;</span><br><span class="line">        _setupDecimals(<span class="number">6</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">mint</span>(<span class="params">address account, uint256 amount</span>) <span class="title">external</span> <span class="title">onlyOwner</span> </span>&#123;</span><br><span class="line">        _mint(account, amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">burn</span>(<span class="params">address account, uint256 amount</span>) <span class="title">external</span> <span class="title">onlyOwner</span> </span>&#123;</span><br><span class="line">        _burn(account, amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @notice Give the caller 10 USDC (10,000,000 units)</span></span><br><span class="line"><span class="comment">     * 这里我们加了个给测试账户发送代币的方法，能够免费给账户发送USDC测试代币</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">gimmeSome</span>(<span class="params"></span>) <span class="title">external</span> </span>&#123;</span><br><span class="line">        _mint(msg.sender, <span class="number">10e6</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="进行交易以调用智能合约"><a href="#进行交易以调用智能合约" class="headerlink" title="进行交易以调用智能合约"></a>进行交易以调用智能合约</h4><p>在以太坊智能合约中主要有两种类型的功能：<strong>读写和只读</strong>。前者可能导致存储在区块链中的数据发生变化，而后者纯粹是读取但从未写入。可以在不创建事务的情况下调用只读函数，因此无需支付交易费用，除非作为读写函数的一部分进行调用。另一方面，<strong>必须在交易内部调用读写功能</strong>，并且必须支付交易费（GAS）。调用gimmeSome函数会导致存储在区块链中的USDC余额发生变化，因此<strong>必须在交易内部调用它</strong>。</p><p>调用智能合约功能需要一些额外的步骤，但这并不太困难。首先，我们需要找到我们要调用的函数的完整接口，也称为<strong>函数签名或函数原型</strong>。在合同源代码中再次查找gimmeSome，您将发现界面如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gimmeSome</span>(<span class="params"></span>) <span class="title">external</span></span></span><br></pre></td></tr></table></figure><p>这是一个非常简单的函数，不带任何参数，<strong>并且被标记为外部函数，这意味着该函数只能从外部调用，而不能从该协定内的其他函数调用</strong>。因为我们将在事务中直接调用此函数。<br>显而易见，在以太坊主网络上部署的“真实” USDC合约中 <strong>不存在gimmeSome功能</strong>。 下面需要去部署智能合约，才能获取合约的地址，以便在下面调用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MNEMONIC=<span class="string">"viable glow tone pole input series weather slam blouse embark achieve position"</span> INFURA_API_KEY=<span class="string">"c844845b06f84d379ba3fb3bba5a1f99"</span> truffle deploy --network=kovan</span><br></pre></td></tr></table></figure><p>我们执行 truffle deploy 命令，在kovan测试网络中发布我们写好的合约。 签名的2个是地址的私钥和INFURA的KEY，这样能够用这个账户部署合约，部署完成后将现实如下过程，部署的合约数量和总共花费的GAS的费用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">3_init_FakeUSDC.js</span><br><span class="line">==================</span><br><span class="line"></span><br><span class="line">   Deploying <span class="string">'FakeUSDC'</span></span><br><span class="line">   --------------------</span><br><span class="line">   &gt; transaction <span class="built_in">hash</span>:    0x239e6922e55957d964dec79ffc2a8667b375c87185e47a334d824ffea89d9c0f</span><br><span class="line">   &gt; Blocks: 1            Seconds: 5</span><br><span class="line">   &gt; contract address:    0x4bB2ef39DD99A01BD5C11dDd25F890FeB45081e9  <span class="comment"># 这个我们在后续要用到</span></span><br><span class="line">   &gt; block number:        21121362</span><br><span class="line">   &gt; block timestamp:     1600937752</span><br><span class="line">   &gt; account:             0x6598f11d48Da2bfA897d5Eb3968223f98dabc008</span><br><span class="line">   &gt; balance:             0.95161372</span><br><span class="line">   &gt; gas used:            1705672 (0x1a06c8)</span><br><span class="line">   &gt; gas price:           20 gwei</span><br><span class="line">   &gt; value sent:          0 ETH</span><br><span class="line">   &gt; total cost:          0.03411344 ETH</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   &gt; Saving migration to chain.</span><br><span class="line">   &gt; Saving artifacts</span><br><span class="line">   -------------------------------------</span><br><span class="line">   &gt; Total cost:          0.03411344 ETH</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Summary</span><br><span class="line">=======</span><br><span class="line">&gt; Total deployments:   3</span><br><span class="line">&gt; Final cost:          0.03985546 ETH</span><br></pre></td></tr></table></figure><p>拿到合约地址，在src文件夹中创建一个名为getTestnetUSDC.js的新文件，然后输入以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ethers = <span class="built_in">require</span>(<span class="string">"ethers"</span>);</span><br><span class="line"><span class="keyword">const</span> wallet = <span class="built_in">require</span>(<span class="string">"./wallet"</span>);</span><br><span class="line"><span class="keyword">const</span> provider = <span class="built_in">require</span>(<span class="string">"./provider"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> account = wallet.connect(provider);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> usdc = <span class="keyword">new</span> ethers.Contract(</span><br><span class="line">    <span class="string">"0x68ec573C119826db2eaEA1Efbfc2970cDaC869c4"</span>,   <span class="comment">//这里是我们发布的合约地址</span></span><br><span class="line">    [<span class="string">"function gimmeSome() external"</span>],   <span class="comment">//我们本次需要调用的函数名 </span></span><br><span class="line">    account</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> tx = <span class="keyword">await</span> usdc.gimmeSome(&#123; <span class="attr">gasPrice</span>: <span class="number">20e9</span> &#125;);  <span class="comment">//指定gas</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Transaction hash: <span class="subst">$&#123;tx.hash&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> receipt = <span class="keyword">await</span> tx.wait();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Transaction confirmed in block <span class="subst">$&#123;receipt.blockNumber&#125;</span>`</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Gas used: <span class="subst">$&#123;receipt.gasUsed.toString()&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main();</span><br></pre></td></tr></table></figure><p>该代码首先使用我们感兴趣的函数gimmeSome的接口实例化一个合同对象（新ethers.Contract），并将其指向testnet Fake USDC合同的地址：0x68ec⋯69c4。然后，您可以调用列出的任何功能。 gimmeSome函数本身不会接受任何参数，但是您可以将事务选项指定为最后一个参数。在这种情况下，我们给它20 Gwei的GAS价格，这将加快交易速度。本质上，与网络交互的所有方法都是异步的，并返回Promise，因此我们使用的是JavaScript的await表达式。然后，代码将打印交易哈希，这是您交易的唯一标识符，可用于跟踪进度。然后等待直到确认交易。<br>运行代码，您将看到类似以下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node src/getTestnetUSDC.js</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  solidity-tutorial git:(master) ✗ node src/getTestnetUSDC.js</span><br><span class="line">Mnemonic: viable glow tone pole input series weather slam blouse embark achieve position</span><br><span class="line">Address: 0x6598f11d48Da2bfA897d5Eb3968223f98dabc008</span><br><span class="line">Transaction <span class="built_in">hash</span>: 0xf7ca007d794ea7d530da36b8cc55f6dce3c99276d65d45e0d32ea10290505666</span><br><span class="line">Transaction confirmed <span class="keyword">in</span> block 21121386</span><br><span class="line">Gas used: 65221</span><br></pre></td></tr></table></figure><p>瞧！您已经使用代码进行了首次以太坊交易！在Kovan Etherscan中检查您的地址和交易哈希。现在您应该看到，由于执行交易所支付的汽油费用，您现在拥有10个测试网USDC和略少于1 ETH。</p><p>ℹ️如果您在Etherscan中检查交易，您会发现这是将 <strong>（0）ETH与4字节数据</strong>一起发送到合约地址的交易。如果函数调用具有参数，则将不止4个字节的数据。如果您想了解此数据的编码方式，请阅读以太坊合约ABI规范。</p><h4 id="GAS，GAS价格和GAS限额"><a href="#GAS，GAS价格和GAS限额" class="headerlink" title="GAS，GAS价格和GAS限额"></a>GAS，GAS价格和GAS限额</h4><p>之前，我提到过，我们为交易提供20 Gwei的价格，以加快交易速度，并且脚本还显示使用的GAS量。这些都是什么意思？嗯，以太坊是一个由网络运营商组成的网络。将其视为一台世界计算机。它不是一台免费的计算机，您在该计算机上运行的每条指令都需要钱。该计算机也被世界各地的所有人共享，这意味着每个人都必须互相竞争才能在此计算机上花费时间。</p><p>我们如何做到这一点？</p><p>好吧，我们可以在这台计算机上拍卖时间，而您愿意为在此计算机上运行的每条计算指令支付的费用越多，网络运营商（矿工）将给您更多的时间。这种确定不是完美的，因为它可能会导致只有富人才能使用此系统的特权。但是，这是我们拥有的最差的解决方案，直到系统具有更高的可伸缩性并可以容纳更多的交易为止。<br>回到区块链的术语上，“已使用的GAS”是您运行交易后消耗的计算资源量，“GAS价格”是您愿意为每单位天然气支付多少费用。通常，您愿意支付的费用越高，交易的优先级就越高，并且网络会更快地对其进行确认。在我们的案例中，我们使用20 Gwei作为GAS价格，使用的GAS为35121（您还可以通过在Etherscan中检查交易来找到此价格），因此总GAS成本为35121 <em>20 Gwei = 702,420 Gwei 或0.00070242 ETH。<br>由于用GAS要花钱，因此您可能需要设置您愿意花费的最大GAS上限。幸运的是，您可以设置“GAS限制”。如果交易最终需要的GAS超过指定的GAS上限，则交易将失败，而不是继续执行并消耗比您愿意支付的更多的GAS。要注意的一个副作用是，<em>*如果执行由于限制而最终失败，那么已花费的汽油量将不会退还给您</em></em>。</p><h4 id="调用智能合约功能以读取数据"><a href="#调用智能合约功能以读取数据" class="headerlink" title="调用智能合约功能以读取数据"></a>调用智能合约功能以读取数据</h4><p>您可以检查是否在Etherscan上收到了10 USDC，但请通过代码检查余额来确认这一点。<br>我们在src文件夹中的创建个新文件getFakeUSDCBalance.js，内容如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ethers = <span class="built_in">require</span>(<span class="string">"ethers"</span>);</span><br><span class="line"><span class="keyword">const</span> wallet = <span class="built_in">require</span>(<span class="string">"./wallet"</span>);</span><br><span class="line"><span class="keyword">const</span> provider = <span class="built_in">require</span>(<span class="string">"./provider"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> account = wallet.connect(provider);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Define FakeUSDC contract interface</span></span><br><span class="line">  <span class="keyword">const</span> usdc = <span class="keyword">new</span> ethers.Contract(</span><br><span class="line">    <span class="string">"0x4bB2ef39DD99A01BD5C11dDd25F890FeB45081e9"</span>,</span><br><span class="line">    [</span><br><span class="line">      <span class="string">"function balanceOf(address _owner) public view returns (uint256 balance)"</span>,</span><br><span class="line">    ],</span><br><span class="line">    account</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// get eth</span></span><br><span class="line">  <span class="keyword">const</span> ethBalance = <span class="keyword">await</span> account.getBalance();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`ETH Balance: <span class="subst">$&#123;ethers.utils.formatEther(ethBalance)&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Call FackUSDC balanceOf function</span></span><br><span class="line">  <span class="keyword">const</span> usdcBalance = <span class="keyword">await</span> usdc.balanceOf(account.address);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`USDC Balance: <span class="subst">$&#123;ethers.utils.formatUnits(usdcBalance, <span class="number">6</span>)&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main();</span><br></pre></td></tr></table></figure><p>USDC是ERC20代币，因此它包含ERC20规范中定义的所有方法。 balanceOf是其中之一，其接口直接来自规格。 balanceOf是一个只读函数，因此可以免费调用，不需要作为事务提交。 <strong>最后，重要的是要注意，USDC使用6个小数位精度，而许多其他ERC20令牌使用18个精度。</strong></p><p>您可以在此处了解有关Solidity函数的更多信息。<br>运行代码，现在您还将看到USDC余额：执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  solidity-tutorial git:(master) ✗ node src/getFakeUSDCBalance.js </span><br><span class="line">Mnemonic: viable glow tone pole input series weather slam blouse embark achieve position</span><br><span class="line">Address: 0x6598f11d48Da2bfA897d5Eb3968223f98dabc008</span><br><span class="line">ETH Balance: 0.9497621</span><br><span class="line">USDC Balance: 10.0   //这里拿到了 USDC返回的数量</span><br></pre></td></tr></table></figure><h4 id="转移ETH和USDC"><a href="#转移ETH和USDC" class="headerlink" title="转移ETH和USDC"></a>转移ETH和USDC</h4><p>现在，让我们看看如何使用帐户中的ETH和USDC。</p><h5 id="转移ETH"><a href="#转移ETH" class="headerlink" title="转移ETH"></a>转移ETH</h5><p>在src文件夹中创建transferETH.js并输入以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ethers = <span class="built_in">require</span>(<span class="string">"ethers"</span>);</span><br><span class="line"><span class="keyword">const</span> wallet = <span class="built_in">require</span>(<span class="string">"./wallet"</span>);</span><br><span class="line"><span class="keyword">const</span> provider = <span class="built_in">require</span>(<span class="string">"./provider"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> account = wallet.connect(provider);</span><br><span class="line">  <span class="keyword">let</span> to, value;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Parse the first argument - recipient address</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    to = ethers.utils.getAddress(args[<span class="number">0</span>]);</span><br><span class="line">  &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">`Invalid recipient address: <span class="subst">$&#123;args[<span class="number">0</span>]&#125;</span>`</span>);</span><br><span class="line">    process.exit(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Parse the second argument - amount</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    value = ethers.utils.parseEther(args[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (value.isNegative()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">`Invalid amount: <span class="subst">$&#123;args[<span class="number">1</span>]&#125;</span>`</span>);</span><br><span class="line">    process.exit(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> valueFormatted = ethers.utils.formatEther(value);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check that the account has sufficient balance</span></span><br><span class="line">  <span class="keyword">const</span> balance = <span class="keyword">await</span> account.getBalance();</span><br><span class="line">  <span class="keyword">if</span> (balance.lt(value)) &#123;</span><br><span class="line">    <span class="keyword">const</span> balanceFormatted = ethers.utils.formatEther(balance);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.error(</span><br><span class="line">      <span class="string">`Insufficient balance to send <span class="subst">$&#123;valueFormatted&#125;</span> (You have <span class="subst">$&#123;balanceFormatted&#125;</span>)`</span></span><br><span class="line">    );</span><br><span class="line">    process.exit(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Transferring <span class="subst">$&#123;valueFormatted&#125;</span> ETH to <span class="subst">$&#123;to&#125;</span>...`</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Submit transaction</span></span><br><span class="line">  <span class="keyword">const</span> tx = <span class="keyword">await</span> account.sendTransaction(&#123; to, value, <span class="attr">gasPrice</span>: <span class="number">20e9</span> &#125;);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Transaction hash: <span class="subst">$&#123;tx.hash&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> receipt = <span class="keyword">await</span> tx.wait();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Transaction confirmed in block <span class="subst">$&#123;receipt.blockNumber&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main(process.argv.slice(<span class="number">2</span>));</span><br></pre></td></tr></table></figure><p>这段代码虽然比以前的代码长，但实际上只是到目前为止<strong>所学到的一切的结合</strong>。该脚本接受两个命令行参数。<strong>第一个是收件人地址，第二个是发送金额</strong>。然后，它确保提供的地址有效，提供的金额不为负，<strong>并且帐户具有足够的余额以能够发送所请求的金额。然后，它提交交易并等待确认。</strong><br>使用我们之前创建的createWallet.js脚本<strong>创建一个新帐户，然后尝试向新地址汇款</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  solidity-tutorial git:(master) ✗ node src/createWallet.js </span><br><span class="line">Mnemonic: put among keep license two negative version uniform claw zebra health input</span><br><span class="line">Address: 0x7B6d22b2130e585f5dacb40dE9Ff9DbD23E5CDB0</span><br></pre></td></tr></table></figure><p>我们建了个新地址，在将0.1 ETH转移到 0x7B6d22b2130e585f5dacb40dE9Ff9DbD23E5CDB0 新地址上：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  solidity-tutorial git:(master) ✗ node src/transferETH.js 0x7B6d22b2130e585f5dacb40dE9Ff9DbD23E5CDB0 0.1</span><br><span class="line">Mnemonic: viable glow tone pole input series weather slam blouse embark achieve position</span><br><span class="line">Address: 0x6598f11d48Da2bfA897d5Eb3968223f98dabc008</span><br><span class="line">Transferring 0.1 ETH to 0x7B6d22b2130e585f5dacb40dE9Ff9DbD23E5CDB0...</span><br><span class="line">Transaction <span class="built_in">hash</span>: 0x91cb73c1ed608eec56eb6c81319bc232c8a0a7d0023eda87d1631ac45f29f49a</span><br><span class="line">Transaction confirmed <span class="keyword">in</span> block 21121715</span><br></pre></td></tr></table></figure><p>您可以在Etherscan中验证结果。</p><p>我们还要测试验证逻辑是否有效, 以下是一些无效的例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ node src/transferETH.js foo</span><br><span class="line">Address: 0xB3512cF013F71598F359bd5CA3f53C1F4260956a</span><br><span class="line">Invalid address: foo</span><br><span class="line">$ node src/transferETH.js 0xDdAC089Fe56F0a9C70e6a04C74DCE52F86a91e13 0.1.2</span><br><span class="line">Address: 0xB3512cF013F71598F359bd5CA3f53C1F4260956a</span><br><span class="line">Invalid amount: 0.1.2</span><br><span class="line">$ node src/transferETH.js 0xDdAC089Fe56F0a9C70e6a04C74DCE52F86a91e13 -0.1</span><br><span class="line">Address: 0xB3512cF013F71598F359bd5CA3f53C1F4260956a</span><br><span class="line">Invalid amount: -0.1</span><br><span class="line">$ node src/transferETH.js 0xDdAC089Fe56F0a9C70e6a04C74DCE52F86a91e13 100</span><br><span class="line">Address: 0xB3512cF013F71598F359bd5CA3f53C1F4260956a</span><br><span class="line">Insufficient balance to send 100.0 (You have 0.89328474)</span><br></pre></td></tr></table></figure><h3 id="转移USDC"><a href="#转移USDC" class="headerlink" title="转移USDC"></a>转移USDC</h3><p>您将能够复用大部分代码。主要区别在于USDC有6个小数位，并且您必须使用ERC20规格的传递函数来执行交易。您还需要将参数“ to”和“ value”传递给转让智能合约功能，而不是以太坊交易本身。在同一文件夹中创建transferUSDC.js并输入以下内容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ethers = <span class="built_in">require</span>(<span class="string">"ethers"</span>);</span><br><span class="line"><span class="keyword">const</span> wallet = <span class="built_in">require</span>(<span class="string">"./wallet"</span>);</span><br><span class="line"><span class="keyword">const</span> provider = <span class="built_in">require</span>(<span class="string">"./provider"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> account = wallet.connect(provider);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Define balanceOf and transfer functions in the contract</span></span><br><span class="line">  <span class="keyword">const</span> usdc = <span class="keyword">new</span> ethers.Contract(</span><br><span class="line">    <span class="string">"0x4bB2ef39DD99A01BD5C11dDd25F890FeB45081e9"</span>,</span><br><span class="line">    [</span><br><span class="line">      <span class="string">"function balanceOf(address _owner) public view returns (uint256 balance)"</span>,</span><br><span class="line">      <span class="string">"function transfer(address _to, uint256 _value) public returns (bool success)"</span>,</span><br><span class="line">    ],</span><br><span class="line">    account</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> to, value;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Parse the first argument - recipient address</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    to = ethers.utils.getAddress(args[<span class="number">0</span>]);</span><br><span class="line">  &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">`Invalid address: <span class="subst">$&#123;args[<span class="number">0</span>]&#125;</span>`</span>);</span><br><span class="line">    process.exit(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Parse the second argument - amount</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    value = ethers.utils.parseUnits(args[<span class="number">1</span>], <span class="number">6</span>);</span><br><span class="line">    <span class="keyword">if</span> (value.isNegative()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">`Invalid amount: <span class="subst">$&#123;args[<span class="number">1</span>]&#125;</span>`</span>);</span><br><span class="line">    process.exit(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> valueFormatted = ethers.utils.formatUnits(value, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check that the account has sufficient balance</span></span><br><span class="line">  <span class="keyword">const</span> balance = <span class="keyword">await</span> usdc.balanceOf(account.address);</span><br><span class="line">  <span class="keyword">if</span> (balance.lt(value)) &#123;</span><br><span class="line">    <span class="keyword">const</span> balanceFormatted = ethers.utils.formatUnits(balance, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.error(</span><br><span class="line">      <span class="string">`Insufficient balance to send <span class="subst">$&#123;valueFormatted&#125;</span> (You have <span class="subst">$&#123;balanceFormatted&#125;</span>)`</span></span><br><span class="line">    );</span><br><span class="line">    process.exit(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Transferring <span class="subst">$&#123;valueFormatted&#125;</span> USDC to <span class="subst">$&#123;to&#125;</span>...`</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Submit a transaction to call the transfer function</span></span><br><span class="line">  <span class="keyword">const</span> tx = <span class="keyword">await</span> usdc.transfer(to, value, &#123; <span class="attr">gasPrice</span>: <span class="number">20e9</span> &#125;);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Transaction hash: <span class="subst">$&#123;tx.hash&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> receipt = <span class="keyword">await</span> tx.wait();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Transaction confirmed in block <span class="subst">$&#123;receipt.blockNumber&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main(process.argv.slice(<span class="number">2</span>));</span><br></pre></td></tr></table></figure><p>尝试一下向新地址转1个FakeUSDC，它应该也可以正常工作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  solidity-tutorial git:(master) ✗ node src/transferUSDC.js 0x7B6d22b2130e585f5dacb40dE9Ff9DbD23E5CDB0 1</span><br><span class="line">Mnemonic: viable glow tone pole input series weather slam blouse embark achieve position</span><br><span class="line">Address: 0x6598f11d48Da2bfA897d5Eb3968223f98dabc008</span><br><span class="line">Transferring 1.0 USDC to 0x7B6d22b2130e585f5dacb40dE9Ff9DbD23E5CDB0...</span><br><span class="line">Transaction <span class="built_in">hash</span>: 0xb81d2844a086750f5b6e3a71778fc4362cc913cc9960aacdce7028c627e7f49d</span><br><span class="line">Transaction confirmed <span class="keyword">in</span> block 21121797</span><br></pre></td></tr></table></figure><p><strong>恭喜你，完成了！</strong></p><p>最后看看之前的地址还有多少个ETH和USDC</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  solidity-tutorial git:(master) ✗ node src/getFakeUSDCBalance.js                                        </span><br><span class="line">Mnemonic: viable glow tone pole input series weather slam blouse embark achieve position</span><br><span class="line">Address: 0x6598f11d48Da2bfA897d5Eb3968223f98dabc008</span><br><span class="line">ETH Balance: 0.84831602</span><br><span class="line">USDC Balance: 9.0    // 这里的USDC就剩下9个了</span><br></pre></td></tr></table></figure><p>在本教程中，您学习了如何<strong>生成帐户，查询余额，转移代币以及调用智能合约</strong>。您可能以为您对加密还不很了解，但是实际上您已经足够了解能够构建自己的加密钱包应用程序了。我们一直在编写命令行脚本来简化操作，但是如何使用基于Web的漂亮图形界面来完成作业来构建脚本呢？<br>在本教程系列的下一部分中，我们将使用Solidity从零开始编写我们自己的以太坊智能合约，并学习如何构建自己的可与USDC交换的代币。我们还将使用今天学到的技术与该合约进行互动。敬请关注。这个是之前作者的下一篇， 之后大杨会加上如何使用脚本自动化的调用Uniswap进行自动交易。</p><p>如果您对分布式金融DEFI的未来感兴趣，请关注Chaininout链因智能，大杨作为创始人，会努力的科普DEFI技能，促进生态发展。</p><p>作者原文中有CoinBase的免责声明，这里略过，以下也是常规的我们的免责声明。</p><p>以上表达的观点是作者的观点，并不代表Chaininout链因智能的观点和立场。信息仅用于一般教育目的，并不构成对金融产品的投资或其他建议。大杨和Chaininout对本篇内容上任何信息的准确性，完整性，及时性，适用性或有效性不做任何陈述，对于该信息的任何错误，遗漏或延误，或因其造成的任何损失，伤害或损害，概不负责。显示或使用。除非另有说明，否则本文提供的所有图像均为大杨的财产，所有商标均为其各自所有者的财产。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Apr 21 2021 01:32:54 GMT+0900 (Japan Standard Time) --&gt;&lt;p&gt;翻译者： 大杨， 链因智能CEO， 一家初创区块链技术公司，DEFI布道者。&lt;/p&gt;&lt;p&gt;技术点： DEFI，ETH，NODEJS，SOLIDITY&lt;/p&gt;&lt;p&gt;今天抽出了一些时间，翻译了CoinBase的&lt;a href=&quot;https://twitter.com/petejkim&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;em&gt;Pete Kim&lt;/em&gt;&lt;/a&gt; 写的【&lt;a href=&quot;https://blog.coinbase.com/introduction-to-building-on-defi-with-ethereum-and-usdc-part-1-ea952295a6e2&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Introduction to Building on DeFi with Ethereum and USDC — Part 1&lt;/a&gt;】DEFI编程入门学习的文章。&lt;/p&gt;&lt;p&gt;翻了下Pete Kim的twitter和他的github，发现是个全栈高手和社区活跃者，看上去应该是韩国人，技术很不错，人也很帅 😂。&lt;/p&gt;&lt;p&gt;最为美系的第一交易所CoinBase对整个Crypto生态的贡献是巨大的，本篇DEFI编程的入门文章也非常适合新手，看了有很想翻译的冲动，就花了2小时做了下整理，并在kovan的网络上实战了一把，对很多细节的地方做了补充，强烈推荐给大家。 经历DEFI，后续链因智能3年积累的相关技术都会进行开源，通过开源促进技术发展。&lt;/p&gt;
    
    </summary>
    
      <category term="blockchain" scheme="http://yangxinqi.com/categories/blockchain/"/>
    
    
      <category term="DEFI ETH NODEJS SOLIDITY" scheme="http://yangxinqi.com/tags/DEFI-ETH-NODEJS-SOLIDITY/"/>
    
  </entry>
  
  <entry>
    <title>数字金融数据科学系列-Tushare实战</title>
    <link href="http://yangxinqi.com/2020/07/28/%E6%95%B0%E5%AD%97%E9%87%91%E8%9E%8D%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%B3%BB%E5%88%97-Tushare%E5%AE%9E%E6%88%98/"/>
    <id>http://yangxinqi.com/2020/07/28/数字金融数据科学系列-Tushare实战/</id>
    <published>2020-07-28T07:47:23.000Z</published>
    <updated>2020-11-02T03:04:30.423Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Apr 21 2021 01:32:54 GMT+0900 (Japan Standard Time) --><h4 id="数据科学已经走入我们的生活"><a href="#数据科学已经走入我们的生活" class="headerlink" title="数据科学已经走入我们的生活"></a>数据科学已经走入我们的生活</h4><p>近年来AI很热，大部分人看AI的角度，或者说切入点都和实际商业场景有很大的落差，走的是存粹的优化，做的很研究，有时候模型很准，但是难以付之行动，比如金融模型常常是快速的杀进快速杀出，倒跌手续费还赔上时间。</p><p>大部分时候，做模型的成本太高，解决一个实际问题，需要不少预算来购买云端服务器，GPU资源来做大量运算，但是回归商业社会，不是实验室，不能重来，一切都得小心翼翼的向前，后退就意味着接受沉没成本，可能也因此给公司造成巨额损失。</p><p>经历过几个项目，也和不少同事一起共事，往往不是模型问题，大部分是数据问题，数据的获取和清洗，已经训练集的准备和调优基本上占去了70%的时间，模型选型基本不是重点。</p><p>所以说回来，还是先从数据科学的角度，来切入，底层基础搭好了，上层的模型才能稳固。</p><p>所以我认为，数据科学的本质： 就是认清现在能够拿到多少资源，想产出多大效益。</p><p>让我们一起来认识下数字金融模型下的数据科学的实际应用，本期给大家介绍Tushare数据组件。</p><p><img src="/images/tushare0.png?style=centerme" alt="Tushare"></p><a id="more"></a><h4 id="什么是Tushare"><a href="#什么是Tushare" class="headerlink" title="什么是Tushare"></a>什么是Tushare</h4><p>Tushare金融大数据开放社区，免费提供各类金融数据和区块链数据，助力智能投资和创新型投资。</p><p>平台特点：<br>数据丰富： 拥有丰富的数据维度，股票，基金，期货，数字货币等行情数据，公司财务数据，基金经历等基本面数据。</p><p>获取简单： SDK开发包支持语言，同时提供http restful接口，最大成都方便不同人群使用。</p><p>落地方便： 提供多种数据存储方式，如Mysql,MongoDB, HDF5,CSV等，为数据获取提供了性能保证。</p><p>Tushare自2014年12月起，经历了6年的发展，逐渐形成了自己的社区，与国内知名金融数据服务商，优矿，米筐，聚宽等量化平台合作，作者曾就职于通联数据，并和上海交大等高校建立合作，作为金融大数据的开源服务提供商，是一个很不错的选择。</p><h4 id="Tushare代码review"><a href="#Tushare代码review" class="headerlink" title="Tushare代码review"></a>Tushare代码review</h4><p>TuShare的github上的开源代码有段时间没有更新了。本次直接review安装后的lib代码，最新版本1.2.60。</p><p>github地址： <a href="https://github.com/waditu/tushare" target="_blank" rel="noopener">https://github.com/waditu/tushare</a></p><p>最核心的代码是 tushare/pro 目录下的 data_pro 以及 client 。 一个作为api调用的入口类，client作为api交互的client用来和服务器端收发数据用。</p><p><img src="/images/tushare1.png?style=centerme" alt="Tushare data_pro"></p><p>核心代码通过requests.post 拼接post params 的方式，发送请求，返回的结果用json的方式，解析并拼接成pandas Dataframe对象，返回给上层。</p><p><img src="/images/tushare2.png?style=centerme" alt="Tushare client"></p><p>其他的主要是util的一些辅助类，formula.py中有一些常见的指标方法，推荐可以使用。</p><p><img src="/images/tushare3.png?style=centerme" alt="Tushare formula"></p><h4 id="Tushare的数字金融数据介绍"><a href="#Tushare的数字金融数据介绍" class="headerlink" title="Tushare的数字金融数据介绍"></a>Tushare的数字金融数据介绍</h4><p>tushare的数字金融数据模块，包含基础数据，行情数据，资讯数据：<br>基础数据：<br>全球数字货币列表， 全球数字货币交易所，交易所交易对，以及项目和交易所LOGO， 很多交易所也停止维护了。</p><p>行情数据：<br>数字货币行情， 每日市值，交易所费率，比特币每日市值，比特币每日交易量，数字货币K线</p><p>资讯公告：<br>包含了，金色财经，巴比特，比世界，交易所公告，twitter数据， twitter大V数据等。</p><p>很不幸的是，大部分已经停止更新了。 最新的数据更新到6月10号，联系了维护的米哥，这块业务有个人维护，服务器费用的原因，已经暂停了部分数据的更新，缺钱来为开源的项目做贡献。 国内的开源项目，大杨也捐赠过几个，花了几千块rmb，在国内没有这样的捐助的氛围，很多开源项目很难维持下去。</p><h4 id="如何玩转TuShare"><a href="#如何玩转TuShare" class="headerlink" title="如何玩转TuShare"></a>如何玩转TuShare</h4><p>开箱即用：<br>使用pip来安装tushare:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install tushare</span><br></pre></td></tr></table></figure><p>安装好之后，开始些个测试来获取数据：<br>如果注册好了，在官方网站，申请了token了之后，就可以用token来访问api获取数据了：<br>这里申明那个交易所的那个时间段，哪个币种的数据，并将获取的数据打印出来。 最后保存成CSV文件。</p><pre><code>def test_coindayohlcv(self):    token = &apos;b3a30846b80**************:89db61bf236&apos;       pro = ts.pro_api(token)    ex = &apos;huobi&apos;    &quot;&quot;&quot;    1min    1分钟    5min    5分钟    15min    15分钟    30min    30分钟    60min    60分钟    daily    日线    week    周线    &quot;&quot;&quot;    df = pro.coinbar(exchange=ex, symbol=&apos;btcusdt&apos;, freq=&apos;daily&apos;, start_date=&apos;20200301&apos;, end_date=&apos;20200728&apos;)    print(df.columns)    print(df)    df.to_csv(&apos;{}.csv&apos;.format(ex), index=False)</code></pre><p><img src="/images/tushare4.png?style=centerme" alt="Tushare fetchohlcv"></p><h4 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h4><p>最后，测试了下指数数据，美股数据，期货数据，外汇数据，还有港股数据，作为学习来使用，还是挺适合的，但是作为生产环境的数据源头的话，还是推荐购买，米筐，聚宽等专业的数据服务商提供的稳定的数据源,当然每年的费用6-8万也是企业才能够承受的了的，个人还是相对困难。<br>数据的完整性还是没法保证，毕竟只有米哥一个人维护，而且通过大家捐助的方式，来收取一定的费用，来维持服务器，还有抓取程序。</p><p>作为开源的一份子，tushare还是做的不错的，坚持6年也相当的不容易，数据商业化，在中国还是相当难的。 大家多给一些鼓励，如果有用，并且学到东西，可以捐助下，捐助地址： <a href="https://waditu.com/document/1?doc_id=243。" target="_blank" rel="noopener">https://waditu.com/document/1?doc_id=243。</a></p><p>为开源点赞吧。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Apr 21 2021 01:32:54 GMT+0900 (Japan Standard Time) --&gt;&lt;h4 id=&quot;数据科学已经走入我们的生活&quot;&gt;&lt;a href=&quot;#数据科学已经走入我们的生活&quot; class=&quot;headerlink&quot; title=&quot;数据科学已经走入我们的生活&quot;&gt;&lt;/a&gt;数据科学已经走入我们的生活&lt;/h4&gt;&lt;p&gt;近年来AI很热，大部分人看AI的角度，或者说切入点都和实际商业场景有很大的落差，走的是存粹的优化，做的很研究，有时候模型很准，但是难以付之行动，比如金融模型常常是快速的杀进快速杀出，倒跌手续费还赔上时间。&lt;/p&gt;&lt;p&gt;大部分时候，做模型的成本太高，解决一个实际问题，需要不少预算来购买云端服务器，GPU资源来做大量运算，但是回归商业社会，不是实验室，不能重来，一切都得小心翼翼的向前，后退就意味着接受沉没成本，可能也因此给公司造成巨额损失。&lt;/p&gt;&lt;p&gt;经历过几个项目，也和不少同事一起共事，往往不是模型问题，大部分是数据问题，数据的获取和清洗，已经训练集的准备和调优基本上占去了70%的时间，模型选型基本不是重点。&lt;/p&gt;&lt;p&gt;所以说回来，还是先从数据科学的角度，来切入，底层基础搭好了，上层的模型才能稳固。&lt;/p&gt;&lt;p&gt;所以我认为，数据科学的本质： 就是认清现在能够拿到多少资源，想产出多大效益。&lt;/p&gt;&lt;p&gt;让我们一起来认识下数字金融模型下的数据科学的实际应用，本期给大家介绍Tushare数据组件。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/images/tushare0.png?style=centerme&quot; alt=&quot;Tushare&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="finance" scheme="http://yangxinqi.com/categories/finance/"/>
    
    
      <category term="数据科学 数字货币" scheme="http://yangxinqi.com/tags/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-%E6%95%B0%E5%AD%97%E8%B4%A7%E5%B8%81/"/>
    
  </entry>
  
  <entry>
    <title>进入数字金融行业</title>
    <link href="http://yangxinqi.com/2020/06/22/%E8%BF%9B%E5%85%A5%E6%95%B0%E5%AD%97%E9%87%91%E8%9E%8D%E8%A1%8C%E4%B8%9A/"/>
    <id>http://yangxinqi.com/2020/06/22/进入数字金融行业/</id>
    <published>2020-06-22T04:54:59.000Z</published>
    <updated>2020-06-22T05:02:31.725Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Apr 21 2021 01:32:54 GMT+0900 (Japan Standard Time) --><p>迷茫的时候，不知道自己的未来是如何的，做下人生规划，开始找份工作，从IT行业，进入数字金融行业。</p><p>以”Quantamental”为主线，开始努力学习，重新规划自己的人生。 需要补的英语，还有编程能力，还有AI能力。</p><p>36岁，从新开始自己的人生。 对于编程，是热爱的，数字金融可以改变生活的状态，做自己喜欢而且能够改变生活条件的事情，是很值得的，5年规划，希望5年之后，自己不会后悔自己做的选择。 因为后悔也没用，自己选的路，在这么艰难都要走下去。</p><p><img src="/images/quantamental.jpg?style=centerme" alt="数字金融Quantamental!"></p><h3 id="数字金融我来啦！"><a href="#数字金融我来啦！" class="headerlink" title="数字金融我来啦！"></a>数字金融我来啦！</h3><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Apr 21 2021 01:32:54 GMT+0900 (Japan Standard Time) --&gt;&lt;p&gt;迷茫的时候，不知道自己的未来是如何的，做下人生规划，开始找份工作，从IT行业，进入数字金融行业。&lt;/p&gt;&lt;p&gt;以”Quant
      
    
    </summary>
    
      <category term="finance" scheme="http://yangxinqi.com/categories/finance/"/>
    
    
      <category term="数字金融" scheme="http://yangxinqi.com/tags/%E6%95%B0%E5%AD%97%E9%87%91%E8%9E%8D/"/>
    
  </entry>
  
  <entry>
    <title>直面失败消除焦虑设计人生</title>
    <link href="http://yangxinqi.com/2020/06/22/%E7%9B%B4%E9%9D%A2%E5%A4%B1%E8%B4%A5%E6%B6%88%E9%99%A4%E7%84%A6%E8%99%91%E8%AE%BE%E8%AE%A1%E4%BA%BA%E7%94%9F/"/>
    <id>http://yangxinqi.com/2020/06/22/直面失败消除焦虑设计人生/</id>
    <published>2020-06-22T02:28:21.000Z</published>
    <updated>2020-06-22T04:52:43.567Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Apr 21 2021 01:32:54 GMT+0900 (Japan Standard Time) --><p>今天早晨，翻看朋友圈，看到lynne发到一篇读书笔记《斯坦福大学人生设计课》，看了下分析的读书笔记发现是一本蛮有见解的书，从另外的角度，来缓解焦虑，同时用简明扼要的大纲，来一步一步说明，如何克服迷茫，设计自己人生的重要性，而且给出了实际做法， 引起的读它的兴趣。</p><h3 id="读书是缓解的焦虑的好办法"><a href="#读书是缓解的焦虑的好办法" class="headerlink" title="读书是缓解的焦虑的好办法"></a>读书是缓解的焦虑的好办法</h3><p>最近疫情影响，还有创业的行业赛代也都经历的变化，思想和心态都跌入了低谷，也背上了很大的债务， 人也变得迷茫了，尝试了做新的领域，尝试了积极主动，但是内心深处，依旧是那么的迷茫。</p><p>跨过内心的徘徊，直面市场。失败没有大不了的，都是人生的一个阶段而已。</p><p><img src="/images/shejirensheng.jpg?style=centerme" alt="失败免疫!"></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Apr 21 2021 01:32:54 GMT+0900 (Japan Standard Time) --&gt;&lt;p&gt;今天早晨，翻看朋友圈，看到lynne发到一篇读书笔记《斯坦福大学人生设计课》，看了下分析的读书笔记发现是一本蛮有见解的书，从
      
    
    </summary>
    
      <category term="other" scheme="http://yangxinqi.com/categories/other/"/>
    
    
      <category term="人生" scheme="http://yangxinqi.com/tags/%E4%BA%BA%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>整理下简历</title>
    <link href="http://yangxinqi.com/2020/05/27/%E6%95%B4%E7%90%86%E4%B8%8B%E7%AE%80%E5%8E%86/"/>
    <id>http://yangxinqi.com/2020/05/27/整理下简历/</id>
    <published>2020-05-26T18:45:47.000Z</published>
    <updated>2020-05-26T19:04:57.473Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Apr 21 2021 01:32:54 GMT+0900 (Japan Standard Time) --><h3 id="简历"><a href="#简历" class="headerlink" title="简历"></a>简历</h3><p>停下来，整理下简历，继续前行，用jekyll生成了个新的，这10年来，做了不少项目，有4个开源的，接下来把项目中用到的开源出来。</p><p>体现出自己的价值，从整理简历开始，阳光的面对接下来的路。 让家里人过的幸福是最终的。</p><p><a href="/resume/">xinqiyang’s resume</a></p><p>重新进入职场，躲过危机，关注，数据，流量和交易。 让交易飞起来，才有可能实现理想。</p><p>github pages 会自动执行构建，出错就不更新了。</p><p>好吧，好久没更新了。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Apr 21 2021 01:32:54 GMT+0900 (Japan Standard Time) --&gt;&lt;h3 id=&quot;简历&quot;&gt;&lt;a href=&quot;#简历&quot; class=&quot;headerlink&quot; title=&quot;简历&quot;&gt;&lt;/a&gt;简历&lt;/h
      
    
    </summary>
    
      <category term="other" scheme="http://yangxinqi.com/categories/other/"/>
    
    
      <category term="简历" scheme="http://yangxinqi.com/tags/%E7%AE%80%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>2019年终总结</title>
    <link href="http://yangxinqi.com/2020/01/04/2019%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <id>http://yangxinqi.com/2020/01/04/2019年终总结/</id>
    <published>2020-01-03T18:14:43.000Z</published>
    <updated>2020-01-03T18:21:04.586Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Apr 21 2021 01:32:54 GMT+0900 (Japan Standard Time) --><h3 id="2019年，年终总结"><a href="#2019年，年终总结" class="headerlink" title="2019年，年终总结"></a>2019年，年终总结</h3><p>痛并快乐着的创业历程，战到最后，孤身一人，战至一兵一卒。</p><p>最后：</p><h1 id="卒"><a href="#卒" class="headerlink" title="卒"></a>卒</h1><p><img src="/images/20192020.png?style=centerme" alt="come back!"></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Apr 21 2021 01:32:54 GMT+0900 (Japan Standard Time) --&gt;&lt;h3 id=&quot;2019年，年终总结&quot;&gt;&lt;a href=&quot;#2019年，年终总结&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="other" scheme="http://yangxinqi.com/categories/other/"/>
    
    
      <category term="创业" scheme="http://yangxinqi.com/tags/%E5%88%9B%E4%B8%9A/"/>
    
  </entry>
  
  <entry>
    <title>低风险创业阅读笔记</title>
    <link href="http://yangxinqi.com/2019/10/25/%E4%BD%8E%E9%A3%8E%E9%99%A9%E5%88%9B%E4%B8%9A%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <id>http://yangxinqi.com/2019/10/25/低风险创业阅读笔记/</id>
    <published>2019-10-25T05:52:06.000Z</published>
    <updated>2019-10-28T16:14:05.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Apr 21 2021 01:32:54 GMT+0900 (Japan Standard Time) --><h3 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h3><p>经典名言： 千万不要卖房创业！ 千万不要卖房创业！ 千万不要卖房创业！</p><p>实践名言： 创业可能亏掉一套房！创业可能亏掉一套房！创业可能亏掉一套房！</p><p><img src="/images/chuxin.png?style=centerme" alt="img"></p><h3 id="读书笔记"><a href="#读书笔记" class="headerlink" title="读书笔记"></a>读书笔记</h3><h4 id="创业的初衷，你到底是为了什么？"><a href="#创业的初衷，你到底是为了什么？" class="headerlink" title="创业的初衷，你到底是为了什么？"></a>创业的初衷，你到底是为了什么？</h4><p>做企业最重要的是现金流，而不是净资产。</p><p>从最本质的肾上腺素粉笔，到感受到爱，善意拥抱世界，拥抱创业的过程。</p><p>出发点和初衷，带着爱与希望，而不是为了金钱，往往初衷不对会欲速不达，对于下属严苛，失去很多。</p><p>性格好的人，结果不会坏到哪里去。</p><a id="more"></a><h4 id="创业实践中"><a href="#创业实践中" class="headerlink" title="创业实践中"></a>创业实践中</h4><p>优雅的解决一个社会问题，才能影响寻常百姓的日常生活。</p><p>正确的时间，正确的姿势解决一个社会问题，是对的事情，也要天时，地利，人和。</p><p>创业一个是一件令人愉悦的事情， 花时间工作，然后剩下的时间陪孩子和家人。 最完美的创业模式，打造个人IP，同时还能够获得收入，这个过程是互利互惠的。</p><p>克服心理问题，把创业视为人生的修炼。</p><p>从用户抱怨的中，发现低风险创业的机会， 身边的人如何抱怨的，找到真正的需求点，然后着手解决。</p><p>做乙方的生意模式非常危险（外包，咨询），当你江郎才尽的那天，就是公司倒闭的日子。</p><p><strong>痛点： 挖掘小数据满足用户需求</strong></p><p>产品就是小数据加上一个好的用户体验的呈现， 大部分只是改变产品包装，而不是改变产品。</p><p>洞察的力量，进入实际场景，观察用户同时能够给出解决方案。</p><p>忘掉你的创始人身份，开始体验产品，作为第三个灵感来源。 <strong>亲自试用自己的产品，像小白一样体验产品</strong>。把产品做简单。</p><p>找到宏大的变革目标MTP， 找到目标市场足够大，存在问题，存在变革，解决的空间。</p><p><strong>我的MTP是什么？</strong> 需要详细的描述出来。</p><p>在客户最痛的点上突破，痛点到产品的一见钟情。</p><p>识别真痛点和假痛点，客户真的有购买动机，能够在客户口渴的时候递出水，递给他的是半瓶救命水。</p><p>没有秘密是创业者最大的风险，核心竞争力在哪里？</p><p>铁杆粉丝，1000个铁杆，拉起你的产品，用户是创业者的衣食父母，也是你的力量之源。</p><p>超越竞争的“10倍好”原则，如何才能拥有10倍的增长。</p><p>秘密是一个慢慢积累的过程，积累一批核心用户，有了口碑。</p><p>时间是最需要的东西，市场不会等待你和你的企业壮大，你只能自己真去时间，孕育出秘密之花。</p><p>一切没有找对秘密的创业都是谋财害命。 谋投资人，创始人的才，害员工的命。</p><p><strong>验证商业秘密最好的方法是卖而不是问。</strong></p><p>能够让客户带来客户的销售效果，才能让产品的销售持续增长。</p><p>足够价值的服务是会尖叫的。</p><p>打造最小化可行性的产品，幸苦做出来的产品没有人用，悲剧了。 得不到客户认可，才是创业公司最不该犯的错误。</p><p>好的用户体验，最小化，可行性。 少成本，又好用。</p><p>融资需有度，钱不是越多越好。 在发现商业秘密的过程中，一定要把现金流放在最重要的位置。</p><p>正向现金流，不靠融资续命。有不断流进来的现金，让自己的公司尽可能处于盈利状态。</p><p>反脆弱的结构设计，人和创业秘密，商业节奏和团队管理手段，离开特定环境和北京，都难以复制。</p><p>所谓反脆弱，其实就是如何应对黑天鹅时间，从随时可能发生的 不确定性中受益。</p><p><strong>人类总是过度相信经验，而不知道黑天鹅事件出现一次就足以颠覆一切。 而意外的必然性，一定会发生。</strong></p><p>黑天鹅事件，带有巨大的冲击性，会产生极端后果。发生后，可解释可预测。</p><p>创业的脆弱性越强，风险也越来越大。</p><p>具备反脆弱的能力，不等于坚强不屈，在必然出现的不确定风险发生时保全自我，还能让其变得更好，更有力量。</p><p>合作让双方都具备反脆弱能力，在不确定中，找到生存点和发展点。</p><p><strong>设计反脆弱的商业结构，成本有底线，收益无上限。</strong></p><p>找到问题，设计一套反脆弱的模型，IP生意，需要看到本质。</p><p>找到“非对称交易”的机会， 这个世界是曲线的。 损失和收益并不完全对应。</p><p>创业者可以不断试错，不断调整，以期实现收益最大化和风险最小化。</p><p>固定资产不产生任何收益，靠亏损维持不是长久之计。</p><p>创业需要情怀，员工有匠人精神。 情怀，热爱，真诚，专注。</p><p><strong>创业最痛苦的事，莫过于只把事业当作谋生的工具。</strong></p><p>没有经历过痛苦，不懂得欢乐。情怀的价值所在，人要经历痛苦才明白。</p><p>配置你的“创业杠铃”， 好的企业家不是善于冒风险，而是善于控制风险。</p><p>你在一个领域安全，另外一个领域才能创新。</p><p>修炼“君子不器”。让你成为全方位，多向度的人。不能够一条路走到黑，要有选择权。</p><p>只要我们能够在内容层面不断精进突破，就不担心某一天会遭遇不确定性。</p><p>通过思维方式的转变，扩大自己的生意的选择空间，让自己的风险发生时，有可以选择杠铃的另一端。</p><p>大前提保证自己的安全，成功最好，不成功也不会伤经动骨。</p><p>能力陷阱和资源陷阱，先看自己的能力和资源做什么，而不是设计一套反脆弱的商业结构。</p><p>赋能生物态团队，创业是孤独而寒冷的路，会渐渐失去热情而难以持久，容易迷失。需要“群智涌现，彼此协同”</p><p>创业团队是复杂体系，不能机械化管理，需要打造应对不确定性的敏捷团队。 需要为社会做贡献，不断成长。 要善待一起的兄弟，也不能过于安稳。</p><p>重新定义成功，成功的思维模式，倡导终生成长。 能够守住底线，让员工犯错误，能够一起承担错误。</p><p>建员工迟早会离开团队，离开才是最大的不稳定。</p><p>有些创业者格局不够大，从气量就可以看出来。</p><p>创业过程中，核心员工，兼职的千万不能要，三心二意的坚决清理。</p><h4 id="突产品"><a href="#突产品" class="headerlink" title="突产品"></a>突产品</h4><p>十万人说不错，不如一百人尖叫。 优质的产品，偏向于营销推广。</p><p>客户只会给你一次机会，学会珍惜自己的品牌。</p><p>不着急打广告和买流量。</p><p>产品重要，用户才会分享。</p><p>让客户为你带来新的客户。</p><p>让用户主动分享，专业化，简单化，情绪化，可视化，故事化。</p><p>广告是必须做的，广告要持续，定下来不能经常变。</p><p>唤醒大众情绪，才能被大量传播。</p><p>用故事打败只是的诅咒， 将一个好的故事，好想法和好故事，好IP才行。</p><p>学会用幂次法则思考，线性思想被幂次法则取代。 头部公司带来偏好链接，形成马太效应。 想法流，实现指数型增长。</p><h4 id="突运营"><a href="#突运营" class="headerlink" title="突运营"></a>突运营</h4><p>让边际成本为零的运营方法，增加一个用户所需要支付的成本，决定创业是否成功的关键。</p><p>内容和程序，生产的成本是一样的， 可以卖的人越来越多。</p><p><strong>只运营信息，</strong>杜绝将大部分精力用于维护用户和商家的平台系统，边际成本自然能够大幅降低。</p><p>学会撬动资源刚刚，用梦想感召他人，MTP，宏大的变革目标，用你的梦想去感召更多的人，一起实践这个梦想。</p><p>对于团队培养2个接班人。</p><p>找到指数型增长的关键节点，列出工作流，要点，注意事项。 清单管理时间，找出关键点。</p><p>手里有收入更好的更从容的解决问题，提高用户体验，找代理商。 在全球范围内找最合适的代理商。</p><p><strong>二周一个关键点，找到方向有实际结果。</strong></p><h4 id="保增长"><a href="#保增长" class="headerlink" title="保增长"></a>保增长</h4><p>搭建跨部门的增长小组，增长这件事人不能多。</p><p><strong>只有增长，最重要</strong></p><p>只有增长才能创造奇迹</p><p>下2周多目标，看这周的实际数据</p><p>企业的下一个增长方向应该取决于数据，它决定了你该做什么事，不该做什么事。</p><p>让增长小组进行实验，监控，反馈。 6个角色，增长负责人，产品经理，工程师，营销专员，数据分析师和设计师。 获得支持，多实验，高效沟通。</p><p>天下武功，唯快不破。</p><p>唯一限制我们的是我们的想象力。</p><h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>做最好的自己，终生成长，创业也许是一个过程，也是会持续一生，但是 勿忘初心，用爱前行。 我错了，我改正。 樊登读书真心很不错，强烈推荐下。 微信读书，每天的时间应该都给他。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Apr 21 2021 01:32:54 GMT+0900 (Japan Standard Time) --&gt;&lt;h3 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h3&gt;&lt;p&gt;经典名言： 千万不要卖房创业！ 千万不要卖房创业！ 千万不要卖房创业！&lt;/p&gt;&lt;p&gt;实践名言： 创业可能亏掉一套房！创业可能亏掉一套房！创业可能亏掉一套房！&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/images/chuxin.png?style=centerme&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;&lt;h3 id=&quot;读书笔记&quot;&gt;&lt;a href=&quot;#读书笔记&quot; class=&quot;headerlink&quot; title=&quot;读书笔记&quot;&gt;&lt;/a&gt;读书笔记&lt;/h3&gt;&lt;h4 id=&quot;创业的初衷，你到底是为了什么？&quot;&gt;&lt;a href=&quot;#创业的初衷，你到底是为了什么？&quot; class=&quot;headerlink&quot; title=&quot;创业的初衷，你到底是为了什么？&quot;&gt;&lt;/a&gt;创业的初衷，你到底是为了什么？&lt;/h4&gt;&lt;p&gt;做企业最重要的是现金流，而不是净资产。&lt;/p&gt;&lt;p&gt;从最本质的肾上腺素粉笔，到感受到爱，善意拥抱世界，拥抱创业的过程。&lt;/p&gt;&lt;p&gt;出发点和初衷，带着爱与希望，而不是为了金钱，往往初衷不对会欲速不达，对于下属严苛，失去很多。&lt;/p&gt;&lt;p&gt;性格好的人，结果不会坏到哪里去。&lt;/p&gt;
    
    </summary>
    
      <category term="other" scheme="http://yangxinqi.com/categories/other/"/>
    
    
      <category term="创业" scheme="http://yangxinqi.com/tags/%E5%88%9B%E4%B8%9A/"/>
    
  </entry>
  
  <entry>
    <title>践行时间管理</title>
    <link href="http://yangxinqi.com/2019/10/21/%E8%B7%B5%E8%A1%8C%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/"/>
    <id>http://yangxinqi.com/2019/10/21/践行时间管理/</id>
    <published>2019-10-21T02:28:55.000Z</published>
    <updated>2019-10-28T16:13:52.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Apr 21 2021 01:32:54 GMT+0900 (Japan Standard Time) --><h3 id="回归"><a href="#回归" class="headerlink" title="回归"></a>回归</h3><p>经历了近2年的全力创业历程，发现自己欠缺的太多太多。从本质上来讲，是自己的心态以及具体的执行层面，很多事情的抉择很容易受到心态的干扰。 做事情欠缺全盘考虑。</p><p>回到内心初衷， 进行深刻的反省。</p><p>先从时间管理开始，忙是一种状态，一直忙碌好几年，遵循着不好的时间分配原则，导致效率低下，还有花在某个点上的时间太多，导致面上整理出现不协调。 买了微信读书的会员，不知不觉，以及收藏了近300本书，认真的看着这些书，为自己充充电，才能继续前行。</p><p>​ <img src="/images/self_up.jpg?style=centerme" alt="img"></p><a id="more"></a><h3 id="时间管理和生活态度"><a href="#时间管理和生活态度" class="headerlink" title="时间管理和生活态度"></a>时间管理和生活态度</h3><p>好的经验别人告诉你，但是你自己不实践，没有意义。</p><p>时间对于每个人是一样的， 其多少是效率问题，更关乎自己的生活态度。</p><h3 id="一些不好的例子"><a href="#一些不好的例子" class="headerlink" title="一些不好的例子"></a>一些不好的例子</h3><p>残酷错误： 不整理。</p><p>解决方法： 整理东西，尽量少买，丢掉不需要的。 各种购物软件，淘宝，京东，尽量少打开，还有小红书。</p><p>残酷错误：拖来拖去，事情都在那里，只多不少</p><p>解决方法： 拖延因为没有开始，开始起来就好了。 行动吧。 马上行动，马上行动，马上行动。</p><p>残酷错误： 承若的大事情，不能善始善终</p><p>解决方法： 大事情分解成小事情，身体力行。 行动行动，先把小事情做好。</p><p>残酷错误： 决策遇上选择恐惧症</p><p>解决方法： 每天晚上列出明天应该必须做的5件最重要的事情。</p><p>残酷错误： 很多待办TODO列表</p><p>解决方法： 把待办变成必办，其他的事情就会迎刃而解。</p><p>残酷错误： 各种干扰以及时间顺序不当</p><p>解决方法： 有些事情说不，整理生活碎片，想干扰说不， 不给干扰开口的机会。</p><p>残酷错误： 忙得焦头烂额，嘴上还在说好好好</p><p>解决方法： 不经常说不，问题很严重， 不管是谁的拜托，应该权衡之后在去做。</p><p>残酷错误： 网络世界里经常欲罢不能</p><p>解决方法： 离开位置，离开电脑，说不，网络上的事情，尽量少打开各类必须软件。 特别是 微信，微博，twitter之类的，以及各种的视频软件。 整理自己的电脑及手机，把消耗自己时间的APP全部干掉，电脑上的不用的统统卸载。</p><p>残酷错误： 做了很多低于自己时间估值的事情</p><p>解决方法： 事情可不可以分出去给其他人做，低于自己时间价值的事情，坚决不做。</p><p>残酷错误： 开会花太多的时间</p><p>解决方法： 小会5分钟， 大会30-45分钟，切记不要超过45分钟。</p><p>残酷错误： 大部分时间在工作上，在客户那边</p><p>解决方法： 留时间给自己以及家人，这个世界安排第一优先，这样你才能做的更好。</p><p>残酷错误： 没有陪孩子，教育的时间太少</p><p>解决方法： 和家人和孩子一起用早餐和晚餐，具体询问一些具体的事情，学校还有朋友啊，相互问候，陪孩子玩游戏，单独带他们出去玩， 给他们分配清单培养他们独立购买的能力。 星期天一家人聚在床上说话，增加家庭温馨感。</p><p>残酷错误： 好久没有一家人旅行了</p><p>解决方法： 规划一个假期，提前规划好，不要因为公事而影响一家人的出游放松。 提早计划。</p><p>残酷错误： 没有在理财上花时间</p><p>解决方法： 定期一个月，一个季度，半年，一年，对家庭财务进行整理，列出花费，到年末了需要进行年末调整了。</p><p>残酷错误： 没有花时间在锻炼身体上</p><p>解决方法： 看着自己的大肚子，每天锻炼坚持10分钟，比如平板撑，还有做收肚子的5组运动，先锻炼起来，去掉大肚子。</p><p>残酷错误： 没有给自己留时间</p><p>解决方法： 自我日，关键日，事物日要分清，这样才能规划好，自我日最优先，先把自己的时间安排好，才能够做好关键和事物安排。 聚集5种最大收益的活动，每天必须完成5种活动。</p><p>残酷错误： 思想没有升级</p><p>解决方案： 对自己的细节，行为，举止，外观气质等没有很好的关注。 需要做到 少即是多， 倾听少说，不要乱买了， 特别是那些便宜的所谓性价比高的东西，必须买顶配，而且尽量少买。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>需要多花时间，看书，总结，践行自己的修改，类似程序写了后的review和打patch是一样的。 人需要打补丁，需要不断的循序渐进的优化自己的行为，提高自己的气质的，最基本的是做好自己的时间安排，将大部分的时间花在自己有益的事情上面。 对自己好了，只有自己好了，才能够带动其他人，好起来。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Apr 21 2021 01:32:54 GMT+0900 (Japan Standard Time) --&gt;&lt;h3 id=&quot;回归&quot;&gt;&lt;a href=&quot;#回归&quot; class=&quot;headerlink&quot; title=&quot;回归&quot;&gt;&lt;/a&gt;回归&lt;/h3&gt;&lt;p&gt;经历了近2年的全力创业历程，发现自己欠缺的太多太多。从本质上来讲，是自己的心态以及具体的执行层面，很多事情的抉择很容易受到心态的干扰。 做事情欠缺全盘考虑。&lt;/p&gt;&lt;p&gt;回到内心初衷， 进行深刻的反省。&lt;/p&gt;&lt;p&gt;先从时间管理开始，忙是一种状态，一直忙碌好几年，遵循着不好的时间分配原则，导致效率低下，还有花在某个点上的时间太多，导致面上整理出现不协调。 买了微信读书的会员，不知不觉，以及收藏了近300本书，认真的看着这些书，为自己充充电，才能继续前行。&lt;/p&gt;&lt;p&gt;​ &lt;img src=&quot;/images/self_up.jpg?style=centerme&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="other" scheme="http://yangxinqi.com/categories/other/"/>
    
    
      <category term="other" scheme="http://yangxinqi.com/tags/other/"/>
    
  </entry>
  
  <entry>
    <title>一年的产出</title>
    <link href="http://yangxinqi.com/2019/08/02/%E4%B8%80%E5%B9%B4%E7%9A%84%E4%BA%A7%E5%87%BA/"/>
    <id>http://yangxinqi.com/2019/08/02/一年的产出/</id>
    <published>2019-08-02T06:51:49.000Z</published>
    <updated>2019-10-28T16:13:30.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Apr 21 2021 01:32:54 GMT+0900 (Japan Standard Time) --><p>​ <img src="/images/projects.png?style=centerme" alt="img"></p><h3 id="一年积累下来"><a href="#一年积累下来" class="headerlink" title="一年积累下来"></a>一年积累下来</h3><p>23个项目，一年下来，忙活代码行数，超过10w+。 涵盖了数据库， app的， 后端模块， 发布模块，以及前端，还有网站，部署等等。</p><p>使用了包含java,python,php,js,sh,go, sodility 共计7种语言。</p><p>产品产品发布后，提供给用户使用，接下来做好定价后，开始买卖吧。</p><p>产品需要市场的体验，才行的。</p><p>在国内有各种卖法，如何让用户能够更容易的找到我们，还是很关键的。</p><a id="more"></a><h3 id="拥抱开源"><a href="#拥抱开源" class="headerlink" title="拥抱开源"></a>拥抱开源</h3><p>接下来，还是做一个开源的项目，让大家可以用的很happy，让大家能够放心，这样的话。</p><p>接下来我们的项目 <a href="https://github.com/coinphd" target="_blank" rel="noopener">https://github.com/coinphd</a> 项目都在这里，欢迎大家参观。</p><h3 id="拥抱区块链"><a href="#拥抱区块链" class="headerlink" title="拥抱区块链"></a>拥抱区块链</h3><p>拥抱区块链，在区块链上，做自己的应用，服务市场，服务客户。这个才是我们应该做的，这样的话，成本可以减少下来，但是我们的产品，能够得到大家的认同，这样才能够活下来，走出去。</p><h3 id="技术成就梦想"><a href="#技术成就梦想" class="headerlink" title="技术成就梦想"></a>技术成就梦想</h3><p>开发和运营集合起来，ansible很好用，docker也很好用，用技术实现梦想，才是最近这个阶段应该做的事情的。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Apr 21 2021 01:32:54 GMT+0900 (Japan Standard Time) --&gt;&lt;p&gt;​ &lt;img src=&quot;/images/projects.png?style=centerme&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;&lt;h3 id=&quot;一年积累下来&quot;&gt;&lt;a href=&quot;#一年积累下来&quot; class=&quot;headerlink&quot; title=&quot;一年积累下来&quot;&gt;&lt;/a&gt;一年积累下来&lt;/h3&gt;&lt;p&gt;23个项目，一年下来，忙活代码行数，超过10w+。 涵盖了数据库， app的， 后端模块， 发布模块，以及前端，还有网站，部署等等。&lt;/p&gt;&lt;p&gt;使用了包含java,python,php,js,sh,go, sodility 共计7种语言。&lt;/p&gt;&lt;p&gt;产品产品发布后，提供给用户使用，接下来做好定价后，开始买卖吧。&lt;/p&gt;&lt;p&gt;产品需要市场的体验，才行的。&lt;/p&gt;&lt;p&gt;在国内有各种卖法，如何让用户能够更容易的找到我们，还是很关键的。&lt;/p&gt;
    
    </summary>
    
      <category term="devops" scheme="http://yangxinqi.com/categories/devops/"/>
    
    
      <category term="devops" scheme="http://yangxinqi.com/tags/devops/"/>
    
  </entry>
  
</feed>
