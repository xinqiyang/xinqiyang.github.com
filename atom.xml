<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>xinqiyang notes</title>
  
  <subtitle>Nothing behind me, everything ahead of me,as is ever so on the road.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yangxinqi.com/"/>
  <updated>2020-11-02T06:58:48.604Z</updated>
  <id>http://yangxinqi.com/</id>
  
  <author>
    <name>xinqiyang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>solidity学习笔记</title>
    <link href="http://yangxinqi.com/2020/11/02/solidity%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yangxinqi.com/2020/11/02/solidity学习笔记/</id>
    <published>2020-11-02T05:06:16.000Z</published>
    <updated>2020-11-02T06:58:48.604Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Nov 02 2020 15:59:06 GMT+0900 (Japan Standard Time) --><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>做区块链相关的创业已经有4年了，都是做ETL方面的，对于真正的合约以及Trading，其实没有真正的使用，技术就是这样，用了就会发现有意思，从最早的没有信仰，到现在的信心满满，虽然BTC的价格还是3年前BTC的价格，但是市场已经今非昔比了，从DEFI的火热，到各种POOL的出现，区块链的运营方式和目标人群都巨大的变化了。在大经济形势周期的转变下，我也从数据，转战到了DEFI，因为DEFI才是代表了未来真正的放下，大环境下，随着疫情，越来越多的政府和国家地区更深入的隔绝，对于崇尚自由的人来说，我们更应该获得真正意义上的金融自由。虽然现在Blockchain还是被美帝把持着。</p><p>闲话不多说，我们开始真正的来玩转合约，合约从Ether起，也和Ether的创始团队息息相关，从V神，还有WOOD博士开始，Ether的出现也带来了Solidity和Vyper,智能合约语言，目前来看Vyper更安全，而Solidity使用更广泛，本文主要讲Solidity的开发和使用。</p><p>Solidity文档： <a href="https://learnblockchain.cn/docs/solidity/introduction-to-smart-contracts.html" target="_blank" rel="noopener">https://learnblockchain.cn/docs/solidity/introduction-to-smart-contracts.html</a></p><p><img src="/images/solidity.jpeg" alt="Solidity"></p><a id="more"></a><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><h4 id="Solidity语法"><a href="#Solidity语法" class="headerlink" title="Solidity语法"></a>Solidity语法</h4><p>Solidity 是一门面向合约的、为实现智能合约而创建的高级编程语言。这门语言受到了 C++，Python 和 Javascript 语言的影响，设计的目的是能在 <a href="https://learnblockchain.cn/2019/04/09/easy-evm/" target="_blank" rel="noopener">以太坊虚拟机（EVM）</a> 上运行。Solidity 是静态类型语言，支持继承、库和复杂的用户定义类型等特性。在部署合约时，应该尽量使用最新版本，因为新版本会有一些重大的新特性以及bug修复。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: GPL-3.0 </span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.4</span><span class="number">.16</span> &lt;<span class="number">0.8</span><span class="number">.0</span>; </span><br><span class="line"></span><br><span class="line">contract SimpleStorage &#123;</span><br><span class="line">  uint storedData;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">set</span>(<span class="params">uint x</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">  storedData = x;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> storedData;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>pragmas（编译指令）是告知编译器如何处理源代码的指令, Solidity中合约的含义就是一组代码（它的 <em>函数</em> )和数据（它的 <em>状态</em> ），它们位于以太坊区块链的一个特定地址上。该合约能完成的事情并不多（由于以太坊构建的基础架构的原因）：它能允许任何人在合约中存储一个单独的数字，并且这个数字可以被世界上任何人访问，且没有可行的办法阻止你发布这个数字。当然，任何人都可以再次调用 <code>set</code> ，传入不同的值，覆盖你的数字，但是这个数字仍会被存储在区块链的历史记录中。随后，我们会看到怎样施加访问限制，以确保只有你才能改变这个数字。 所有的标识符（合约名称，函数名称和变量名称）都只能使用ASCII字符集。UTF-8编码的数据可以用字符串变量的形式存储。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: GPL-3.0</span></span><br><span class="line">pragma solidity  &gt;<span class="number">0.5</span><span class="number">.99</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract Coin &#123;</span><br><span class="line">    <span class="comment">// 关键字“public”让这些变量可以从外部读取</span></span><br><span class="line">    address public minter;</span><br><span class="line">    mapping (<span class="function"><span class="params">address</span> =&gt;</span> uint) public balances;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 轻客户端可以通过事件针对变化作出高效的反应</span></span><br><span class="line">    event Sent(address <span class="keyword">from</span>, address to, uint amount);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这是构造函数，只有当合约创建时运行</span></span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        minter = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 铸币操作</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">mint</span>(<span class="params">address receiver, uint amount</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(msg.sender == minter);</span><br><span class="line">        <span class="built_in">require</span>(amount &lt; <span class="number">1e60</span>);</span><br><span class="line">        balances[receiver] += amount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 转币操作</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">send</span>(<span class="params">address receiver, uint amount</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(amount &lt;= balances[msg.sender], <span class="string">"Insufficient balance."</span>);</span><br><span class="line">        balances[msg.sender] -= amount;</span><br><span class="line">        balances[receiver] += amount;</span><br><span class="line">        emit Sent(msg.sender, receiver, amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>address public minter;</code> 这一行声明了一个可以被公开访问的 <code>address</code> 类型的状态变量。 <code>address</code> 类型是一个160位的值，且不允许任何算数操作。mapping (address =&gt; uint) public balances;` 也创建一个公共状态变量，但它是一个更复杂的数据类型。 该类型将address映射为无符号整数。 Mappings 可以看作是一个 <a href="https://en.wikipedia.org/wiki/Hash_table" target="_blank" rel="noopener">哈希表</a> 它会执行虚拟初始化，以使所有可能存在的键都映射到一个字节表示为全零的值。 但是，这种类比并不太恰当，因为它既不能获得映射的所有键的列表，也不能获得所有值的列表。</p><p><code>event Sent(address from, address to, uint amount);</code> 这行声明了一个所谓的“事件（event）”，它会在 <code>send</code> 函数的最后一行被发出。</p><p>对于程序员来说，区块链这个概念并不难理解，这是因为大多数难懂的东西 (挖矿, <a href="https://en.wikipedia.org/wiki/Cryptographic_hash_function" target="_blank" rel="noopener">哈希</a> ，<a href="https://en.wikipedia.org/wiki/Elliptic_curve_cryptography" target="_blank" rel="noopener">椭圆曲线密码学</a> ，<a href="https://en.wikipedia.org/wiki/Peer-to-peer" target="_blank" rel="noopener">点对点网络（P2P）</a> 等) 都只是用于提供特定的功能和承诺。</p><p><strong>区块，交易，事务</strong></p><p>区块链是全球共享的事务性数据库，这意味着每个人都可加入网络来阅读数据库中的记录。如果你想改变数据库中的某些东西，你必须创建一个被所有其他人所接受的事务。此外，交易总是由发送人（创建者）签名。</p><p>在比特币中，要解决的一个主要难题，被称为“双花攻击 (double-spend attack)”：如果网络存在两笔交易，都想花光同一个账户的钱时（即所谓的冲突）会发生什么情况？交易互相冲突？</p><p><strong>以太仿虚拟机EVM</strong></p><p>以太坊虚拟机 EVM 是智能合约的运行环境。它不仅是沙盒封装的，而且是完全隔离的，也就是说在 EVM 中运行代码是无法访问网络、文件系统和其他进程的。甚至智能合约之间的访问也是受限的。以太坊中有两类账户（它们共用同一个地址空间）： <strong>外部账户</strong> 由公钥-私钥对（也就是人）控制； <strong>合约账户</strong> 由和账户一起存储的代码控制.每个账户都有一个键值对形式的持久化存储。其中 key 和 value 的长度都是256位，我们称之为 <strong>存储</strong> 。此外，每个账户有一个以太币余额（ <strong>balance</strong> ）（单位是“Wei”, <code>1 ether</code> 是 <code>10**18 wei</code>），余额会因为发送包含以太币的交易而改变。交易可以看作是从一个帐户发送到另一个帐户的消息（这里的账户，可能是相同的或特殊的零帐户，请参阅下文）。它能包含一个二进制数据（合约负载）和以太币。如果目标账户含有代码，此代码会被执行，并以 payload 作为入参。如果目标账户是零账户（账户地址为 <code>0</code> )，此交易将创建一个 <strong>新合约</strong> 。 如前文所述，合约的地址不是零地址，而是通过合约创建者的地址和从该地址发出过的交易数量计算得到的（所谓的“nonce”）。 这个用来创建合约的交易的 payload 会被转换为 EVM 字节码并执行。执行的输出将作为合约代码被永久存储。这意味着，为创建一个合约，你不需要发送实际的合约代码，而是发送能够产生合约代码的代码。</p><p>一经创建，每笔交易都收取一定数量的 <strong>gas</strong> ，目的是限制执行交易所需要的工作量和为交易支付手续费。EVM 执行交易时，gas 将按特定规则逐渐耗尽。<strong>gas price</strong> 是交易发送者设置的一个值，发送者账户需要预付的手续费= <code>gas_price * gas</code> 。如果交易执行后还有剩余， gas 会原路返还。无论执行到什么位置，一旦 gas 被耗尽（比如降为负值），将会触发一个 out-of-gas 异常。当前调用帧（call frame）所做的所有状态修改都将被回滚。译者注：调用帧（call frame），指的是下文讲到的EVM的运行栈（stack）中当前操作所需要的若干元素。</p><p>每个账户有一块持久化内存区称为 <strong>存储</strong> 。 存储是将256位字映射到256位字的键值存储区。 在合约中枚举存储是不可能的，且读存储的相对开销很高，修改存储的开销甚至更高。合约只能读写存储区内属于自己的部分。</p><p>第二个内存区称为 <strong>内存</strong> ，合约会试图为每一次消息调用获取一块被重新擦拭干净的内存实例。 内存是线性的，可按字节级寻址，但读的长度被限制为256位，而写的长度可以是8位或256位。当访问（无论是读还是写）之前从未访问过的内存字（word）时（无论是偏移到该字内的任何位置），内存将按字进行扩展（每个字是256位）。扩容也将消耗一定的gas。 随着内存使用量的增长，其费用也会增高（以平方级别）。</p><p>EVM 不是基于寄存器的，而是基于栈的，因此所有的计算都在一个被称为 <strong>栈（stack）</strong> 的区域执行。 栈最大有1024个元素，每个元素长度是一个字（256位）。对栈的访问只限于其顶端，限制方式为：允许拷贝最顶端的16个元素中的一个到栈顶，或者是交换栈顶元素和下面16个元素中的一个。所有其他操作都只能取最顶的两个（或一个，或更多，取决于具体的操作）元素，运算后，把结果压入栈顶。当然可以把栈上的元素放到存储或内存中。但是无法只访问栈上指定深度的那个元素，除非先从栈顶移除其他元素。</p><p>EVM的指令集量应尽量少，以最大限度地避免可能导致共识问题的错误实现。所有的指令都是针对”256位的字（word）”这个基本的数据类型来进行操作。具备常用的算术、位、逻辑和比较操作。也可以做到有条件和无条件跳转。此外，合约可以访问当前区块的相关属性，比如它的编号和时间戳。</p><p>有一种特殊类型的消息调用，被称为 <strong>委托调用(delegatecall)</strong> 。它和一般的消息调用的区别在于，目标地址的代码将在发起调用的合约的上下文中执行，并且 <code>msg.sender</code> 和 <code>msg.value</code> 不变。 这意味着一个合约可以在运行时从另外一个地址动态加载代码。存储、当前地址和余额都指向发起调用的合约，只有代码是从被调用地址获取的。 这使得 Solidity 可以实现”库“能力：可复用的代码库可以放在一个合约的存储上，如用来实现复杂的数据结构的库。</p><p>有一种特殊的可索引的数据结构，其存储的数据可以一路映射直到区块层级。这个特性被称为 <strong>日志(logs)</strong> ，Solidity用它来实现 <strong>事件(events)</strong> 。合约创建之后就无法访问日志数据，但是这些数据可以从区块链外高效的访问。因为部分日志数据被存储在 <a href="https://en.wikipedia.org/wiki/Bloom_filter" target="_blank" rel="noopener">布隆过滤器（Bloom filter)</a> 中，我们可以高效并且加密安全地搜索日志，所以那些没有下载整个区块链的网络节点（轻客户端）也可以找到这些日志。</p><p>合约代码从区块链上移除的唯一方式是合约在合约地址上的执行自毁操作 <code>selfdestruct</code> 。合约账户上剩余的以太币会发送给指定的目标，然后其存储和代码从状态中被移除。移除一个合约听上去不错，但其实有潜在的危险，如果有人发送以太币到移除的合约，这些以太币将永远提丢失。</p><h4 id="安装Solidity"><a href="#安装Solidity" class="headerlink" title="安装Solidity"></a>安装Solidity</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### 最常用的还是通过nodejs来安装</span></span><br><span class="line">npm install -g solc</span><br><span class="line"></span><br><span class="line">docker run ethereum/solc:stable solc --version</span><br><span class="line"></span><br><span class="line">sudo add-apt-repository ppa:ethereum/ethereum</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install solc</span><br><span class="line"></span><br><span class="line"><span class="comment">## 从源码安装</span></span><br><span class="line">sudo xcodebuild -license accept</span><br></pre></td></tr></table></figure><h4 id="Solidity源文件结构"><a href="#Solidity源文件结构" class="headerlink" title="Solidity源文件结构"></a>Solidity源文件结构</h4><p>源文件中可以包含任意多个 <a href="https://learnblockchain.cn/docs/solidity/structure-of-a-contract.html#contract-structure" target="_blank" rel="noopener">合约定义</a> 、<a href="https://learnblockchain.cn/docs/solidity/layout-of-source-files.html#import" target="_blank" rel="noopener">导入源文件指令</a> 、 <a href="https://learnblockchain.cn/docs/solidity/layout-of-source-files.html#pragma" target="_blank" rel="noopener">版本标识</a> 指令、 <a href="https://learnblockchain.cn/docs/solidity/types.html#structs" target="_blank" rel="noopener">结构体</a> , <a href="https://learnblockchain.cn/docs/solidity/types.html#enums" target="_blank" rel="noopener">枚举</a> 和 <a href="https://learnblockchain.cn/docs/solidity/contracts.html#functions" target="_blank" rel="noopener">函数</a> 定义.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.5</span><span class="number">.2</span>;</span><br></pre></td></tr></table></figure><p>这样，源文件将既不允许低于 0.5.2 版本的编译器编译， 也不允许高于（包含） <code>0.6.0</code> 版本的编译器编译（第二个条件因使用 <code>^</code> 被添加）。 这种做法的考虑是，编译器在 0.6.0 版本之前不会有重大变更，所以可确保源代码始终按预期被编译。 上面例子中不固定编译器的具体版本号，因此编译器的补丁版也可以使用。</p><p>Pragma 是 pragmatic information 的简称，微软 Visual C++ <a href="https://msdn.microsoft.com/zh-cn/library/d9x1s805.aspx" target="_blank" rel="noopener">文档</a> 中译为标识。 Solidity 中沿用 C ，C++ 等中的编译指令概念，用于告知编译器 <strong>如何</strong> 编译。 ——译者注</p><p>第2个标注是用来标注实验性阶段的功能，它可以用来启用一些新的编译器功能或语法特性。 当前支持下面的一些实验性标注: ABIEncoderV2</p><p>新的 ABI 编码器可以用来编码和解码嵌套的数组和结构体，当然这部分代码还在优化之中，他没有像之前 ABI 编码器 那样经过严格的测试，我们可以使用下面的语法来启用它</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pragma experimental ABIEncoderV2;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"filename"</span>;</span><br></pre></td></tr></table></figure><p>ES6 即 ECMAScript 6.0，ES6是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布。 ——译者注</p><p>通常使用相对引用 <code>import &quot;./filename.sol&quot;;</code> 并且避免使用 <code>..</code> ，后面这种方式可以使用全局路径并设置映射，下面会有解释。</p><p>可以使用单行注释（<code>//</code>）和多行注释（<code>/*...*/</code>）</p><p>在 Solidity 语言中，合约类似于其他面向对象编程语言中的<strong>类</strong>。</p><p>每个合约中可以包含 <a href="https://learnblockchain.cn/docs/solidity/structure-of-a-contract.html#structure-state-variables" target="_blank" rel="noopener">状态变量</a>、 <a href="https://learnblockchain.cn/docs/solidity/structure-of-a-contract.html#structure-functions" target="_blank" rel="noopener">函数</a>、<a href="https://learnblockchain.cn/docs/solidity/structure-of-a-contract.html#structure-events" target="_blank" rel="noopener">事件 Event</a>、 <a href="https://learnblockchain.cn/docs/solidity/structure-of-a-contract.html#structure-struct-types" target="_blank" rel="noopener">结构体</a>、 和 <a href="https://learnblockchain.cn/docs/solidity/structure-of-a-contract.html#structure-enum-types" target="_blank" rel="noopener">枚举类型</a> 的声明，且合约可以从其他合约继承。</p><p>还有一些特殊的合约，如： <a href="https://learnblockchain.cn/docs/solidity/contracts.html#libraries" target="_blank" rel="noopener">库</a> 和 <a href="https://learnblockchain.cn/docs/solidity/contracts.html#interfaces" target="_blank" rel="noopener">接口</a>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=<span class="number">0.4</span><span class="number">.0</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract TinyStorage &#123;</span><br><span class="line">    uint storedXlbData; <span class="comment">// 状态变量</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: GPL-3.0</span></span><br><span class="line">pragma solidity &gt;<span class="number">0.7</span><span class="number">.0</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract TinyAuction &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Mybid</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">payable</span> </span>&#123; <span class="comment">// 定义函数</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Helper function defined outside of a contract</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">helper</span>(<span class="params">uint x</span>) <span class="title">pure</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=<span class="number">0.4</span><span class="number">.22</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract MyPurchase &#123;</span><br><span class="line">    address public seller;</span><br><span class="line"></span><br><span class="line">    modifier onlySeller() &#123; <span class="comment">// 修改器</span></span><br><span class="line">        <span class="built_in">require</span>(</span><br><span class="line">            msg.sender == seller,</span><br><span class="line">            <span class="string">"Only seller can call this."</span></span><br><span class="line">        );</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">abort</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">onlySeller</span> </span>&#123; <span class="comment">// 修改器用法</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数 修改器modifier 可以用来以声明的方式修改函数语义（参阅合约章节中 <a href="https://learnblockchain.cn/docs/solidity/contracts.html#modifiers" target="_blank" rel="noopener">函数修改器</a>）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=<span class="number">0.4</span><span class="number">.21</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line">contract TinyAuction &#123;</span><br><span class="line">    event HighestBidIncreased(address bidder, uint amount); <span class="comment">// 事件</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bid</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">payable</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        emit HighestBidIncreased(msg.sender, msg.value); <span class="comment">// 触发事件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事件是能方便地调用以太坊虚拟机日志功能的接口。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=<span class="number">0.4</span><span class="number">.0</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract TinyBallot &#123;</span><br><span class="line">    struct Voter &#123; <span class="comment">// 结构体 结构体是可以将几个变量分组的自定义类型</span></span><br><span class="line">        uint weight;</span><br><span class="line">        bool voted;</span><br><span class="line">        address delegate;</span><br><span class="line">        uint vote;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=<span class="number">0.4</span><span class="number">.0</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract Upchain &#123;</span><br><span class="line">    enum State &#123; Created, Locked, InValid &#125; <span class="comment">// 枚举 枚举可用来创建由一定数量的“常量值”构成的自定义类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h4><p><code>bool</code> ：可能的取值为字面常量值 <code>true</code> 和 <code>false</code> 。</p><p>运算符：</p><ul><li><p><code>!</code> （逻辑非）</p></li><li><p><code>&amp;&amp;</code> （逻辑与， “and” ）</p></li><li><p><code>||</code> （逻辑或， “or” ）</p></li><li><p><code>==</code> （等于）</p></li><li><p><code>!=</code> （不等于）</p><p>运算符 <code>||</code> 和 <code>&amp;&amp;</code> 都遵循同样的短路（ short-circuiting ）规则。就是说在表达式 <code>f(x) || g(y)</code> 中， 如果 <code>f(x)</code> 的值为 <code>true</code> ，那么 <code>g(y)</code> 就不会被执行，即使会出现一些副作用。</p></li></ul><p><code>int</code> / <code>uint</code> ：分别表示有符号和无符号的不同位数的整型变量。 支持关键字 <code>uint8</code> 到 <code>uint256</code> （无符号，从 8 位到 256 位）以及 <code>int8</code> 到 <code>int256</code>，以 <code>8</code> 位为步长递增。 <code>uint</code> 和 <code>int</code> 分别是 <code>uint256</code> 和 <code>int256</code> 的别名。</p><p>运算符：</p><ul><li>比较运算符： <code>&lt;=</code> ， <code>&lt;</code> ， <code>==</code> ， <code>!=</code> ， <code>&gt;=</code> ， <code>&gt;</code> （返回布尔值）</li><li>位运算符： <code>&amp;</code> ， <code>|</code> ， <code>^</code> （异或）， <code>~</code> （位取反）</li><li>移位运算符： <code>&lt;&lt;</code> （左移位） ， <code>&gt;&gt;</code> （右移位）</li><li>算数运算符： <code>+</code> ， <code>-</code> ， 一元运算 <code>-</code> ， 一元运算 <code>+</code> ， <code>*</code> ， <code>/</code> ， <code>%</code> （取余或叫模运算） ， <code>**</code> （幂）</li></ul><p>对于整形 <code>X</code>，可以使用 <code>type(X).min</code> 和 <code>type(X).max</code> 去获取这个类型的最小值与最大值。</p><p>加法，减法和乘法具有通常的语义，值用两进制补码表示，意思是比如：<code>uint256（0） - uint256（1）== 2 ** 256 - 1</code> 。 我们在设计和编写智能合约时必须考虑到溢出问题。</p><p>表达式 <code>-x</code> 相当于 <code>(T(0) - x)</code> 这里 <code>T</code> 是指 <code>x</code> 的类型。 这意味着如果 <code>x</code> 的类型的类型是无符号整数类型 <code>-x</code> 不会是负数。 另外，如果 <code>x</code> 为负数， <code>-x</code> 也可以为正数。 由于两进制补码表示还需要小心:</p><p>除法运算结果的类型始终是其中一个操作数的类型，整数除法总是产生整数。 在Solidity中，分数会取零。 这意味着 <code>int256(-5) / int256(2) == int256(-2)</code></p><p>注意在智能合约中，在 <a href="https://learnblockchain.cn/docs/solidity/types.html#rational-literals" target="_blank" rel="noopener">字面常量</a> 上进行除法会保留精度（保留小数位）。</p><p><strong>除以0 会发生错误（assert 类型错误）。</strong></p><p>模运算 <code>a％n</code> 是在操作数 <code>a</code> 的除以 <code>n</code> 之后产生余数 <code>r</code> ，其中 <code>q = int(a / n)</code> 和 <code>r = a - (n * q)</code> 。 这意味着模运算结果与左操作数相同的符号相同（或零）。 对于 负数的a : <code>a % n == -(a % n)</code>， 几个例子：</p><blockquote><ul><li><code>int256(5) % int256(2) == int256(1)</code></li><li><code>int256(5) % int256(-2) == int256(1)</code></li><li><code>int256(-5) % int256(2) == int256(-1)</code></li><li><code>int256(-5) % int256(-2) == int256(-1)</code></li></ul></blockquote><p>注解, 对0取模会发生错误（assert 类型错误）。</p><p><strong>注意 `0</strong>0<code>在EVM中定义为</code>1` 。**</p><p><code>fixed</code> / <code>ufixed</code>：表示各种大小的有符号和无符号的定长浮点型。 在关键字 <code>ufixedMxN</code> 和 <code>fixedMxN</code> 中，<code>M</code> 表示该类型占用的位数，<code>N</code> 表示可用的小数位数。 <code>M</code> 必须能整除 8，即 8 到 256 位。 <code>N</code> 则可以是从 0 到 80 之间的任意数。 <code>ufixed</code> 和 <code>fixed</code> 分别是 <code>ufixed128x19</code> 和 <code>fixed128x19</code> 的别名。</p><p>地址类型有两种形式，他们大致相同：</p><blockquote><ul><li><code>address</code>：保存一个20字节的值（以太坊地址的大小）。</li><li><code>ddress payable</code> ：可支付地址，与 <code>address</code> 相同，不过有成员函数 <code>transfer</code> 和 <code>send</code> 。</li></ul></blockquote><p>这种区别背后的思想是 <strong><code>address payable</code> 可以接受以太币的地址，而一个普通的 <code>address</code> 则不能</strong>。</p><p>可以使用 <code>balance</code> 属性来查询一个地址的余额， 也可以使用 <code>transfer</code> 函数向一个可支付地址（payable address）发送 以太币Ether （以 wei 为单位）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">address x = 0x123;</span><br><span class="line">address myAddress = this;</span><br><span class="line"><span class="keyword">if</span> (x.balance &lt; 10 &amp;&amp; myAddress.balance &gt;= 10) x.transfer(10);</span><br></pre></td></tr></table></figure><p>如果当前合约的余额不够多，则 <code>transfer</code> 函数会执行失败，或者如果以太转移被接收帐户拒绝， <code>transfer</code> 函数同样会失败而进行回退。</p><p>如果 <code>x</code> 是一个合约地址，它的代码（更具体来说是, 如果有receive函数, 执行 <a href="https://learnblockchain.cn/docs/solidity/contracts.html#receive-ether-function" target="_blank" rel="noopener">receive 接收以太函数</a>, 或者存在fallback函数,执行 <a href="https://learnblockchain.cn/docs/solidity/contracts.html#fallback-function" target="_blank" rel="noopener">Fallback 回退函数</a> 函数）会跟 <code>transfer</code> 函数调用一起执行（这是 EVM 的一个特性，无法阻止）。 如果在执行过程中用光了 gas 或者因为任何原因执行失败，以太币Ether 交易会被打回，当前的合约也会在终止的同时抛出异常。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">警告⚠️：</span><br><span class="line">在使用 send 的时候会有些风险：如果调用栈深度是 1024 会导致发送失败（这总是可以被调用者强制），如果接收者用光了 gas 也会导致发送失败。 所以为了保证 以太币Ether 发送的安全，一定要检查 send 的返回值，使用 transfer 或者更好的办法： 使用接收者自己取回资金的模式。</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bytes memory payload = abi.encodeWithSignature(<span class="string">"register(string)"</span>, <span class="string">"MyName"</span>);</span><br><span class="line">(bool success, bytes memory returnData) = address(nameReg).call(payload);</span><br><span class="line"><span class="built_in">require</span>(success);</span><br><span class="line"></span><br><span class="line">address nameReg = <span class="number">0x72ba7d8e73fe8eb666ea66babc8116a41bfb10e2</span>;</span><br><span class="line">nameReg.call(<span class="string">"register"</span>, <span class="string">"MyName"</span>);</span><br><span class="line">nameReg.call(bytes4(keccak256(<span class="string">"fun(uint256)"</span>)), a);</span><br></pre></td></tr></table></figure><p>所有这些函数都是低级函数，应谨慎使用。 具体来说，任何未知的合约都可能是恶意的，我们在调用一个合约的同时就将控制权交给了它，而合约又可以回调合约，所以要准备好在调用返回时改变相应的状态变量（可参考 <a href="https://learnblockchain.cn/docs/solidity/security-considerations.html#re-entance" target="_blank" rel="noopener">可重入</a> )， 与其他合约交互的常规方法是在合约对象上调用函数（x.f()）。</p><p>所有三个函数 <code>call</code> ，<code>delegatecall</code> 和 <code>staticcall</code> 都是非常低级的函数，应该只把它们当作 <em>最后一招</em> 来使用，因为它们破坏了 Solidity 的类型安全性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">uint128 a = <span class="number">1</span>;</span><br><span class="line">uint128 b = <span class="number">2.5</span> + a + <span class="number">0.5</span>;</span><br><span class="line"></span><br><span class="line">bytes32 samevar = <span class="string">"stringliteral"</span>;</span><br><span class="line">string memory a = unicode<span class="string">"Hello 😃"</span>;</span><br><span class="line">hex<span class="string">"0011223344556677"</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: GPL-3.0</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.4</span><span class="number">.16</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract test &#123;</span><br><span class="line">    enum ActionChoices &#123; GoLeft, GoRight, GoStraight, SitStill &#125;</span><br><span class="line">    ActionChoices choice;</span><br><span class="line">    ActionChoices constant defaultChoice = ActionChoices.GoStraight;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setGoStraight</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        choice = ActionChoices.GoStraight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于枚举类型不属于 |ABI| 的一部分，因此对于所有来自 Solidity 外部的调用，</span></span><br><span class="line">    <span class="comment">// "getChoice" 的签名会自动被改成 "getChoice() returns (uint8)"。</span></span><br><span class="line">    <span class="comment">// 整数类型的大小已经足够存储所有枚举类型的值，随着值的个数增加，</span></span><br><span class="line">    <span class="comment">// 可以逐渐使用 `uint16` 或更大的整数类型。</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getChoice</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">ActionChoices</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> choice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getDefaultChoice</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> uint(defaultChoice);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">&lt;parameter types&gt;</span>) </span>&#123;internal|external&#125; [pure|constant|view|payable] [returns (&lt;return types&gt;)]</span><br></pre></td></tr></table></figure><ul><li><p>内存memory 即数据在内存中，因此数据仅在其生命周期内（函数调用期间）有效。不能用于外部调用。</p></li><li><p>存储storage 状态变量保存的位置，只要合约存在就一直存储．</p></li><li><p>调用数据calldata 用来保存函数参数的特殊数据位置，是一个只读位置。</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: GPL-3.0</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.5</span><span class="number">.0</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract Tiny &#123;</span><br><span class="line">    uint[] x; <span class="comment">// x 的数据存储位置是 storage，　位置可以忽略</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// memoryArray 的数据存储位置是 memory</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">uint[] memory memoryArray</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        x = memoryArray; <span class="comment">// 将整个数组拷贝到 storage 中，可行</span></span><br><span class="line">        uint[] storage y = x;  <span class="comment">// 分配一个指针（其中 y 的数据存储位置是 storage），可行</span></span><br><span class="line">        y[<span class="number">7</span>]; <span class="comment">// 返回第 8 个元素，可行</span></span><br><span class="line">        y.pop(); <span class="comment">// 通过 y 修改 x，可行</span></span><br><span class="line">        <span class="keyword">delete</span> x; <span class="comment">// 清除数组，同时修改 y，可行</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面的就不可行了；需要在 storage 中创建新的未命名的临时数组，</span></span><br><span class="line">        <span class="comment">// 但 storage 是“静态”分配的：</span></span><br><span class="line">        <span class="comment">// y = memoryArray;</span></span><br><span class="line">        <span class="comment">// 下面这一行也不可行，因为这会“重置”指针，</span></span><br><span class="line">        <span class="comment">// 但并没有可以让它指向的合适的存储位置。</span></span><br><span class="line">        <span class="comment">// delete y;</span></span><br><span class="line"></span><br><span class="line">        g(x); <span class="comment">// 调用 g 函数，同时移交对 x 的引用</span></span><br><span class="line">        h(x); <span class="comment">// 调用 h 函数，同时在 memory 中创建一个独立的临时拷贝</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params">uint[] storage </span>) <span class="title">internal</span> <span class="title">pure</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">h</span>(<span class="params">uint[] memory</span>) <span class="title">public</span> <span class="title">pure</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=<span class="number">0.6</span><span class="number">.99</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="built_in">Proxy</span> &#123;</span><br><span class="line">    <span class="comment">/// 被当前合约管理的 客户端合约地址</span></span><br><span class="line">    address client;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(address _client) &#123;</span><br><span class="line">        client = _client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 在进行参数验证之后，转发到由client实现的 "setOwner(address)"</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">forward</span>(<span class="params">bytes calldata _payload</span>) <span class="title">external</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 由于 ABI 解码要求填充的数据（padded data）不能使用</span></span><br><span class="line">        <span class="comment">// abi.decode(_payload[:4], (bytes4)).</span></span><br><span class="line">        bytes4 sig =</span><br><span class="line">            _payload[<span class="number">0</span>] |</span><br><span class="line">            (bytes4(_payload[<span class="number">1</span>]) &gt;&gt; <span class="number">8</span>) |</span><br><span class="line">            (bytes4(_payload[<span class="number">2</span>]) &gt;&gt; <span class="number">16</span>) |</span><br><span class="line">            (bytes4(_payload[<span class="number">3</span>]) &gt;&gt; <span class="number">24</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sig == bytes4(keccak256(<span class="string">"setOwner(address)"</span>))) &#123;</span><br><span class="line">            address owner = abi.decode(_payload[<span class="number">4</span>:], (address));</span><br><span class="line">            <span class="built_in">require</span>(owner != address(<span class="number">0</span>), <span class="string">"Address of owner cannot be zero."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        (bool status,) = client.delegatecall(_payload);</span><br><span class="line">        <span class="built_in">require</span>(status, <span class="string">"Forwarded call failed."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: GPL-3.0</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.4</span><span class="number">.0</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract MappingExample &#123;</span><br><span class="line">    mapping(<span class="function"><span class="params">address</span> =&gt;</span> uint) public balances;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params">uint newBalance</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        balances[msg.sender] = newBalance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract MappingLBC &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">        MappingExample m = <span class="keyword">new</span> MappingExample();</span><br><span class="line">        m.update(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">return</span> m.balances(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: GPL-3.0</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.4</span><span class="number">.22</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract MappingExample &#123;</span><br><span class="line"></span><br><span class="line">    mapping (<span class="function"><span class="params">address</span> =&gt;</span> uint256) private _balances;</span><br><span class="line">    mapping (<span class="function"><span class="params">address</span> =&gt;</span> mapping (<span class="function"><span class="params">address</span> =&gt;</span> uint256)) private _allowances;</span><br><span class="line"></span><br><span class="line">    event Transfer(address indexed <span class="keyword">from</span>, address indexed to, uint256 value);</span><br><span class="line">    event Approval(address indexed owner, address indexed spender, uint256 value);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">allowance</span>(<span class="params">address owner, address spender</span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">uint256</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _allowances[owner][spender];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">transferFrom</span>(<span class="params">address sender, address recipient, uint256 amount</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">bool</span>) </span>&#123;</span><br><span class="line">        _transfer(sender, recipient, amount);</span><br><span class="line">        approve(sender, msg.sender, amount);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">approve</span>(<span class="params">address owner, address spender, uint256 amount</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">bool</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(owner != address(<span class="number">0</span>), <span class="string">"ERC20: approve from the zero address"</span>);</span><br><span class="line">        <span class="built_in">require</span>(spender != address(<span class="number">0</span>), <span class="string">"ERC20: approve to the zero address"</span>);</span><br><span class="line"></span><br><span class="line">        _allowances[owner][spender] = amount;</span><br><span class="line">        emit Approval(owner, spender, amount);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">_transfer</span>(<span class="params">address sender, address recipient, uint256 amount</span>) <span class="title">internal</span> </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(sender != address(<span class="number">0</span>), <span class="string">"ERC20: transfer from the zero address"</span>);</span><br><span class="line">        <span class="built_in">require</span>(recipient != address(<span class="number">0</span>), <span class="string">"ERC20: transfer to the zero address"</span>);</span><br><span class="line"></span><br><span class="line">        _balances[sender] -= amount;</span><br><span class="line">        _balances[recipient] += amount;</span><br><span class="line">        emit Transfer(sender, recipient, amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: GPL-3.0</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.6</span><span class="number">.0</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">struct IndexValue &#123; uint keyIndex; uint value; &#125;</span><br><span class="line">struct KeyFlag &#123; uint key; bool deleted; &#125;</span><br><span class="line"></span><br><span class="line">struct itmap &#123;</span><br><span class="line">    mapping(<span class="function"><span class="params">uint</span> =&gt;</span> IndexValue) data;</span><br><span class="line">    KeyFlag[] keys;</span><br><span class="line">    uint size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">library IterableMapping &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params">itmap storage self, uint key, uint value</span>) <span class="title">internal</span> <span class="title">returns</span> (<span class="params">bool replaced</span>) </span>&#123;</span><br><span class="line">        uint keyIndex = self.data[key].keyIndex;</span><br><span class="line">        self.data[key].value = value;</span><br><span class="line">        <span class="keyword">if</span> (keyIndex &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            keyIndex = self.keys.length;</span><br><span class="line"></span><br><span class="line">            self.keys.push();</span><br><span class="line">            self.data[key].keyIndex = keyIndex + <span class="number">1</span>;</span><br><span class="line">            self.keys[keyIndex].key = key;</span><br><span class="line">            self.size++;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params">itmap storage self, uint key</span>) <span class="title">internal</span> <span class="title">returns</span> (<span class="params">bool success</span>) </span>&#123;</span><br><span class="line">        uint keyIndex = self.data[key].keyIndex;</span><br><span class="line">        <span class="keyword">if</span> (keyIndex == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">delete</span> self.data[key];</span><br><span class="line">        self.keys[keyIndex - <span class="number">1</span>].deleted = <span class="literal">true</span>;</span><br><span class="line">        self.size --;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">contains</span>(<span class="params">itmap storage self, uint key</span>) <span class="title">internal</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">bool</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> self.data[key].keyIndex &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">iterate_start</span>(<span class="params">itmap storage self</span>) <span class="title">internal</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">uint keyIndex</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> iterate_next(self, uint(<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">iterate_valid</span>(<span class="params">itmap storage self, uint keyIndex</span>) <span class="title">internal</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">bool</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> keyIndex &lt; self.keys.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">iterate_next</span>(<span class="params">itmap storage self, uint keyIndex</span>) <span class="title">internal</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">uint r_keyIndex</span>) </span>&#123;</span><br><span class="line">        keyIndex++;</span><br><span class="line">        <span class="keyword">while</span> (keyIndex &lt; self.keys.length &amp;&amp; self.keys[keyIndex].deleted)</span><br><span class="line">            keyIndex++;</span><br><span class="line">        <span class="keyword">return</span> keyIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">iterate_get</span>(<span class="params">itmap storage self, uint keyIndex</span>) <span class="title">internal</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">uint key, uint value</span>) </span>&#123;</span><br><span class="line">        key = self.keys[keyIndex].key;</span><br><span class="line">        value = self.data[key].value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如何使用</span></span><br><span class="line">contract User &#123;</span><br><span class="line">    <span class="comment">// Just a struct holding our data.</span></span><br><span class="line">    itmap data;</span><br><span class="line">    <span class="comment">// Apply library functions to the data type.</span></span><br><span class="line">    using IterableMapping <span class="keyword">for</span> itmap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Insert something</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params">uint k, uint v</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">uint size</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// This calls IterableMapping.insert(data, k, v)</span></span><br><span class="line">        data.insert(k, v);</span><br><span class="line">        <span class="comment">// We can still access members of the struct,</span></span><br><span class="line">        <span class="comment">// but we should take care not to mess with them.</span></span><br><span class="line">        <span class="keyword">return</span> data.size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Computes the sum of all stored data.</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">uint s</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (</span><br><span class="line">            uint i = data.iterate_start();</span><br><span class="line">            data.iterate_valid(i);</span><br><span class="line">            i = data.iterate_next(i)</span><br><span class="line">        ) &#123;</span><br><span class="line">            (, uint value) = data.iterate_get(i);</span><br><span class="line">            s += value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>映射本身是无法遍历的，即无法枚举所有的键。不过，可以在它们之上实现一个数据结构来进行迭代。 例如，以下代码实现了 <code>IterableMapping</code> 库，然后　<code>User</code> 合约可以添加数据，　<code>sum</code>　函数迭代求和所有值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: GPL-3.0</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.4</span><span class="number">.0</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract DeleteLBC &#123;</span><br><span class="line">    uint data;</span><br><span class="line">    uint[] dataArray;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        uint x = data;</span><br><span class="line">        <span class="keyword">delete</span> x; <span class="comment">// 将 x 设为 0，并不影响数据</span></span><br><span class="line">        <span class="keyword">delete</span> data; <span class="comment">// 将 data 设为 0，并不影响 x，因为它仍然有个副本</span></span><br><span class="line">        uint[] storage y = dataArray;</span><br><span class="line">        <span class="keyword">delete</span> dataArray;</span><br><span class="line">        <span class="comment">// 将 dataArray.length 设为 0，但由于 uint[] 是一个复杂的对象，y 也将受到影响，</span></span><br><span class="line">        <span class="comment">// 因为它是一个存储位置是 storage 的对象的别名。</span></span><br><span class="line">        <span class="comment">// 另一方面："delete y" 是非法的，引用了 storage 对象的局部变量只能由已有的 storage 对象赋值。</span></span><br><span class="line">        assert(y.length == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">uint8 y;</span><br><span class="line">uint16 z;</span><br><span class="line">uint32 x = y + z;</span><br><span class="line">int8 y = <span class="number">-3</span>;</span><br><span class="line">uint x = uint(y);</span><br><span class="line">uint32 a = <span class="number">0x12345678</span>;</span><br><span class="line">uint16 b = uint16(a); <span class="comment">// 此时 b 的值是 0x5678</span></span><br><span class="line">uint16 a = <span class="number">0x1234</span>;</span><br><span class="line">uint32 b = uint32(a); <span class="comment">// b 为 0x00001234 now</span></span><br><span class="line">assert(a == b);</span><br></pre></td></tr></table></figure><h4 id="单位和全局变量"><a href="#单位和全局变量" class="headerlink" title="单位和全局变量"></a>单位和全局变量</h4><p>以太币Ether 单位之间的换算就是在数字后边加上 <code>wei</code>、<code>gwei</code> 或 <code>ether</code> 来实现的，如果后面没有单位，缺省为 wei。例如 <code>2 ether == 2000 finney</code> 的逻辑判断值为 <code>true</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">assert(<span class="number">1</span> wei == <span class="number">1</span>);</span><br><span class="line">assert(<span class="number">1</span> gwei == <span class="number">1e9</span>);</span><br><span class="line">assert(<span class="number">1</span> ether == <span class="number">1e18</span>);</span><br></pre></td></tr></table></figure><p>这些后缀不能直接用在变量后边。如果想用时间单位（例如 days）来将输入变量换算为时间，你可以用如下方式来完成：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> == <span class="number">1</span> seconds</span><br><span class="line"><span class="number">1</span> minutes == <span class="number">60</span> seconds</span><br><span class="line"><span class="number">1</span> hours == <span class="number">60</span> minutes</span><br><span class="line"><span class="number">1</span> days == <span class="number">24</span> hours</span><br><span class="line"><span class="number">1</span> weeks == <span class="number">7</span> days</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">uint start, uint daysAfter</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (block.timestamp &gt;= start + daysAfter * <span class="number">1</span> days) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这些编码函数可以用来构造函数调用数据，而不用实际进行调用。此外，keccak256(abi.encodePacked(a, b)) 是一种计算结构化数据的哈希值（尽管我们也应该关注到：使用不同的函数参数类型也有可能会引起“哈希冲突” ）的方式，不推荐使用的 keccak256(a, b) 。</span><br></pre></td></tr></table></figure><h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>可以参阅专门的章节 <a href="https://learnblockchain.cn/docs/solidity/control-structures.html#assert-and-require" target="_blank" rel="noopener">assert and require</a> 参阅有关错误处理以及何时使用哪个函数的更多详细信息。</p><ul><li><p><code>assert(bool condition)</code></p><p>如果不满足条件，则会导致无效的操作码，则撤销状态更改 - 用于检查内部错误。</p></li><li><p><code>require(bool condition)</code></p><p>如果条件不满足则撤销状态更改 - 用于检查由输入或者外部组件引起的错误。</p></li><li><p><code>require(bool condition, string memory message)</code></p><p>如果条件不满足则撤销状态更改 - 用于检查由输入或者外部组件引起的错误，可以同时提供一个错误消息。</p></li><li><p><code>revert()</code></p><p>终止运行并撤销状态更改。</p></li><li><p><code>revert(string memory reason)</code></p><p>终止运行并撤销状态更改，可以同时提供一个解释性的字符串。</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=<span class="number">0.5</span><span class="number">.0</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    uint index;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">uint, bool, uint</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">7</span>, <span class="literal">true</span>, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="comment">//基于返回的元组来声明变量并赋值</span></span><br><span class="line">        (uint x, bool b, uint y) = f();</span><br><span class="line">        <span class="comment">//交换两个值的通用窍门——但不适用于非值类型的存储 (storage) 变量。</span></span><br><span class="line">        (x, y) = (y, x);</span><br><span class="line">        <span class="comment">//元组的末尾元素可以省略（这也适用于变量声明）。</span></span><br><span class="line">        (index,,) = f(); <span class="comment">// 设置 index 为 7</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=<span class="number">0.5</span><span class="number">.0</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract Sharer &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sendHalf</span>(<span class="params">address addr</span>) <span class="title">public</span> <span class="title">payable</span> <span class="title">returns</span> (<span class="params">uint balance</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(msg.value % <span class="number">2</span> == <span class="number">0</span>, <span class="string">"Even value required."</span>);</span><br><span class="line">        uint balanceBeforeTransfer = <span class="keyword">this</span>.balance;</span><br><span class="line">        addr.transfer(msg.value / <span class="number">2</span>);</span><br><span class="line">                    <span class="comment">//由于转移函数在失败时抛出异常并且不能在这里回调，因此我们应该没有办法仍然有一半的钱。</span></span><br><span class="line">        assert(<span class="keyword">this</span>.balance == balanceBeforeTransfer - msg.value / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在内部， Solidity 对一个 <code>require</code> 式的异常执行回退操作（指令 <code>0xfd</code> ）并执行一个无效操作（指令 <code>0xfe</code> ）来引发 <code>assert</code> 式异常。 在这两种情况下，都会导致 EVM 回退对状态所做的所有更改。回退的原因是不能继续安全地执行，因为没有实现预期的效果。</p><p>在这两种情况下，调用者都可以使用 <code>try</code>/<code>catch</code> 来应对此类失败（在<code>assert</code>类型的异常中,仅在剩余足够gas的情况下才行 ），但是调用者中的更改将始终被还原。</p><p>请注意， <code>assert</code> 式异常消耗了所有可用的调用 gas ，<strong>而从 Metropolis 版本起 <code>require</code> 式的异常不会消耗任何 gas。 </strong>这里还是尽量使用require.</p><h4 id="合约"><a href="#合约" class="headerlink" title="合约"></a>合约</h4><h4 id="Solidity-合约类似于面向对象语言中的类。合约中有用于数据持久化的状态变量，和可以修改状态变量的函数。-调用另一个合约实例的函数时，会执行一个-EVM-函数调用，这个操作会切换执行时的上下文，这样，前一个合约的状态变量就不能访问了。"><a href="#Solidity-合约类似于面向对象语言中的类。合约中有用于数据持久化的状态变量，和可以修改状态变量的函数。-调用另一个合约实例的函数时，会执行一个-EVM-函数调用，这个操作会切换执行时的上下文，这样，前一个合约的状态变量就不能访问了。" class="headerlink" title="Solidity 合约类似于面向对象语言中的类。合约中有用于数据持久化的状态变量，和可以修改状态变量的函数。 调用另一个合约实例的函数时，会执行一个 EVM 函数调用，这个操作会切换执行时的上下文，这样，前一个合约的状态变量就不能访问了。"></a>Solidity 合约类似于面向对象语言中的类。合约中有用于数据持久化的状态变量，和可以修改状态变量的函数。 调用另一个合约实例的函数时，会执行一个 EVM 函数调用，这个操作会切换执行时的上下文，这样，前一个合约的状态变量就不能访问了。</h4><p>可以通过以太坊交易“从外部”或从 Solidity 合约内部创建合约。</p><p>一些集成开发环境，例如 <a href="https://remix.ethereum.org/" target="_blank" rel="noopener">Remix</a>, 通过使用一些UI用户界面使创建合约的过程更加顺畅。 在以太坊上通过编程创建合约最好使用 JavaScript API <a href="https://github.com/ethereum/web3.js" target="_blank" rel="noopener">web3.js</a>。 现在，我们已经有了一个叫做 <a href="https://web3js.readthedocs.io/en/1.0/web3-eth-contract.html#new-contract" target="_blank" rel="noopener">web3.eth.Contract</a> 的方法能够更容易的创建合约。</p><p>创建合约时， 合约的 <a href="https://learnblockchain.cn/docs/solidity/contracts.html#constructor" target="_blank" rel="noopener">构造函数</a> (一个用关键字 <code>constructor</code> 声明的函数)会执行一次。 构造函数是可选的。只允许有一个构造函数，这意味着不支持重载。</p><p>构造函数执行完毕后，合约的最终代码将部署到区块链上。此代码包括所有公共和外部函数以及所有可以通过函数调用访问的函数。 部署的代码没有 包括构造函数代码或构造函数调用的内部函数。</p><p>在内部，构造函数参数在合约代码之后通过 <a href="https://learnblockchain.cn/docs/solidity/abi-spec.html#abi" target="_blank" rel="noopener">ABI 编码</a> 传递，但是如果你使用 <code>web3.js</code> 则不必关心这个问题。</p><p>如果一个合约想要创建另一个合约，那么创建者必须知晓被创建合约的源代码(和二进制代码)。 这意味着不可能循环创建依赖项。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=<span class="number">0.4</span><span class="number">.22</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract OwnedToken &#123;</span><br><span class="line">    <span class="comment">// TokenCreator 是如下定义的合约类型.</span></span><br><span class="line">    <span class="comment">// 不创建新合约的话，也可以引用它。</span></span><br><span class="line">    TokenCreator creator;</span><br><span class="line">    address owner;</span><br><span class="line">    bytes32 name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这是注册 creator 和设置名称的构造函数。</span></span><br><span class="line">    <span class="keyword">constructor</span>(bytes32 _name) &#123;</span><br><span class="line">        <span class="comment">// 状态变量通过其名称访问，而不是通过例如 this.owner 的方式访问。</span></span><br><span class="line">        <span class="comment">// 这也适用于函数，特别是在构造函数中，你只能像这样（“内部地”）调用它们，</span></span><br><span class="line">        <span class="comment">// 因为合约本身还不存在。</span></span><br><span class="line">        owner = msg.sender;</span><br><span class="line">        <span class="comment">// 从 `address` 到 `TokenCreator` ，是做显式的类型转换</span></span><br><span class="line">        <span class="comment">// 并且假定调用合约的类型是 TokenCreator，没有真正的方法来检查这一点。</span></span><br><span class="line">        creator = TokenCreator(msg.sender);</span><br><span class="line">        name = _name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">changeName</span>(<span class="params">bytes32 newName</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 只有 creator （即创建当前合约的合约）能够更改名称 —— 因为合约是隐式转换为地址的，</span></span><br><span class="line">        <span class="comment">// 所以这里的比较是可行的。</span></span><br><span class="line">        <span class="keyword">if</span> (msg.sender == address(creator))</span><br><span class="line">            name = newName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">transfer</span>(<span class="params">address newOwner</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 只有当前所有者才能发送 token。</span></span><br><span class="line">        <span class="keyword">if</span> (msg.sender != owner) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 我们也想询问 creator 是否可以发送。</span></span><br><span class="line">        <span class="comment">// 请注意，这里调用了一个下面定义的合约中的函数。</span></span><br><span class="line">        <span class="comment">// 如果调用失败（比如，由于 gas 不足），会立即停止执行。</span></span><br><span class="line">        <span class="keyword">if</span> (creator.isTokenTransferOK(owner, newOwner))</span><br><span class="line">            owner = newOwner;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract TokenCreator &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">createToken</span>(<span class="params">bytes32 name</span>)</span></span><br><span class="line"><span class="function">       <span class="title">public</span></span></span><br><span class="line"><span class="function">       <span class="title">returns</span> (<span class="params">OwnedToken tokenAddress</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个新的 Token 合约并且返回它的地址。</span></span><br><span class="line">        <span class="comment">// 从 JavaScript 方面来说，返回类型是简单的 `address` 类型，因为</span></span><br><span class="line">        <span class="comment">// 这是在 ABI 中可用的最接近的类型。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OwnedToken(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">changeName</span>(<span class="params">OwnedToken tokenAddress, bytes32 name</span>)  <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 同样，`tokenAddress` 的外部类型也是 `address` 。</span></span><br><span class="line">        tokenAddress.changeName(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">isTokenTransferOK</span>(<span class="params">address currentOwner, address newOwner</span>)</span></span><br><span class="line"><span class="function">        <span class="title">public</span></span></span><br><span class="line"><span class="function">        <span class="title">view</span></span></span><br><span class="line"><span class="function">        <span class="title">returns</span> (<span class="params">bool ok</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 检查一些任意的情况。</span></span><br><span class="line">        address tokenAddress = msg.sender;</span><br><span class="line">        <span class="keyword">return</span> (keccak256(newOwner) &amp; <span class="number">0xff</span>) == (bytes20(tokenAddress) &amp; <span class="number">0xff</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 Solidity 有两种函数调用（内部调用不会产生实际的 EVM 调用或称为“消息调用”，而外部调用则会产生一个 EVM 调用）， 函数和状态变量有四种可见性类型。 函数可以指定为 <code>external</code> ，<code>public</code> ，<code>internal</code> 或者 <code>private</code>。 对于状态变量，不能设置为 <code>external</code> ，默认是 <code>internal</code> 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">external</span><br></pre></td></tr></table></figure><p>外部函数作为合约接口的一部分，意味着我们可以从其他合约和交易中调用。 一个外部函数 <code>f</code> 不能从内部调用（即 <code>f</code> 不起作用，但 <code>this.f()</code> 可以）。 当收到大量数据的时候，外部函数有时候会更有效率，因为数据不会从calldata复制到内存.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public</span><br></pre></td></tr></table></figure><p>public 函数是合约接口的一部分，可以在内部或通过消息调用。对于 public 状态变量， 会自动生成一个 getter 函数（见下面）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">internal</span><br></pre></td></tr></table></figure><p>这些函数和状态变量只能是内部访问（即从当前合约内部或从它派生的合约访问），不使用 <code>this</code> 调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private</span><br></pre></td></tr></table></figure><p>private 函数和状态变量仅在当前定义它们的合约中使用，并且不能被派生合约使用。</p><p><strong>合约中的所有内容对外部观察者都是可见的。设置一些 <code>private</code> 类型只能阻止其他合约访问和修改这些信息， 但是对于区块链外的整个世界它仍然是可见的。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: GPL-3.0</span></span><br><span class="line">pragma solidity &gt;<span class="number">0.7</span><span class="number">.0</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract owned &#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123; owner = msg.sender; &#125;</span><br><span class="line"></span><br><span class="line">    address owner;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个合约只定义一个修改器，但并未使用： 它将会在派生合约中用到。</span></span><br><span class="line">    <span class="comment">// 修改器所修饰的函数体会被插入到特殊符号 _; 的位置。</span></span><br><span class="line">    <span class="comment">// 这意味着如果是 owner 调用这个函数，则函数会被执行，否则会抛出异常。</span></span><br><span class="line">    modifier onlyOwner &#123;</span><br><span class="line">        <span class="built_in">require</span>(</span><br><span class="line">            msg.sender == owner,</span><br><span class="line">            <span class="string">"Only owner can call this function."</span></span><br><span class="line">        );</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract destructible is owned &#123;</span><br><span class="line">    <span class="comment">// 这个合约从 `owned` 继承了 `onlyOwner` 修饰符，并将其应用于 `destroy` 函数，</span></span><br><span class="line">    <span class="comment">// 只有在合约里保存的 owner 调用 `destroy` 函数，才会生效。</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">destroy</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">onlyOwner</span> </span>&#123;</span><br><span class="line">        selfdestruct(owner);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract priced &#123;</span><br><span class="line">    <span class="comment">// 修改器可以接收参数：</span></span><br><span class="line">    modifier costs(uint price) &#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.value &gt;= price) &#123;</span><br><span class="line">            _;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Register is priced, destructible &#123;</span><br><span class="line">    mapping (<span class="function"><span class="params">address</span> =&gt;</span> bool) registeredAddresses;</span><br><span class="line">    uint price;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(uint initialPrice) &#123; price = initialPrice; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在这里也使用关键字 `payable` 非常重要，否则函数会自动拒绝所有发送给它的以太币。</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">register</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">payable</span> <span class="title">costs</span>(<span class="params">price</span>) </span>&#123;</span><br><span class="line">        registeredAddresses[msg.sender] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">changePrice</span>(<span class="params">uint _price</span>) <span class="title">public</span> <span class="title">onlyOwner</span> </span>&#123;</span><br><span class="line">        price = _price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Mutex &#123;</span><br><span class="line">    bool locked;</span><br><span class="line">    modifier noReentrancy() &#123;</span><br><span class="line">        <span class="built_in">require</span>(</span><br><span class="line">            !locked,</span><br><span class="line">            <span class="string">"Reentrant call."</span></span><br><span class="line">        );</span><br><span class="line">        locked = <span class="literal">true</span>;</span><br><span class="line">        _;</span><br><span class="line">        locked = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个函数受互斥量保护，这意味着 `msg.sender.call` 中的重入调用不能再次调用  `f`。</span></span><br><span class="line">    <span class="comment">// `return 7` 语句指定返回值为 7，但修改器中的语句 `locked = false` 仍会执行。</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">noReentrancy</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">        (bool success,) = msg.sender.call(<span class="string">""</span>);</span><br><span class="line">        <span class="built_in">require</span>(success);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">7</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: GPL-3.0</span></span><br><span class="line">pragma solidity &gt;<span class="number">0.6</span><span class="number">.99</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    uint constant X = <span class="number">32</span>**<span class="number">22</span> + <span class="number">8</span>;</span><br><span class="line">    string constant TEXT = <span class="string">"abc"</span>;</span><br><span class="line">    bytes32 constant MY_HASH = keccak256(<span class="string">"abc"</span>);</span><br><span class="line">    uint immutable decimals;</span><br><span class="line">    uint immutable maxBalance;</span><br><span class="line">    address immutable owner = msg.sender;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(uint _decimals, address _reference) &#123;</span><br><span class="line">        decimals = _decimals;</span><br><span class="line">        <span class="comment">// Assignments to immutables can even access the environment.</span></span><br><span class="line">        maxBalance = _reference.balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">isBalanceTooHigh</span>(<span class="params">address _other</span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">bool</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _other.balance &gt; maxBalance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果状态变量声明为 <code>constant</code> (常量)。在这种情况下，只能使用那些在编译时有确定值的表达式来给它们赋值。 任何通过访问 storage，区块链数据（例如 <code>block.timestamp</code>, <code>address(this).balance</code> 或者 <code>block.number</code>）或执行数据（ <code>msg.value</code> 或 <code>gasleft()</code> ） 或对外部合约的调用来给它们赋值都是不允许的。</p><p>允许可能对内存分配产生副作用（side-effect）的表达式，但那些可能对其他内存对象产生副作用的表达式则不允许。</p><p>内建（built-in）函数 <code>keccak256</code> ， <code>sha256</code> ， <code>ripemd160</code> ， <code>ecrecover</code> ， <code>addmod</code> 和 <code>mulmod</code> 是允许的（即使他们确实会调用外部合约， <code>keccak256</code> 除外）。</p><p>允许内存分配器的副作用的原因是它可以构造复杂的对象，例如： 查找表（lookup-table）。 此功能尚不完全可用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: GPL-3.0</span></span><br><span class="line">pragma solidity &gt;<span class="number">0.8</span><span class="number">.0</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">uint[] memory _arr</span>) <span class="title">pure</span> <span class="title">returns</span> (<span class="params">uint s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; _arr.length; i++)</span><br><span class="line">        s += _arr[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract ArrayExample &#123;</span><br><span class="line">    bool found;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">uint[] memory _arr</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="comment">// This calls the free function internally.</span></span><br><span class="line">        <span class="comment">// The compiler will add its code to the contract.</span></span><br><span class="line">        uint s = sum(_arr);</span><br><span class="line">        <span class="built_in">require</span>(s &gt;= <span class="number">10</span>);</span><br><span class="line">        found = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=<span class="number">0.4</span><span class="number">.16</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract Simple &#123;</span><br><span class="line">    uint sum;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">taker</span>(<span class="params">uint _a, uint _b</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        sum = _a + _b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pragma solidity &gt;=<span class="number">0.4</span><span class="number">.16</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract Simple &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">arithmetic</span>(<span class="params">uint _a, uint _b</span>)</span></span><br><span class="line"><span class="function">        <span class="title">public</span></span></span><br><span class="line"><span class="function">        <span class="title">pure</span></span></span><br><span class="line"><span class="function">        <span class="title">returns</span> (<span class="params">uint o_sum, uint o_product</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        o_sum = _a + _b;</span><br><span class="line">        o_product = _a * _b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity  &gt;=<span class="number">0.5</span><span class="number">.0</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">uint a, uint b</span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a * (b + <span class="number">42</span>) + block.timestamp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Getter 方法自动被标记为 <code>view</code>。<code>constant</code> 之前是 <code>view</code> 的别名，不过在0.5.0之后移除了。函数可以声明为 <code>pure</code> ，在这种情况下，承诺不读取也不修改状态。</p><p>一个合约最多有一个 <code>receive</code> 函数, 声明函数为： <code>receive() external payable { ... }</code></p><p>不需要 <code>function</code> 关键字，也没有参数和返回值并且必须是　<code>external</code>　可见性和　<code>payable</code> 修饰． 在对合约没有任何附加数据调用（通常是对合约转账）是会执行 <code>receive</code> 函数．　例如　通过 <code>.send()</code> or <code>.transfer()</code> 如果 <code>receive</code> 函数不存在，　但是有payable　的 <a href="https://learnblockchain.cn/docs/solidity/contracts.html#fallback-function" target="_blank" rel="noopener">fallback 回退函数</a> 那么在进行纯以太转账时，fallback 函数会调用．</p><p>如果两个函数都没有，这个合约就没法通过常规的转账交易接收以太（会抛出异常）．</p><p>更糟的是，fallback函数可能只有 2300 gas 可以使用（如，当使用 <code>send</code> 或 <code>transfer</code> 时）， 除了基础的日志输出之外，进行其他操作的余地很小。下面的操作消耗会操作 2300 gas :</p><ul><li><p>写入存储</p></li><li><p>创建合约</p></li><li><p>调用消耗大量 gas 的外部函数</p></li><li><p>发送以太币</p></li></ul><p>一个没有定义 fallback 函数或　 receive 函数的合约，直接接收以太币（没有函数调用，即使用 <code>send</code> 或 <code>transfer</code>）会抛出一个异常， 并返还以太币（在 Solidity v0.4.0 之前行为会有所不同）。 所以如果你想让你的合约接收以太币，必须实现receive函数（使用 payable　fallback 函数不再推荐，因为它会让借口混淆）。 这个之前调试老版本的合约中出现过异常的情况。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=<span class="number">0.6</span><span class="number">.2</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    <span class="comment">// 发送到这个合约的所有消息都会调用此函数（因为该合约没有其它函数）。</span></span><br><span class="line">    <span class="comment">// 向这个合约发送以太币会导致异常，因为 fallback 函数没有 `payable` 修饰符</span></span><br><span class="line">    fallback() external &#123; x = <span class="number">1</span>; &#125;</span><br><span class="line">    uint x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个合约会保留所有发送给它的以太币，没有办法返还。</span></span><br><span class="line">contract TestPayable &#123;</span><br><span class="line">    <span class="comment">// 除了纯转账外，所有的调用都会调用这个函数．</span></span><br><span class="line">    <span class="comment">// (因为除了 receive 函数外，没有其他的函数).</span></span><br><span class="line">    <span class="comment">// 任何对合约非空calldata 调用会执行回退函数(即使是调用函数附加以太).</span></span><br><span class="line">    fallback() external payable &#123; x = <span class="number">1</span>; y = msg.value; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 纯转账调用这个函数，例如对每个空empty calldata的调用</span></span><br><span class="line">    receive() external payable &#123; x = <span class="number">2</span>; y = msg.value; &#125;</span><br><span class="line">    uint x;</span><br><span class="line">    uint y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Caller &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">callTest</span>(<span class="params">Test test</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">bool</span>) </span>&#123;</span><br><span class="line">        (bool success,) = address(test).call(abi.encodeWithSignature(<span class="string">"nonExistingFunction()"</span>));</span><br><span class="line">        <span class="built_in">require</span>(success);</span><br><span class="line">        <span class="comment">//  test.x 结果变成 == 1。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// address(test) 不允许直接调用 ``send`` ,  因为 ``test`` 没有 payable 回退函数</span></span><br><span class="line">        <span class="comment">//  转化为 ``address payable`` 类型 , 然后才可以调用 ``send``</span></span><br><span class="line">        address payable testPayable = payable(address(test));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以下将不会编译，但如果有人向该合约发送以太币，交易将失败并拒绝以太币。</span></span><br><span class="line">        <span class="comment">// test.send(2 ether）;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">callTestPayable</span>(<span class="params">TestPayable test</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">bool</span>) </span>&#123;</span><br><span class="line">        (bool success,) = address(test).call(abi.encodeWithSignature(<span class="string">"nonExistingFunction()"</span>));</span><br><span class="line">        <span class="built_in">require</span>(success);</span><br><span class="line">        <span class="comment">// 结果 test.x 为 1  test.y 为 0.</span></span><br><span class="line">        (success,) = address(test).call&#123;<span class="attr">value</span>: <span class="number">1</span>&#125;(abi.encodeWithSignature(<span class="string">"nonExistingFunction()"</span>));</span><br><span class="line">        <span class="built_in">require</span>(success);</span><br><span class="line">        <span class="comment">// 结果test.x 为1 and test.y 为 1.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送以太币, TestPayable 的 receive　函数被调用．</span></span><br><span class="line">        <span class="built_in">require</span>(address(test).send(<span class="number">2</span> ether));</span><br><span class="line">        <span class="comment">// 结果 in test.x 为 2 and test.y 为 2 ether.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">    fromBlock: <span class="number">0</span>,</span><br><span class="line">    address: web3.eth.defaultAccount,</span><br><span class="line">    topics: [<span class="string">"0x0000000000000000000000000000000000000000000000000000000000000000"</span>, <span class="literal">null</span>, <span class="literal">null</span>]</span><br><span class="line">&#125;;</span><br><span class="line">web3.eth.subscribe(<span class="string">'logs'</span>, options, <span class="function"><span class="keyword">function</span> (<span class="params">error, result</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!error)</span><br><span class="line">        <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;)</span><br><span class="line">    .on(<span class="string">"data"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">log</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(log);</span><br><span class="line">    &#125;)</span><br><span class="line">    .on(<span class="string">"changed"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">log</span>) </span>&#123;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>关于web3 subscribe的描述</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=<span class="number">0.4</span><span class="number">.10</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">payable</span> </span>&#123;</span><br><span class="line">        bytes32 _id = <span class="number">0x420042</span>;</span><br><span class="line">        log3(</span><br><span class="line">            bytes32(msg.value),</span><br><span class="line">            bytes32(<span class="number">0x50cb9fe53daa9737b786ab3646f04d0150dc50ef4e75f59509d83667ad5adb20</span>),</span><br><span class="line">            bytes32(msg.sender),</span><br><span class="line">            _id</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>日志的底层接口</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// SPDX-License-Identifier: GPL-3.0</span></span><br><span class="line">   pragma solidity &gt;<span class="number">0.6</span><span class="number">.99</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">   contract Owned &#123;</span><br><span class="line">       <span class="keyword">constructor</span>() public &#123; owner = msg.sender; &#125;</span><br><span class="line">       address payable owner;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 使用 is 从另一个合约派生。派生合约可以访问所有非私有成员，包括内部（internal）函数和状态变量，</span></span><br><span class="line">   <span class="comment">// 但无法通过 this 来外部访问。</span></span><br><span class="line">   contract Destructible is Owned &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关键字`virtual`表示该函数可以在派生类中“overriding”。</span></span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">function</span> <span class="title">destroy</span>(<span class="params"></span>) <span class="title">virtual</span> <span class="title">public</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (msg.sender == owner) selfdestruct(owner);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 这些抽象合约仅用于给编译器提供接口。</span></span><br><span class="line">   <span class="comment">// 注意函数没有函数体。</span></span><br><span class="line">   <span class="comment">// 如果一个合约没有实现所有函数，则只能用作接口。</span></span><br><span class="line">   abstract contract Config &#123;</span><br><span class="line">       <span class="function"><span class="keyword">function</span> <span class="title">lookup</span>(<span class="params">uint id</span>) <span class="title">public</span> <span class="title">virtual</span> <span class="title">returns</span> (<span class="params">address adr</span>);</span></span><br><span class="line"><span class="function">   &#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">   <span class="title">abstract</span> <span class="title">contract</span> <span class="title">NameReg</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">function</span> <span class="title">register</span>(<span class="params">bytes32 name</span>) <span class="title">public</span> <span class="title">virtual</span>;</span></span><br><span class="line"><span class="function">       <span class="title">function</span> <span class="title">unregister</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">virtual</span>;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">   // 可以多重继承。请注意，<span class="title">owned</span> 也是 <span class="title">Destructible</span> 的基类，</span></span><br><span class="line"><span class="function">   // 但只有一个 <span class="title">owned</span> 实例（就像 <span class="title">C</span>++ 中的虚拟继承）。</span></span><br><span class="line"><span class="function">   <span class="title">contract</span> <span class="title">Named</span> <span class="title">is</span> <span class="title">Owned</span>, <span class="title">Destructible</span> </span>&#123;</span><br><span class="line">       <span class="keyword">constructor</span>(bytes32 name) &#123;</span><br><span class="line">           Config config = Config(<span class="number">0xD5f9D8D94886E70b06E474c3fB14Fd43E2f23970</span>);</span><br><span class="line">           NameReg(config.lookup(<span class="number">1</span>)).register(name);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 函数可以被另一个具有相同名称和相同数量/类型输入的函数重载。</span></span><br><span class="line">       <span class="comment">// 如果重载函数有不同类型的输出参数，会导致错误。</span></span><br><span class="line">       <span class="comment">// 本地和基于消息的函数调用都会考虑这些重载。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果要覆盖函数，则需要使用 `override` 关键字。 如果您想再次覆盖此函数，则需要再次指定`virtual`关键字。</span></span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">function</span> <span class="title">destroy</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">virtual</span> <span class="title">override</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (msg.sender == owner) &#123;</span><br><span class="line">               Config config = Config(<span class="number">0xD5f9D8D94886E70b06E474c3fB14Fd43E2f23970</span>);</span><br><span class="line">               NameReg(config.lookup(<span class="number">1</span>)).unregister();</span><br><span class="line">               <span class="comment">// 仍然可以调用特定的重载函数。</span></span><br><span class="line">               Destructible.destroy();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果构造函数接受参数，</span></span><br><span class="line">   <span class="comment">// 则需要在声明（合约的构造函数）时提供，</span></span><br><span class="line">   <span class="comment">// 或在派生合约的构造函数位置以修改器调用风格提供（见下文）。</span></span><br><span class="line">   contract PriceFeed is Owned, Destructible, Named(<span class="string">"GoldFeed"</span>) &#123;</span><br><span class="line">       <span class="function"><span class="keyword">function</span> <span class="title">updateInfo</span>(<span class="params">uint newInfo</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (msg.sender == owner) info = newInfo;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Here, we only specify `override` and not `virtual`.</span></span><br><span class="line">       <span class="comment">// This means that contracts deriving from `PriceFeed`</span></span><br><span class="line">       <span class="comment">// cannot change the behaviour of `destroy` anymore.</span></span><br><span class="line">       <span class="function"><span class="keyword">function</span> <span class="title">destroy</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">override</span>(<span class="params">Destructible, Named</span>) </span>&#123; Named.destroy(); &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span>(<span class="params">uint r</span>) </span>&#123; <span class="keyword">return</span> info; &#125;</span><br><span class="line"></span><br><span class="line">       uint info;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>父合约标记为 <code>virtual</code> 函数可以在继承合约里重写(overridden)以更改他们的行为。重写的函数需要使用关键字 <code>override</code> 修饰。</p><p>重写函数只能将覆盖函数的可见性从 <code>external</code> 更改为 <code>public</code> 。</p><p>可变性可以按照以下顺序更改为更严格的一种： <code>nonpayable</code> 可以被 <code>view</code> 和 <code>pure</code> 覆盖。 <code>view</code> 可以被 <code>pure</code> 覆盖。 <code>payable</code> 是一个例外，不能更改为任何其他可变性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: GPL-3.0</span></span><br><span class="line">pragma solidity &gt;<span class="number">0.6</span><span class="number">.99</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) <span class="title">virtual</span> <span class="title">external</span> <span class="title">view</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Middle is Base &#123;&#125;</span><br><span class="line"></span><br><span class="line">contract Inherited is Middle</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) <span class="title">override</span> <span class="title">public</span> <span class="title">pure</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pragma solidity &gt;=<span class="number">0.6</span><span class="number">.0</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract Base1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) <span class="title">virtual</span> <span class="title">public</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Base2</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) <span class="title">virtual</span> <span class="title">public</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Inherited is Base1, Base2</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 继承自两个基类合约定义的foo(), 必须显示的指定 override</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">override</span>(<span class="params">Base1, Base2</span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口类似于抽象合约，但是它们不能实现任何函数。还有进一步的限制：</p><ul><li>无法继承其他合约,不过可以继承其他接口。</li><li>所有的函数都需要是 external</li><li>无法定义构造函数。</li><li>无法定义状态变量。</li></ul><p>将来可能会解除这里的某些限制。</p><p>接口基本上基本上仅限于合约 ABI 可以表示的内容，并且 ABI 和接口之间的转换应该不会丢失任何信息。</p><p>接口由它们自己的关键字表示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=<span class="number">0.6</span><span class="number">.2</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">interface Token &#123;</span><br><span class="line">    enum TokenType &#123; Fungible, NonFungible &#125;</span><br><span class="line">    struct Coin &#123; string obverse; string reverse; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">transfer</span>(<span class="params">address recipient, uint amount</span>) <span class="title">external</span>;</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">//-------</span></span><br><span class="line"><span class="function"><span class="title">pragma</span> <span class="title">solidity</span> &gt;=0.6.2 &lt;0.8.0;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">interface</span> <span class="title">ParentA</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) <span class="title">external</span> <span class="title">returns</span> (<span class="params">uint256</span>);</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">interface</span> <span class="title">ParentB</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) <span class="title">external</span> <span class="title">returns</span> (<span class="params">uint256</span>);</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">interface</span> <span class="title">SubInterface</span> <span class="title">is</span> <span class="title">ParentA</span>, <span class="title">ParentB</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 必须重新定义 test 函数，以表示兼容父合约含义</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) <span class="title">external</span> <span class="title">override</span>(<span class="params">ParentA, ParentB</span>) <span class="title">returns</span> (<span class="params">uint256</span>);</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>就像继承其他合约一样，合约可以继承接口。接口中的函数都会隐式的标记为 <code>virtual</code> ，意味着他们会被重写。 但是不表示重写（overriding）函数可以再次重写，仅仅当重写的函数标记为 <code>virtual</code> 才可以再次重写。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=<span class="number">0.6</span><span class="number">.0</span> &lt;<span class="number">0.7</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 我们定义了一个新的结构体数据类型，用于在调用合约中保存数据。</span></span><br><span class="line">  struct Data &#123;</span><br><span class="line">    mapping(<span class="function"><span class="params">uint</span> =&gt;</span> bool) flags;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">library <span class="built_in">Set</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注意第一个参数是“storage reference”类型，因此在调用中参数传递的只是它的存储地址而不是内容。</span></span><br><span class="line">  <span class="comment">// 这是库函数的一个特性。如果该函数可以被视为对象的方法，则习惯称第一个参数为 `self` 。</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params">Data storage self, uint value</span>)</span></span><br><span class="line"><span class="function">      <span class="title">public</span></span></span><br><span class="line"><span class="function">      <span class="title">returns</span> (<span class="params">bool</span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (self.flags[value])</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 已经存在</span></span><br><span class="line">      self.flags[value] = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params">Data storage self, uint value</span>)</span></span><br><span class="line"><span class="function">      <span class="title">public</span></span></span><br><span class="line"><span class="function">      <span class="title">returns</span> (<span class="params">bool</span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!self.flags[value])</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 不存在</span></span><br><span class="line">      self.flags[value] = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">contains</span>(<span class="params">Data storage self, uint value</span>)</span></span><br><span class="line"><span class="function">      <span class="title">public</span></span></span><br><span class="line"><span class="function">      <span class="title">view</span></span></span><br><span class="line"><span class="function">      <span class="title">returns</span> (<span class="params">bool</span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> self.flags[value];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    Data knownValues;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">register</span>(<span class="params">uint value</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 不需要库的特定实例就可以调用库函数，</span></span><br><span class="line">        <span class="comment">// 因为当前合约就是“instance”。</span></span><br><span class="line">        <span class="built_in">require</span>(<span class="built_in">Set</span>.insert(knownValues, value));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果我们愿意，我们也可以在这个合约中直接访问 knownValues.flags。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个我们没咋个看到过</p><h4 id="合约元数据"><a href="#合约元数据" class="headerlink" title="合约元数据"></a>合约元数据</h4><p>Solidity编译器自动生成JSON文件，即合约的元数据，其中包含了当前合约的相关信息。 它可以用于查询编译器版本，所使用的源代码，<a href="https://learnblockchain.cn/docs/solidity/metadata.html#id5" target="_blank" rel="noopener">|ABI|</a> 和 <a href="https://learnblockchain.cn/docs/solidity/metadata.html#id7" target="_blank" rel="noopener">|natspec|</a> 文档，以便更安全地与合约进行交互并验证其源代码。</p><p>编译器会将元数据文件的 Swarm 哈希值附加到每个合约的字节码末尾（详情请参阅下文）， 以便你可以以认证的方式获取该文件，而不必求助于中心化的数据提供者。</p><p>当然，你必须将元数据文件发布到 Swarm （或其他服务），以便其他人可以访问它。 该文件可以通过使用 <code>solc --metadata</code> 来生成，并被命名为 <code>ContractName_meta.json</code> 。 它将包含源代码的在 Swarm 上的引用，因此你必须上传所有源文件和元数据文件。</p><p>元数据文件具有以下格式。 下面的例子将以人类可读的方式呈现。 正确格式化的元数据应正确使用引号，将空白减少到最小，并对所有对象的键值进行排序以得到唯一的格式。 代码注释当然也是不允许的，这里仅用于解释目的。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // 必选：元数据格式的版本</span><br><span class="line">  version: "1",</span><br><span class="line">  // 必选：源代码的编程语言，一般会选择规范的“子版本”</span><br><span class="line">  language: "Solidity",</span><br><span class="line">  // 必选：编译器的细节，内容视语言而定。</span><br><span class="line">  compiler: &#123;</span><br><span class="line">    // 对 Solidity 来说是必须的：编译器的版本</span><br><span class="line">    version: "0.4.6+commit.2dabbdf0.Emscripten.clang",</span><br><span class="line">    // 可选： 生成此输出的编译器二进制文件的哈希值</span><br><span class="line">    keccak256: "0x123..."</span><br><span class="line">  &#125;,</span><br><span class="line">  // 必选：编译的源文件／源单位，键值为文件名</span><br><span class="line">  sources:</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"myFile.sol"</span>: &#123;</span><br><span class="line">      // 必选：源文件的 keccak256 哈希值</span><br><span class="line">      "keccak256": "0x123...",</span><br><span class="line">      // 必选（除非定义了“content”，详见下文）：</span><br><span class="line">      // 已排序的源文件的URL，URL的协议可以是任意的，但建议使用 Swarm 的URL</span><br><span class="line">      "urls": [ "bzzr://56ab..." ]</span><br><span class="line">      // Optional: 在源文件中定义的 SPDX license 标识</span><br><span class="line">      "license": "MIT"</span><br><span class="line">    &#125;,</span><br><span class="line">    "mortal": &#123;</span><br><span class="line">      // 必选：源文件的 keccak256 哈希值</span><br><span class="line">      "keccak256": "0x234...",</span><br><span class="line">      // 必选（除非定义了“urls”）： 源文件的字面内容</span><br><span class="line">      "content": "contract mortal is owned &#123; function kill() &#123; if (msg.sender == owner) selfdestruct(owner); &#125; &#125;"</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  // 必选：编译器的设置</span><br><span class="line">  settings:</span><br><span class="line">  &#123;</span><br><span class="line">    // 对 Solidity 来说是必须的： 已排序的重定向列表</span><br><span class="line">    remappings: [ ":g/dir" ],</span><br><span class="line">    // 可选： 优化器的设置（ enabled 默认设为 false ）</span><br><span class="line">    optimizer: &#123;</span><br><span class="line">      enabled: true,</span><br><span class="line">      runs: 500,</span><br><span class="line">      details: &#123;</span><br><span class="line">        // peephole defaults to "true"</span><br><span class="line">        peephole: true,</span><br><span class="line">        // jumpdestRemover defaults to "true"</span><br><span class="line">        jumpdestRemover: true,</span><br><span class="line">        orderLiterals: false,</span><br><span class="line">        deduplicate: false,</span><br><span class="line">        cse: false,</span><br><span class="line">        constantOptimizer: false,</span><br><span class="line">        yul: true,</span><br><span class="line">        // Optional: Only present if "yul" is "true"</span><br><span class="line">        yulDetails: &#123;</span><br><span class="line">          stackAllocation: false,</span><br><span class="line">          optimizerSteps: "dhfoDgvulfnTUtnIf..."</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  metadata: &#123;</span><br><span class="line">      // Reflects the setting used in the input json, defaults to false</span><br><span class="line">      useLiteralContent: true,</span><br><span class="line">      // Reflects the setting used in the input json, defaults to "ipfs"</span><br><span class="line">      bytecodeHash: "ipfs"</span><br><span class="line">    &#125;</span><br><span class="line">    // Required for Solidity: File and name of the contract or library this</span><br><span class="line">    // metadata is created for.</span><br><span class="line">    compilationTarget: &#123;</span><br><span class="line">      "myFile.sol": "MyContract"</span><br><span class="line">    &#125;,</span><br><span class="line">    // Required for Solidity: Addresses for libraries used</span><br><span class="line">    libraries: &#123;</span><br><span class="line">      "MyLib": "0x123123..."</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  // 必选：合约的生成信息</span><br><span class="line">  output:</span><br><span class="line">  &#123;</span><br><span class="line">    // 必选：合约的 ABI 定义</span><br><span class="line">    abi: [ ... ],</span><br><span class="line">    // 必选：合约的 NatSpec 用户文档</span><br><span class="line">    userdoc: [ ... ],</span><br><span class="line">    // 必选：合约的 NatSpec 开发者文档</span><br><span class="line">    devdoc: [ ... ],</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于生成的合约的字节码包含元数据的哈希值，因此对元数据的任何更改都会导致字节码的更改。 此外，由于元数据包含所有使用的源代码的哈希值，所以任何源代码中的， 哪怕是一个空格的变化都将导致不同的元数据，并随后产生不同的字节代码。需注意，上面的 ABI 没有固定的顺序，随编译器的版本而不同。尽管从 Solidity 0.5.12 开始，数组保持了一定的顺序。</p><h4 id="源代码验证方法"><a href="#源代码验证方法" class="headerlink" title="源代码验证方法"></a>源代码验证方法</h4><p>为了验证编译，可以通过元数据文件中的链接从 Swarm 中获取源代码。 获取到的源码，会根据元数据中指定的设置，被正确版本的编译器（应该为“官方”编译器之一）所处理。 处理得到的字节码会与创建交易的数据或者 <code>CREATE</code> 操作码使用的数据进行比较。 这会自动验证元数据，因为它的哈希值是字节码的一部分。 而额外的数据，则是与基于接口进行编码并展示给用户的构造输入数据相符的。</p><h4 id="ABI"><a href="#ABI" class="headerlink" title="ABI"></a>ABI</h4><p>在 以太坊Ethereum 生态系统中， 应用二进制接口Application Binary Interface(ABI) 是从区块链外部与合约进行交互以及合约与合约间进行交互的一种标准方式。 数据会根据其类型按照这份手册中说明的方法进行编码。这种编码并不是可以自描述的，而是需要一种特定的概要（schema）来进行解码。</p><p>除了 元组tuple 以外，Solidity 支持以上所有类型的名称。ABI 元组tuple 是利用 Solidity 的 <code>structs</code> 编码得到的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.16</span>;</span><br><span class="line"></span><br><span class="line">contract Foo &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">bytes3[<span class="number">2</span>]</span>) <span class="title">public</span> <span class="title">pure</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params">uint32 x, bool y</span>) <span class="title">public</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">bool r</span>) </span>&#123; r = x &gt; <span class="number">32</span> || y; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">sam</span>(<span class="params">bytes, bool, uint[]</span>) <span class="title">public</span> <span class="title">pure</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，对于我们的例子 <code>Foo</code>，如果我们想用 <code>69</code> 和 <code>true</code> 做参数调用 <code>baz</code>，我们总共需要传送 68 字节，可以分解为：</p><ul><li><code>0xcdcd77c0</code>：方法ID。这源自ASCII格式的 <code>baz(uint32,bool)</code> 签名的 Keccak 哈希的前 4 字节。</li><li><code>0x0000000000000000000000000000000000000000000000000000000000000045</code>：第一个参数，一个被用 0 值字节补充到 32 字节的 uint32 值 <code>69</code>。</li><li><code>0x0000000000000000000000000000000000000000000000000000000000000001</code>：第二个参数，一个被用 0 值字节补充到 32 字节的 boolean 值 <code>true</code>。</li></ul><p>合起来就是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0xcdcd77c000000000000000000000000000000000000000000000000000000000000000450000000000000000000000000000000000000000000000000000000000000001</span><br></pre></td></tr></table></figure><p>它返回一个 <code>bool</code>。比如它返回 <code>false</code>，那么它的输出将是一个字节数组 <code>0x0000000000000000000000000000000000000000000000000000000000000000</code>，一个bool值。</p><p>事件，是 以太坊Ethereum 的日志/事件监视协议的一个抽象。日志项提供了合约的地址、一系列的主题（最高 4 项）和一些任意长度的二进制数据。为了使用合适的类型数据结构来演绎这些功能（与接口定义一起），事件沿用了既存的 ABI 函数。</p><p>给定了事件名称和事件参数之后，我们将其分解为两个子集：已索引的和未索引的。已索引的部分，最多有 3 个，被用来与事件签名的 Keccak 哈希一起组成日志项的主题。未索引的部分就组成了事件的字节数组。</p><p>一个事件描述是一个有极其相似字段的 JSON 对象：</p><ul><li><p><code>type</code>：总是 <code>&quot;event&quot;</code>；</p></li><li><p><code>name</code>：事件名称；</p></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inputs</span><br></pre></td></tr></table></figure><p>：对象数组，每个数组对象会包含：</p><ul><li><code>name</code>：参数名称；</li><li><code>type</code>：参数的权威类型（相见下文）；</li><li><code>components</code>：供 元组tuple 类型使用（详见下文）；</li><li><code>indexed</code>：如果此字段是日志的一个主题，则为 <code>true</code>；否则为 <code>false</code>。</li></ul></li><li><p><code>anonymous</code>：如果事件被声明为 <code>anonymous</code>，则为 <code>true</code>。</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: GPL-3.0</span></span><br><span class="line">pragma solidity &gt;<span class="number">0.6</span><span class="number">.99</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123; b = <span class="number">0x12345678901234567890123456789012</span>; &#125;</span><br><span class="line">  event Event(uint indexed a, bytes32 b);</span><br><span class="line">  event Event2(uint indexed a, bytes32 b);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">uint a</span>) <span class="title">public</span> </span>&#123; Event(a, b); &#125;</span><br><span class="line">  bytes32 b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[&#123;</span><br><span class="line"><span class="attr">"type"</span>:<span class="string">"event"</span>,</span><br><span class="line"><span class="attr">"inputs"</span>: [&#123;<span class="attr">"name"</span>:<span class="string">"a"</span>,<span class="attr">"type"</span>:<span class="string">"uint256"</span>,<span class="attr">"indexed"</span>:<span class="literal">true</span>&#125;,&#123;<span class="attr">"name"</span>:<span class="string">"b"</span>,<span class="attr">"type"</span>:<span class="string">"bytes32"</span>,<span class="attr">"indexed"</span>:<span class="literal">false</span>&#125;],</span><br><span class="line"><span class="attr">"name"</span>:<span class="string">"Event"</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line"><span class="attr">"type"</span>:<span class="string">"event"</span>,</span><br><span class="line"><span class="attr">"inputs"</span>: [&#123;<span class="attr">"name"</span>:<span class="string">"a"</span>,<span class="attr">"type"</span>:<span class="string">"uint256"</span>,<span class="attr">"indexed"</span>:<span class="literal">true</span>&#125;,&#123;<span class="attr">"name"</span>:<span class="string">"b"</span>,<span class="attr">"type"</span>:<span class="string">"bytes32"</span>,<span class="attr">"indexed"</span>:<span class="literal">false</span>&#125;],</span><br><span class="line"><span class="attr">"name"</span>:<span class="string">"Event2"</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line"><span class="attr">"type"</span>:<span class="string">"function"</span>,</span><br><span class="line"><span class="attr">"inputs"</span>: [&#123;<span class="attr">"name"</span>:<span class="string">"a"</span>,<span class="attr">"type"</span>:<span class="string">"uint256"</span>&#125;],</span><br><span class="line"><span class="attr">"name"</span>:<span class="string">"foo"</span>,</span><br><span class="line"><span class="attr">"outputs"</span>: []</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>Solidity的合约开始真正的意义上的普及还需要一些时间，但是对于真正的使用，还是相当的有意思。</p><p>接下来的使用中，在一步一步更新这个文档，感觉solidity蛮有意思的。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Nov 02 2020 15:59:06 GMT+0900 (Japan Standard Time) --&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;做区块链相关的创业已经有4年了，都是做ETL方面的，对于真正的合约以及Trading，其实没有真正的使用，技术就是这样，用了就会发现有意思，从最早的没有信仰，到现在的信心满满，虽然BTC的价格还是3年前BTC的价格，但是市场已经今非昔比了，从DEFI的火热，到各种POOL的出现，区块链的运营方式和目标人群都巨大的变化了。在大经济形势周期的转变下，我也从数据，转战到了DEFI，因为DEFI才是代表了未来真正的放下，大环境下，随着疫情，越来越多的政府和国家地区更深入的隔绝，对于崇尚自由的人来说，我们更应该获得真正意义上的金融自由。虽然现在Blockchain还是被美帝把持着。&lt;/p&gt;&lt;p&gt;闲话不多说，我们开始真正的来玩转合约，合约从Ether起，也和Ether的创始团队息息相关，从V神，还有WOOD博士开始，Ether的出现也带来了Solidity和Vyper,智能合约语言，目前来看Vyper更安全，而Solidity使用更广泛，本文主要讲Solidity的开发和使用。&lt;/p&gt;&lt;p&gt;Solidity文档： &lt;a href=&quot;https://learnblockchain.cn/docs/solidity/introduction-to-smart-contracts.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://learnblockchain.cn/docs/solidity/introduction-to-smart-contracts.html&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/images/solidity.jpeg&quot; alt=&quot;Solidity&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="blockchain" scheme="http://yangxinqi.com/categories/blockchain/"/>
    
    
      <category term="solidity" scheme="http://yangxinqi.com/tags/solidity/"/>
    
  </entry>
  
  <entry>
    <title>梯子教程简版</title>
    <link href="http://yangxinqi.com/2020/11/02/%E6%A2%AF%E5%AD%90%E6%95%99%E7%A8%8B%E7%AE%80%E7%89%88/"/>
    <id>http://yangxinqi.com/2020/11/02/梯子教程简版/</id>
    <published>2020-11-02T02:51:44.000Z</published>
    <updated>2020-11-02T03:00:23.294Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Nov 02 2020 15:59:06 GMT+0900 (Japan Standard Time) --><p>本篇文章，详细写了关于在海外如何翻回看片，以及如何在国内翻出去自由上网的过程。 希望大家一个便宜且安全的私有梯子。 这篇是欠商神的文章，还上。</p><p>又到1年一度的双11，其他的没有买，买和续费VPS是当务之急，在买中，如何搭建自己私有的梯子，也是蛮好玩的。 对于娃翻墙回国学习，还是大人看国内的节目，或者是翻出来找资料，看youtube等等，都需要，所以本次做了分享，其实就是很简单的docker启动，以及配置防火墙的过程，其实对于IT认识而言，非常的简单。 可以尝试下，推荐使用。</p><p><img src="/images/v2ray-logo.jpg" alt="V2 ra y"></p><a id="more"></a><h4 id="GFW的认识"><a href="#GFW的认识" class="headerlink" title="GFW的认识"></a>GFW的认识</h4><p>首先，需要对GFW要有强大的认识，因为有了GFW，才能保证稳定，还有就是基于版权的保护，会有地域性质的版权限制，但是对于大部分的海外国人来说，希望身在海外也能够看到国内的内容， 那么我们应该如何解决呢？</p><h4 id="梯子服务商"><a href="#梯子服务商" class="headerlink" title="梯子服务商"></a>梯子服务商</h4><p>对于服务商，一定要选择网络快而价格低的，本次给大家推荐：</p><p>C2O： 中国翻海外，第一推荐： Google Cloud , Region选择 taiwan ， 台湾节点是目前在国内最稳定和最快速的海外访问节点。</p><p>O2C: 海外翻中国， 第一推荐： ALi Cloud, region选择 qingdao， 青岛是国内3大光仟出口之一，其他的2个上海和广州那边早已人满为患了，青岛作为还未开发的一个口，目前来看速度最快，而且稳定。 强烈推荐。</p><h4 id="购买时机"><a href="#购买时机" class="headerlink" title="购买时机"></a>购买时机</h4><p>一，Google Cloud: 对于Google Cloud 本身有免费的300美元的额度，可以先使用信用卡开试用账户，然后免费用3个月，之后自动会被转成收费的账户。 系统配置的话，使用</p><p>2core 2G 的足够了，每个月费用在$10以内，速度和性能都还不错，可惜只能免费3个月，之后就是收费的了。</p><p>二，Ali Cloud: 阿里云，正直双11又要到了，可以一次性买3年的， 2Core 4G 的共享5M，3年的价格在1200 左右，不知道今年的价格是多少？ 平均每年在400左右，而且速度很稳定，需要使用阿里云的新账户去抢购。 一个机器解决3年的使用也蛮好。经过速度测试，5M的基本看国内的爱奇艺，腾讯视频，4K基本也不卡, 强烈推荐。</p><h4 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h4><p>梯子买好了之后，需要开始部署，这里推荐使用 V2Ray来搭建。</p><p>Mac 下客户端，使用 V2RayU ， Windows上，还是推荐使用官方的V2Ray相关客户端，手机上 SuperWingy （iOS），v2RayNG (Android).</p><p>搭建步骤：</p><p>1.登录机器安装docker和docker-compose,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ssh ubuntu@xxxx.xxxx.xxx.xxx </span><br><span class="line"></span><br><span class="line">sudo apt-get install -y docker.io</span><br><span class="line">sudo curl -L &quot;https://github.com/docker/compose/releases/download/1.26.2/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose</span><br><span class="line">sudo chmod +x /usr/local/bin/docker-compose</span><br><span class="line">sudo usermod -aG docker $USER</span><br></pre></td></tr></table></figure><p>2.克隆项目到机器上，并修改自己的端口和 uuid 码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/ </span><br><span class="line"><span class="built_in">pwd</span>  <span class="comment">### 这里显示 /home/ubuntu/freeman/ 这里路径不对的话，需要修改docker-compose.yml中的配置文件的位置。 </span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/xinqiyang/freeman</span><br><span class="line"><span class="built_in">cd</span> freemain/docker</span><br><span class="line"></span><br><span class="line">vi v2ray/config.json    <span class="comment">### 这里修改你自己的端口和密码 </span></span><br><span class="line"><span class="comment">### 修改的配置的内容</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"inbounds"</span>: [&#123;</span><br><span class="line">    <span class="string">"port"</span>: 32026,  <span class="comment">### 这里是你的端口号，推荐修改到10000 以上的，降低被ban的概率</span></span><br><span class="line">    <span class="string">"protocol"</span>: <span class="string">"vmess"</span>,</span><br><span class="line">    <span class="string">"settings"</span>: &#123;</span><br><span class="line">      <span class="string">"clients"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">"id"</span>: <span class="string">"4dde0eaf-9e30-442a-b29e-7eb29837b802"</span>,  <span class="comment">#### 自己的唯一的UUID </span></span><br><span class="line">          <span class="string">"level"</span>: 1,</span><br><span class="line">          <span class="string">"alterId"</span>: 64</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;],</span><br><span class="line">  <span class="string">"outbounds"</span>: [&#123;</span><br><span class="line">    <span class="string">"protocol"</span>: <span class="string">"freedom"</span>,</span><br><span class="line">    <span class="string">"settings"</span>: &#123;&#125;</span><br><span class="line">  &#125;,&#123;</span><br><span class="line">    <span class="string">"protocol"</span>: <span class="string">"blackhole"</span>,</span><br><span class="line">    <span class="string">"settings"</span>: &#123;&#125;,</span><br><span class="line">    <span class="string">"tag"</span>: <span class="string">"blocked"</span></span><br><span class="line">  &#125;],</span><br><span class="line">  <span class="string">"routing"</span>: &#123;</span><br><span class="line">    <span class="string">"rules"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"type"</span>: <span class="string">"field"</span>,</span><br><span class="line">        <span class="string">"ip"</span>: [<span class="string">"geoip:private"</span>],</span><br><span class="line">        <span class="string">"outboundTag"</span>: <span class="string">"blocked"</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">### 修改配置结束 :q 退出</span></span><br></pre></td></tr></table></figure><p>3.启动docker，开始服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d </span><br><span class="line">docker ps </span><br><span class="line"><span class="comment">### 看到以下的在跑着，说明启动成功， 这里使用32026 端口，需要去开启防火墙配置</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                      NAMES</span><br><span class="line">8a541b029756        jrohy/v2ray         <span class="string">"./run.sh"</span>          2 months ago        Up 7 days           0.0.0.0:32026-&gt;32026/tcp   v2ray_mritdv2ray_1</span><br></pre></td></tr></table></figure><p>4.打开VPS的安全设置的防火墙端口，即可配置客户端开始使用。</p><p>这里根据自己的账户，在网络设置里面 启动 32026 端口的防火墙，修改状态为 开启状态 即可。</p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>配置客户端的链接,我这里选用v2rayU的配置文件，大家在其他客户端中，只要提供 ip, uuid , level , alterId即可。</p><p>连上之后，打开 ipip.net 查看自己的ip是否为当前的代理ip，看看能否成功。</p><h4 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h4><p>其实国内的在线教育资源，学习资源都超级好，我个人感觉有娃的更应该搭建一个，方便孩子学习中文及英语相关内容。</p><p>对于互联网上的各位，要翻墙出来的，也推荐下。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Nov 02 2020 15:59:06 GMT+0900 (Japan Standard Time) --&gt;&lt;p&gt;本篇文章，详细写了关于在海外如何翻回看片，以及如何在国内翻出去自由上网的过程。 希望大家一个便宜且安全的私有梯子。 这篇是欠商神的文章，还上。&lt;/p&gt;&lt;p&gt;又到1年一度的双11，其他的没有买，买和续费VPS是当务之急，在买中，如何搭建自己私有的梯子，也是蛮好玩的。 对于娃翻墙回国学习，还是大人看国内的节目，或者是翻出来找资料，看youtube等等，都需要，所以本次做了分享，其实就是很简单的docker启动，以及配置防火墙的过程，其实对于IT认识而言，非常的简单。 可以尝试下，推荐使用。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/images/v2ray-logo.jpg&quot; alt=&quot;V2 ra y&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="other" scheme="http://yangxinqi.com/categories/other/"/>
    
    
      <category term="other, v2ray" scheme="http://yangxinqi.com/tags/other-v2ray/"/>
    
  </entry>
  
  <entry>
    <title>Oracle协议比较分析-Band vs Chainlink</title>
    <link href="http://yangxinqi.com/2020/10/20/Oracle%E5%8D%8F%E8%AE%AE%E6%AF%94%E8%BE%83%E5%88%86%E6%9E%90-Band-vs-Chainlink/"/>
    <id>http://yangxinqi.com/2020/10/20/Oracle协议比较分析-Band-vs-Chainlink/</id>
    <published>2020-10-20T02:26:02.000Z</published>
    <updated>2020-10-20T04:52:57.542Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Nov 02 2020 15:59:06 GMT+0900 (Japan Standard Time) --><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近项目中需要使用到Oracle,对价格进行更新，找了一圈市面上的，发现Band和Chainlink，对Chainlink的比价深有体会，遂开始深入研究下Oracle的实现机制，以及如何讲现实世界中的数据和API链接到智能合约中。 以下主要是翻译了SmartContent写的Band协议和Chainlink的对比分析的文章， 原文地址： <a href="https://medium.com/@smartcontentpublication/a-comparative-analysis-of-band-protocol-and-chainlink-54b7d14823b5" target="_blank" rel="noopener">https://medium.com/@smartcontentpublication/a-comparative-analysis-of-band-protocol-and-chainlink-54b7d14823b5</a> ，对文章进行了翻译和补充，基本使用Google翻译进行简要的翻译，可以当成一篇PR稿文章，主要从几个维度，比如 数据质量，随机性以来，采纳指标，资源效率和网络设计，团队，去中心化和多链支持等各个方面，对Band和Chainlink进行了比较，结果都是Chainlink胜出了。</p><p>大杨个人意见，看过Band的创始团队和背后的投资机构，都是相当有前景，而且Oracle语言机的盈利模式上都是平台方来撮合数据需求方和提供方调用，然后支付方式都是用平台的虚拟币支付，这样的方式其实也带来了很大不确定性，随着平台方币价的上涨，也带来了需求方很大的调用成本，本身现在公开的调用方式，实时性也不好，如果采用较为实时的解决方案，那么使用LINK代币来支付的费用，换算成法币的话，也是非常高的。从文章从可以看到的是Band协议V2，依赖于与Cosmos, 而且很区块链化，对于用户的直接引入也很不友好，此外Chainlink VRF作为一个显著的重大热点，为NFT提供服务，Band目前还没有什么亮点仅仅挂个Oracle的竞争者。整体来看，Band还是比较困难的，推荐大家使用Chainlink.</p><p><img src="/images/oracle/oracle.png" alt="Oracle Analysis"></p><a id="more"></a><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>Band Protocol是一个Oracle平台，旨在将现实世界的数据和API聚合并连接到智能合约。 Band v1最初于2019年9月在Ethereum上使用了Bonding Curve设计，但开发人员的兴趣不大，最终没有在主网上获得采用。 核心开发团队在不到一年的时间内就放弃了它, 开始开发V2版本。<br>Band v2，被称为BandChain，是一个在自己的基于Tendermint的区块链上运行的Oracle网络（使用Cosmos SDK）。 BandChain已经启动了两个网络，第一个是Wenchang网络-一个原型主网络，它不具有任何Oracle功能，只生成基本上是空的块。第二个网络是Guan Ya测试网，但是，在底层Cosmos SDK中出现严重的内存泄漏和状态修剪错误之后，该网络最近不得不重新启动。在正式主网之前，其目的是启动一个授权证明网络，该网络由七个属于Band基金会和私有选择验证者节点组成。<br>在本文中，我们将首先从高层次探讨BandChain的工作方式，从而为进行比较分析奠定基础，该分析详细说明了BandChain与Chainlink的堆叠方式。比较的主要重点如下：</p><h4 id="数据质量"><a href="#数据质量" class="headerlink" title="数据质量"></a>数据质量</h4><p>Band：在发布时，BandChain最初将仅支持免费的低质量API，而付费的受密码保护的API支持在很大程度上仍是理论上的。 因此，开发人员不能只调用他们想要的任何受密码保护的API。 他们提出的计划是要求数据提供者更改其整个业务模型，以接受数据的链上加密货币支付。</p><p>Chainlink：本机支持连接到当今任何实时生产环境中的数据源API，包括免费的开放API，付费的经过身份验证的API和专有的私有API。 所有这些都可以通过模块化的外部适配器实现，任何人都可以创建和托管这些适配器，而无需Chainlink团队或数据提供商本身的任何其他支持。</p><h4 id="随机性依赖"><a href="#随机性依赖" class="headerlink" title="随机性依赖"></a>随机性依赖</h4><p>Band：将随机性作为协议的核心组成部分； 这是选择oracle节点的必需方法，尽管该功能不受任何原始学术研究的支持。 这不仅严重限制了数据的可访问性（每个节点都必须有权访问相同的数据）和网络安全性（必须信任每个节点），而且该团队在此主题上无能为力，因为他们在尝试复制Chainlink VRF在他们自己的github repo上的时候，被发现了(<a href="https://twitter.com/chainlink_alert/status/1267133567764758533)。" target="_blank" rel="noopener">https://twitter.com/chainlink_alert/status/1267133567764758533)。</a><br>Chainlink：不将随机性作为协议的核心部分，以确保用户具有高度的灵活性和质量控制机制，可以选择节点并连接到数据。 他们建立了Chainlink可验证随机性功能（VRF），作为一种新颖的方法，以领先的和原创的学术研究为后盾，<strong>为区块链游戏和NFT dApp创建可证明的公平的随机性源</strong>。</p><h4 id="采纳指标"><a href="#采纳指标" class="headerlink" title="采纳指标"></a>采纳指标</h4><p>Band：尽管Band v1在以太坊上存在了将近一年，但主网上目前没有正在使用的产品。 Band v2尚未完成（没有oracle功能），完全未经验证，并且缺少能够支持生产中的真实用户的任何案例研究。<br>Chainlink：目前，通过其众多实时价格参考供稿，对于排名靠前的DeFi项目，其在Mainnet上的价值超过$ 10B。 由于其在VRF方面的开创性工作，它是整个DeFi，跨区块链，游戏中使用最广泛的Oracle，并拥有240多个项目集成管道。</p><h4 id="资源效率与网络设计"><a href="#资源效率与网络设计" class="headerlink" title="资源效率与网络设计"></a>资源效率与网络设计</h4><p>Band：他们的Oracle建立在自己的区块链上，需要Oracle节点执行作为BandChain的块生产者/验证者的辅助工作，这对Oracle的数据交付工作没有任何价值。 这样，由于状态膨胀越来越大，并且随着时间的推移，同步时间较长，因此节点将承受较高的运营成本。<br>Chainlink：Chainlink不是，以后也不会是一个区块链网络，因此节点仅充当仅专注于数据交付的预言家，而不会阻止生产/验证。 节点非常轻巧，不需要状态处理或同步，因此可以将节点旋转并立即使用。</p><h4 id="团队"><a href="#团队" class="headerlink" title="团队"></a>团队</h4><p>Band：Band团队规模很小，没有进行过任何原始的学术研究，也缺乏构建分布式系统和Oracle的经验，尤其是那些能够确保真实价值的产品。 他们还放弃了原始设计，并多次更改了协议。<br>Chainlink：40+ Chainlink团队成员自2014年以来一直在建立Oracle预言机并发表原创学术研究，并得到了顶级顾问的支持，例如Ari Juels（RSA的前首席科学家），Tom Gonser（DocuSign的创始人），Evan Cheng（工程总监） 在Facebook）等等。 他们坚持原始设计并对其进行扩展以改善用户体验。</p><h4 id="去中心化"><a href="#去中心化" class="headerlink" title="去中心化"></a>去中心化</h4><p>Brand：所有数据查询/响应必须通过单个区块链BandChain处理，从而限制了最大吞吐量。 由于Tendermint BFT共识的可扩展性有限，因此上限为100个节点。<br>Chainlink：无限数量的Oracle网络可以并行运行，并且可以在任何区块链，DLT或Layer 2解决方案上本地运行，从而无需通过任何一条链来进行数据查询/响应。 即将到来的阈值签名和链外聚合升级的节点没有上限。</p><h4 id="多链支持"><a href="#多链支持" class="headerlink" title="多链支持"></a>多链支持</h4><p>Brand：依靠尚未发布的Cosmos IBC将数据本地桥接到其他区块链。 因此，它目前仅支持精简客户端，精简客户端要求数据由协议之外的未知第三方交付，这些第三方对其性能的奖励或处罚为零。<br>Chainlink：通过模块化的外部适配器，外部发起程序，核心合约部署和令牌桥接，以本地方式支持任意区块链。 节点将数据直接传递到任何区块链上的请求合约，从而最大程度地减少网络跳转并确保及时传递。</p><p><img src="/images/oracle/chainlink1.png" alt="chainlink1"></p><h3 id="怎么运行的"><a href="#怎么运行的" class="headerlink" title="怎么运行的"></a>怎么运行的</h3><p>Band Protocol v2（BandChain）是基于Bender（DPoS）共识算法的基于Tendermint的区块链，并在Cosmos生态系统中运行。 BandChain当前在主网上不支持oracle，仅产生大部分为空的块。本节介绍了BandChain一旦完全发挥作用后将如何运行，但请记住，主网中尚不存在许多这些功能。<br>BandChain节点必须既充当区块链的验证器（产生块，验证和订购交易），又充当服务外部数据请求的预言家。拥有最多代币的前100名验证者成为BandChain的验证者。该网络的年通胀率将从13.5％开始，目标是占总供应量的66％。如果抵押率低于66％，通货膨胀率最高将上升到20％。如果抵押率高于66％，通货膨胀率将至少降低7％。另外，虽然尚不清楚这些资金将如何分配以及分配给谁，但每个区块奖励的2%会转入社区资金池。</p><p>可以大幅度削减验证者的本金，以使停机时间过多，超过30,000个区块（0.01％罚款），双重签名区块（5％罚款）或无响应（百分比不清楚）。如果大幅减少停机时间，节点将无法参与对任何块的签名，直到它们在BandChain上发送交易证明其在线。重要的是要注意，BAND赌注和所有这些削减条件仅用于维护区块链验证和区块生产，而不是用于确保任何oracle服务的可靠性或数据准确性。尽管Band团队建议在将来共同投票以惩罚执行错误的Oracle服务的验证者（这将受到鲸鱼的操纵），但这尚待开发，并且仍然完全是理论上的。</p><p>用户可以通过调用可用的“ Oracle Script”智能合约将数据请求发送到BandChain，这些智能合约是对数据请求详细信息进行编码的链上可执行程序，例如要调用的数据源API以及将验证程序响应聚合为单个响应的方法。选择响应数据请求的节点由随机权益加权算法决定。验证者投入的BAND令牌越多，将它们分配给数据请求的可能性就越大。因此，数据请求者无法控制将使用哪些节点来完成其数据查询。</p><p>选定的验证器通过获取链下数据并在链上（到BandChain）传递响应来完成数据请求。然后，将来自每个参与节点的数据汇总以形成最终响应。创建了一个oracle数据证明（Merkle证明），并显示最终结果的存在以及oracle脚本哈希，输入参数，执行时间等。该证明可以发送到其他区块链上的智能合约以验证其证明由BandChain验证者。证明也可以被解码，以便智能合约可以使用数据结果。</p><p>Band Protocol的目标是与区块链无关，其中Oracle请求在BandChain的环境中处理并桥接到其他链上。他们计划利用Cosmos正在开发的未发布的跨区块链通信（IBC）协议来将数据桥接到其他链，尽管目前尚不清楚IBC是否以及何时准备投入生产。因此，要求用户使用lite客户端协议将数据手动桥接到其他区块链，直到IBC启动。这要求用户依赖BandChain协议之外的外部第三方将数据实际传递到另一个区块链（例如，以太坊上的DeFi应用程序）上正在使用的智能合约中。这些第三方没有动力可靠地提供数据，也没有因此而受到惩罚。</p><p>现在您对BandChain的工作方式有了一些了解，我们可以逐点深入进行比较，以了解Band如何与Chainlink抗衡。</p><h4 id="数据质量和Oracle连接范围"><a href="#数据质量和Oracle连接范围" class="headerlink" title="数据质量和Oracle连接范围"></a>数据质量和Oracle连接范围</h4><h4 id="Band-Protocol"><a href="#Band-Protocol" class="headerlink" title="Band Protocol"></a>Band Protocol</h4><p>Band协议仅支持免费的开放API。目前，他们对付费的受密码保护的API的支持完全是理论上的。当前的提议将要求数据提供商单独上岗，并修改其业务模型以加密货币支付。 Chainlink原生支持当今的所有数据源，包括通过模块化外部适配器的开放式和经过身份验证的API，这些适配器不需要数据提供商更改其现有业务模型。</p><p>编写本文时，Oracle功能在主网上尚不可用，但一旦上线，它将仅支持免费的低质量API，这些API通常每隔10分钟或更长时间更新一次，精度不超过小数点后1位点。从一开始就无法支持高质量数据，这使人们严重怀疑DeFi协议是否会感到满意，依靠Band来保护数百万美元的用户存款，尤其是当几乎所有高质量数据都存在于付费专区且仅发生一次Oracle攻击时由于数据质量低劣，最终可能导致破产并破坏应用程序的整体声誉。</p><p>Band表示BandChain将无法支持经过身份验证（受密码保护）的API，直到第2阶段（时间表尚不清楚）。密码保护的API如何实施的细节几乎不存在，在他们的文档中减去一句话，即” API提供者通过BandChain的链上支付结算来通过数据获利”。尽管这种模型不太可能已经准备好投入生产，但从整体上考虑它会暴露出逻辑上的一些缺陷。</p><p>首先，数据提供者将需要改变其现有业务模型以支持加密货币支付，这意味着Band将不得不携带成百上千的特定于应用程序的，经过身份验证的利基数据源，数据请求者需要这些数据源来构建其dApp。这既不切实际又不可扩展，将严重限制开发人员访问绝大多数数据源。</p><p>其次，它们的随机权益加权节点选择机制意味着可以潜在地选择网络中的每个节点来服务数据请求，这导致每个节点都需要访问每个潜在的数据源。这将需要与数据提供商进行激烈的协商，以达成整个区块链都可以访问的交易，以及节点之间缓慢，复杂的链外协调/治理，以共同添加新数据源并为其提供资金，这使其非常不切实际或完全不可行。</p><p>扩展性上，由于采用了这种设计选择，Band仅是所有节点都可以平等访问的唯一数据类型，因此它仅非常适合支持开放的API。这将阻止开发人员访问他们所需的特定外部数据，尤其是以任何快速无摩擦的方式。这也将消除绝大多数数据提供商永远无法加入网络，因为他们不能（出于法律原因）和/或不希望（出于商业原因）接受加密货币支付。鉴于缺乏利用BandChain生产的应用程序，任何数据提供商花费时间，资源和金钱来重新设计其业务模型以支持BandChain几乎没有意义。他们也从未详细说明过如何保护数据隐私的功能，这将进一步使BandChain不再受到希望保护其IP的数据提供商和需要保护敏感信息的企业的支持。</p><h4 id="Chainlink"><a href="#Chainlink" class="headerlink" title="Chainlink"></a>Chainlink</h4><p>Chainlink已经通过其价格参考合约利用了凭据数据源，这些参考数据是由分散的oracle网络保护的30多种DeFi价格摘要的集合，这些摘要使任何智能合约都可以在单个交易中同步提取外部数据。</p><p>Chainlink可以灵活地提供高质量的数据，因为节点始终具有内置的凭据管理功能，这些功能使它们可以使用模块化外部适配器访问任何受密码保护的API。可以使用任何编程语言编写Chainlink外部适配器，并与Chainlink节点本身分开托管。这打开了API的整个世界，例如高级数据提供商，Web API，企业系统，云提供商，IoT设备，支付系统，其他区块链（公共和私有）等等。<br>数据提供商无需更改其核心业务模型或后端基础结构即可通过智能合约访问，因为Chainlink节点可以处理外部适配器中的API密码密钥。因此，他们可以为今天使用的法定订阅模型中的已认证API付费，然后只需将其API密码密钥放在外部适配器中，然后立即开始在链上传递该数据。数据提供商更喜欢这种模型，尤其是在最初，因为它们可以在不花费任何时间，资源或金钱进行复杂区块链集成的情况下获得更多收入。</p><p>这极大地减少了开发人员的负担，因为节点可以在无需任何许可或需要所有其他节点获得相同访问权限的情况下，快速构建对任何链外数据资源的支持。它只需要一个节点或开发人员为该数据源API编写一个外部适配器，使其可用于任何区块链。然后，节点可以通过专门提供特定的数据集来区分自己。同样，如果数据提供者希望直接在链上获得报酬，则他们可以自己运行节点并直接向市场出售。实际上，一些数据提供者已经在Chainlink上这样做了，例如Huobi，Kaiko，Alpha Vantage等。重要的是，外部适配器模型可确保数据提供商始终获得报酬，而企业系统仅授权经过验证的用户。</p><p>Chainlink还高度了解Oracle隐私的必要性，因此他们在可信赖的硬件解决方案（如Town Crier）上的完善工作已得到广泛认可。企业可以使用该技术来满足隐私法规，同时在执行智能合约时仍使用其专有数据。最重要的是，企业可以准确选择哪些oracle节点满足其数据问题，这在确保机密数据（PII）即使经过加密的情况下也仅位于特定地理区域内以确保遵守诸如GDPR –许多全球企业和机构的基本要求。</p><p>Chainlink网络是一种资本主义的自由市场经济，任何人都可以运行自己的节点，开始在任何区块链上提供智能合约，并可以访问任何链下数据源API。这促进了健康的竞争，并允许节点建立自己的业务模型，而无需其他所有节点的外部依赖。相反，BandChain采取的是共产主义的，中央计划的经济方法，该方法要求网络中的每个节点都经过标准化，并支持与网络中每个其他节点相同的功能和连接，最终限制了创新，竞争和采用。</p><p>哪些开发人员或用户将信任那些不了解其核心功能到其协议中，没有学术研究或安全审核支持，并要求复制竞争对手解决方案的开发人员大量价值？ 这是BandChain如何利用现有技术，区块链和随机性功能，并试图迫使它们成为基于错误假设的Oracle解决方案的又一个示例。</p><p>Chainlink允许数据请求者准确选择他们要使用的预言软件，从而为智能合约开发人员带来最大的灵活性。 Chainlink团队已经构建了Chainlink VRF，可以用作可证明是公平的随机性源，作为区块链游戏和NFT行业的输入，而不是Chainlink协议本身的核心部分。他们理解并避免了强迫数据请求者使用随机性选择节点的严重危险，特别是无法获得高质量或许可的数据集（如数据质量部分中所述）以及无法在网络上获得确定性保证的巨大安全风险。节点运营商的可靠性或基础架构安全性。<br>Chainlink VRF已被广泛采用，在启动后的短时间内便进行了许多集成，包括：PoolTogether，Digitix，Get Protocol，Blocklords，Polyient Games，BlockPegnio，Vibe，Texel，Tiny Boxes，Cargo，Wildcards，FaceGolf和更多。 Chainlink的VRF建立在行业专家多年的学术研究基础之上，这些专家在分布式系统和高级密码学领域拥有数十年的经验，例如Ari Juels，Andrew Miller，Evan Cheng，Alex Coventry等（在下面的部分中进行详细介绍）。 Chainlink VRF不仅是由世界上一些最聪明的人内部开发的，而且还经过了顶级安全公司的审核，并经过了无数次审查才能投入生产。</p><h3 id="发展与网络效应"><a href="#发展与网络效应" class="headerlink" title="发展与网络效应"></a>发展与网络效应</h3><p>Band团队缺乏在分布式系统，高级密码学和构建oracle方面的经验，已经放弃了最初的v1版本启动，无法捕获任何网络影响，并且Band v2完全未经验证，没有在生产中使用。 自2014年以来，Chainlink团队一直在建立Oracle，其团队由40多人组成，其中包括顶级学术和业务顾问。 Chainlink还为市场领先的DeFi项目确保了Mainnet上超过$ 10B的价值，并且集成管道中有240多个项目（包括60多个区块链）。</p><p>Band v1在开发方面完全被放弃了，并且没有看到任何外部项目在生产中的使用。缺乏任何主网采用以及其价格信息的更新不频繁就证明了这一点，其中许多经常表现出较大的偏差。Band协议在设计上也进行了多次更改，包括放弃了其双令牌绑定曲线设计，等离子L2，Gas，稳定币费用支持，用户驱动的数据治理等。v1的性能不佳以及协议的不断变化质疑Band团队是否真的考虑了他们的Oracle机制的设计，以及是否可以信任他们以确保从其他用户的资金中获得数百万美元的价值。<br>Band v2（BandChain）也未经Oracle系统的完全验证，尚不支持其原始主网上的任何Oracle功能。 BandChain的大部分与区块链相关的工作都外包给了Cosmos SDK和Tendermint。对于任何现实价值而言，都缺乏经过时间考验的安全性，这意味着Band仍需要证明自己是一种可靠的解决方案，然后任何项目才能放心地相信其oracle实现来保护核心协议功能。请务必记住，甲骨文负责其他dApp的关键任务功能，例如发放贷款和执行清算。</p><p>当其他人正在考虑是否可以将整个协议的正确功能委托给您的外部Oracle机制时，成为一个好人或在您的墙上获得学位是毫无意义的。考虑到Band没有获得生产中的用户，已经进行了多次设计变更，并且仅使用提取了所有艰巨工作的SDK推出了区块链，因此任何希望使用BandChain的dApp都承担着严重的风险并且对其鲁their地进行粗鲁用户的资金。</p><p>Band团队由三位创始人组成，他们在构建区块链基础架构，oracle机制或任何处理实际价值的关键任务系统方面<strong>没有经验</strong>。他们在软件开发方面的唯一经验是在2015年创建了基于加密的手机游戏，此游戏已被放弃。为儿童构建手机游戏与构建复杂的分布式系统并不遥不可及，后者不仅为Band令牌持有者确保价值，而且最终也希望确保其他应用程序的价值。这种经验几乎没有甚至没有交叉，因为建立一个区块链的甲骨文网络是一个具有挑战性的指数难题，并且存在许多明显的陷阱和攻击媒介。他们不仅缺乏经验，而且没有学术或商业顾问来指导他们。所有这些都表明Band团队处于顶峰，<strong>这将给使用它的任何人带来巨大风险，并在不可避免地发现和利用漏洞时打开Mt Gox类型的内爆。</strong></p><p>Chainlink,至少从2014年SmartContract LTD成立（以太坊推出之前）开始，Chainlink的联合创始人一直在研究和构建外部连接的智能合约和区块链Oracle技术。该团队直接与需要区块链Oracle的顶级开发人员和企业合作，他们通过开发已在生产中使用的可靠解决方案，了解了如何满足各种不同用例的安全性，隐私性和可扩展性需求，以及应用程序。他们从未放弃过自己的初衷，而是继续在创建的坚实基础上进行创新，包括TownCrier，Threshold签名，Mixicles等原始研究开发。<br>Chainlink的40多人开发团队由区块链，甲骨文，密码学，机器学习，人工智能和业务开发方面的资深专家组成。其中包括众多学术和商业顾问，这对于Chainlink的技术和国防深度方法至关重要。</p><p>Chainlink于一年前在主网上推出，并已迅速实现大型网络效应，目前已从许多领先的DeFi项目（包括Synthetix，Aave，Loopring，Nexus Mutual，Set Protocol，bZx，Kava， 和更多。 Chainlink还拥有240多个集成开发项目，从区块链和加密货币初创企业到Google，Oracle和SWIFT等全球企业以及Hyperledger，IC3，EEA，Baseline，InterWork等企业联盟/标准化组织等等。</p><p>最终的结果是一个非常有经验和知识渊博的团队，他们有能力以加密初创公司，全球企业和顶尖学者的支持方式来解决甲骨文的难题。 开发人员拥有案例研究和明确的证明，Chainlink是一个安全可靠的Oracle解决方案，可通过在生产中的实际使用来确保高价值合同。 它的采用已经在推动一个积极的反馈循环，在该循环中，使用网络的用户，数据提供者和节点越多，对于新的和现有的利益相关者来说，作为Oracle解决方案的功能更强大，价值更高的Chainlink也就变得如此。 鉴于缺乏主网使用以及合作伙伴数量非常有限（大多数是验证者或交易所列表），Band无法实现任何网络效果。 此外，开发人员除了缺乏活力的v1版本外，还没有任何关于Band的预言的信息。</p><h3 id="资源效率与网络设计-1"><a href="#资源效率与网络设计-1" class="headerlink" title="资源效率与网络设计"></a>资源效率与网络设计</h3><p>BandChain使用自己的区块链，这对于Oracle的工作是完全不必要的-将数据传送到智能合约。 Band团队正在使用区块链解决方案来解决一个根本不同的问题，这会导致许多问题，例如状态膨胀，同步时间长和强制随机节点选择。 Chainlink并非现在也永远不会是其专有的区块链，而是真正的与区块链无关的中间件，这使得它可以灵活地支持所有DLT网络和数据资源，并为节点运营商提供轻量级的支持。<br>带<br>BandChain区块链背后的设计选择（即两个秒的块时间）导致所有节点的状态膨胀迅速增长，而新节点或重新连接的节点的同步时间更长。运行Band节点比诸如Bitcoin和Ethereum之类的区块链要昂贵得多，并且要消耗大量资源，这些区块链已针对降低硬件要求进行了优化，以增加分散性。与完全不运行专有区块链的Chainlink oracle节点相比，它的成本和资源消耗也成倍增加。</p><p>随着时间的流逝，BandChain的设计决策很可能自然导致集中度的提高，而节点大多由资本雄厚的验证者在几个数据中心中运行。这些问题与EOS和BSV等区块链受到的影响相同。为了支付运行节点的成本，如果用户费用没有增加到足够高的水平，BandChain将需要更高的新铸造令牌的通货膨胀率来维持相同级别的安全性。<br>由于Band的预言机也是块生产者，因此，块生产的失败（例如最近Cosmos SDK中的内存泄漏和状态修剪问题）也会导致预兆机制的失败。将oracle机制直接集成到区块链的基础层中也将强制执行单个整体网络设计，这由于强制实施的标准化而阻碍了oracle的创新，并极大地限制了oracle在支持各种用例方面的概括（如数据质量部分）。</p><p>BandChain通过隐秘方法通过一种安全措施有效地运作，其中验证者无需透露其身份或可靠性。 这与随机的股权加权选择相结合，意味着数据请求者必须信任在BandChain上运行的所有节点，因为他们无法控制最终将被选中的匿名或非匿名节点，从而给用户带来了很高的信任障碍。 这远非理想，因为大多数安全专家普遍认为通过模糊性来实现安全性是设计基本健壮的系统或网络的不良方法。</p><p>由于Chainlink不是区块链，因此不会遭受状态膨胀或同步时间问题。 Chainlink节点重量轻，对硬件的要求极低，可以通过一个简单的Docker容器在任何计算环境中运行。甚至将节点设置为在Raspberry Pi等极低规格的设备上运行，从而使IoT设备可以直接运行Chainlink节点以减少智能合约的跳数。由于缺乏资源需求而导致的低进入门槛极大地增加了Chainlink网络整体的分散性。</p><p>与BandChain不同，不需要所有活动Chainlink节点之间的整体全局共识，而是选择水平可伸缩性，即无限数量的oracle网络并行并行运行。 Chainlink节点不需要创建或验证任何专有区块链的块，因此不依赖于任何一个特定区块链的功能操作。对于每个单独的Oracle网络，Chainlink的安全性都是完全自主的。它没有做任何实现假设，而是提供了使用任何区块链所需的节点，数据源或参数来创建任何类型的oracle网络所需的工具。它是高度通用的，这意味着它不会对用户强加任何一种类型的oracle设计模式（推送或拉动，允许或不允许，集中或分散，开放或列入白名单，偏差阈值和/或心跳更新等），允许无限在新的Oracle模型上进行创新。<br>当前在主网上运行的Chainlink网络通过透明性原理使用安全性进行操作，其中价格参考数据网络仅由经过安全审查的节点组成，这些节点由经验丰富的区块链DevOps和分布在全球数据中心和现场裸机中的安全团队操作服务器。此外，许多独立的团队创建了多种分析服务，使最终用户和开发人员都可以直接查看每个Oracle网络的性能和历史记录。这样，任何人都可以使用以简单易用的方式呈现的历史索引链上数据来确切地知道特定的Chainlink网络或节点是否可靠。这包括feeds.chain.link（由Chainlink创建），market.link（由LinkPool创建），reputation.link（由Secure Data Links创建），honeycomb.market（由CLCG创建）等。</p><h3 id="去中心化和加密经济安全"><a href="#去中心化和加密经济安全" class="headerlink" title="去中心化和加密经济安全"></a>去中心化和加密经济安全</h3><p>由于Tendermint BFT的可伸缩性有限，BandChain使用具有100个节点上限的单个整体共识机制。验证器仅放样产生块，而对于操作或无效的外部数据则不加砍刀。 Chainlink是独立的分散式Oracle网络的集合，这些Oracle网络在众多区块链上并行运行，其阈值签名和链外聚合升级没有每个网络中节点数量的上限。 LINK放样将涉及绑定服务协议，并在数据质量，可靠性，准确性等方面采用预先定义的削减条件。</p><p>由于BandChain使用Tendermint BFT共识进行操作，因此最多只能扩展到几百个验证器，然后通信带宽才成为问题和每秒事务（TPS）池。因此，Band在任何给定时间点的验证器数量有限，最多100个节点。这是使用整体式区块链作为处理数据请求和响应的唯一共识机制的另一个缺点。它极大地限制了BandChain将能够达到的最大分散级别，除非对整个网络模型进行根本性的重新设计。<br>还需要注意的是，BandChain验证程序只有在充当糟糕的区块生产者（停机，双重签名，无响应）的情况下，才可以削减其BAND股份。充当不良或恶意的Oracle（操纵数据，Oracle网络攻击，串通）不会造成任何重大的惩罚。 BandChain中的验证者可能更专注于成为一个好的区块生产者，而不是成为一个好的预言家，因为这是决定他们是否被削减的原因。<br>尽管零售业者已经讨论了BandChain Token，但现实是，验证者的零售股份并没有为BandChain作为Oracle网络提供任何真正的价值。将来，BandChain可能会对通过链上投票传递不良数据的节点实施大幅削减，但目前很少有细节，因为仅提一个小建议，因为它们已弃用的D3N规范中只有一句话。此后，有关该主题的信息已从其github wiki上的当前文档中删除，表明他们可能对该主题几乎没有积极的开发。</p><p>尽管这个想法可能也已经被抛弃（就像许多其他以前的核心功能一样），但他们过去曾指出，零售BAND令牌涉众将有助于将数据提供者作为信誉系统机制进行管理。这代表了执行质量控制的一种非常脆弱和临界的危险形式，尤其是在考虑到它应该为价值数百万美元或更多的合同提供安全性时。散户投资者不太可能进行任何认真的尽职调查，而只会选择即时投资回报率最高的数据提供商。</p><h4 id="区块链不可知论的方法"><a href="#区块链不可知论的方法" class="headerlink" title="区块链不可知论的方法"></a>区块链不可知论的方法</h4><p>BandChain依靠尚未发布的Cosmos IBC将数据本地桥接到其他链。 当前，它仅支持lite客户端，在这些客户端中，数据必须由协议外部的未付费和可能未知的外部方传送。 Chainlink本机支持当今最领先的区块链，并将通过其自适应且易于集成的设计继续支持未来的链。</p><p>由于BandChain是其自己的区块链，因此另一个要使用Band oracles的区块链上的去中心化应用程序完全依赖于跨链通信桥。 <strong>BandChain的主要跨链功能取决于Cosmos区块链内部通信（IBC）协议</strong>，该协议不是由其团队构建的，距离全面运行和经过时间考验还需要数月甚至数年的时间，尤其是对于不信任的数据传输而言从一个区块链环境到另一个。</p><p>在此之前，将通过部署在每个集成区块链上的BandChain lite客户端执行区块链互操作性。使用Band作为预言的其他区块链上的智能合约将完全依赖于一些外部非激励性第三方向该链上的精简版客户合约提供证明。 BandChain验证器不会将这些证明提供给其他链（直到IBC为止），这意味着当前始终需要第三方在链之间中继数据。这种方法很难扩展，因为每个受支持的区块链将需要托管自己的lite客户合同，并需要Band协议之外的外部实体来提供证明并保持lite客户同步。<br>关于将数据传递给精简客户的动机存在主要问题，尤其是在网络拥挤的情况下，当交易费用在外部区块链上飙升时。需要特别注意的是，即使BandChain在其自己的区块链上聚合数据，但将数据本身广播到其他区块链也将受使用链的本机速度和延迟的影响。 Bandchain当前仅支持少数几个Testnet区块链。</p><p>Chainlink与区块链无关，但是以与BandChain根本不同的方式实现了此类功能。 Chainlink不是运行自己的专有区块链，而是一个框架，用于在任何区块链上为智能合约构建异构的分散式Oracle网络。通过模块化的外部适配器和外部启动器，Chainlink节点能够监视数据请求并将链外数据直接传递到任何区块链环境，这意味着不依赖具有可疑激励/问责制的精简客户或外部第三方。因此，Chainlink节点能够本地支持当前或将来存在的任何区块链，DLT或layer2解决方案，包括智能合约功能有限的链，例如无法托管此类lite客户端的比特币。这还包括非IBC兼容的许可链和非区块链系统，例如企业ERP / CRM后端和旧数据库，这些系统希望从加密经济保护的分散式Oracle网络中创建和使用外部数据。</p><p>Chainlink网络上受支持的区块链包括以太坊，比特币，Polkadot，Ava，NEAR，Kava，Tezos，Binance Smart Chain，BSN，IRIS，基于EVM的链，基于基质的链，Harmony，Zilliqa，本体论，Kadena，Klaytn，CasperLabs， Solana，Hdac，ICON，Conflux，Hedera Hashgraph，Matic等。有60多个区块链被集成到Chainlink协议中。最初在以太坊区块链上启动时，Chainlink的合同系统被重写为可以在其他众多区块链上本地运行，而LINK令牌则通过跨链桥包装。因此，每个Chainlink甲骨文网络仅需遵循其所运行的特定链的吞吐量和安全性假设。</p><p>即使有IBC支持（Chainlink也可以支持），Chainlink的区块链不可知论形式的规模可以远远超过BandChain。代替Bandchain通过单个区块链传递数据请求和节点响应的方法，Chainlink网络可以并行且彼此完全独立地处理数据请求和节点响应，从而提供理论上无限的水平可扩展性。 Chainlink在每个词义上都是与区块链无关的，因为它不是区块链，而是在所有区块链网络上同时运行的抽象层。</p><p><img src="/images/oracle/chainlink2.png" alt="chainlink1"></p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>Chainlink与区块链行业中最著名的研究人员一起进行两次测量并进行一次切割，以进行敏捷开发，以保持在新的前沿技术和创新之上。团队认识到了考虑周到且端到端的安全Oracle框架的重要性，该框架可以提前缓解复杂的攻击媒介。Band的做法更像是将意大利面条扔在墙上，看看遵循“快速行动并打破事物”的理念的实质，换句话说。尽管此方法可以在某些行业中使用，但绝对不是绝对必要的解决方案，它可以解决oracle问题，因为绝对安全是必须的，实际价值很容易受到无法逆转的操纵。<br>经过全面比较，<strong>Band协议将采用基于区块链的方法，通过使用整体共识来解决oracle问题</strong>，这将强制执行节点的标准化并对其分散有上限。这种僵化的模式是Band努力以可扩展的方式支持经过身份验证的API的原因，因为如果不从头开始重新设计整个数据行业，几乎所有节点都无法在其框架中支持凭据数据。他们的大多数原始开发和设计规范已被放弃，未来的功能集几乎完全是理论上的，极其模糊的或根本不存在的。虽然探索和更改有时可能会很好，但它们也可能表明有人在他们的头顶上，这尤其应与构建oracle协议时所面临的风险有关。</p><p>另外，Chainlink已确定Oracle问题与区块链问题是分开的，它采用了高度模块化的自由市场框架，该框架支持无限数量的并行Oracle网络，这些网络达成共识并保持彼此完全独立的安全性。 Chainlink用户可以在多个方面访问高级定制，包括节点选择，数据类型，安全性方法，抵押抵押，隐私支持等等。 Chainlink团队证明了其能够支持主网上DeFi项目的大型生态系统，确保超过10亿美元的用户资金的能力。 Chainlink已经在建立公益的Oracle网络，其中多个用户贡献相同的价格，从而降低了每个用户的成本。</p><p>尽管竞争是健康的，每个人都应该尽自己的努力，但真正检查用于直接保护大量用户资金的预言机机制很重要。如果智能合约经济有望扩大规模，并被风险偏好更为保守，对灵活性和质量控制有更高要求的传统机构所利用，那么，Oracle可以轻而易举。Oracle的“足够好”方法恰恰是遭到黑客入侵并失去用户资金的开发人员的心态。这与部署未经审计的智能合约没有什么不同，智能合约面临着巨大的未知安全风险，这些风险可能会使项目及其用户完全破产。同样，非通用解决方案可能会在短期内服务于一个细分市场，但会像许多高科技行业一样被通用标准所吞并。</p><p>出于这些原因，需要通过智能合约的价值和通用性来扩大安全性，以增强卓越的网络效果，我们认为，与Band Protocol相比，Chainlink迄今为止是一个非常出色的oracle解决方案。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Nov 02 2020 15:59:06 GMT+0900 (Japan Standard Time) --&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;最近项目中需要使用到Oracle,对价格进行更新，找了一圈市面上的，发现Band和Chainlink，对Chainlink的比价深有体会，遂开始深入研究下Oracle的实现机制，以及如何讲现实世界中的数据和API链接到智能合约中。 以下主要是翻译了SmartContent写的Band协议和Chainlink的对比分析的文章， 原文地址： &lt;a href=&quot;https://medium.com/@smartcontentpublication/a-comparative-analysis-of-band-protocol-and-chainlink-54b7d14823b5&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://medium.com/@smartcontentpublication/a-comparative-analysis-of-band-protocol-and-chainlink-54b7d14823b5&lt;/a&gt; ，对文章进行了翻译和补充，基本使用Google翻译进行简要的翻译，可以当成一篇PR稿文章，主要从几个维度，比如 数据质量，随机性以来，采纳指标，资源效率和网络设计，团队，去中心化和多链支持等各个方面，对Band和Chainlink进行了比较，结果都是Chainlink胜出了。&lt;/p&gt;&lt;p&gt;大杨个人意见，看过Band的创始团队和背后的投资机构，都是相当有前景，而且Oracle语言机的盈利模式上都是平台方来撮合数据需求方和提供方调用，然后支付方式都是用平台的虚拟币支付，这样的方式其实也带来了很大不确定性，随着平台方币价的上涨，也带来了需求方很大的调用成本，本身现在公开的调用方式，实时性也不好，如果采用较为实时的解决方案，那么使用LINK代币来支付的费用，换算成法币的话，也是非常高的。从文章从可以看到的是Band协议V2，依赖于与Cosmos, 而且很区块链化，对于用户的直接引入也很不友好，此外Chainlink VRF作为一个显著的重大热点，为NFT提供服务，Band目前还没有什么亮点仅仅挂个Oracle的竞争者。整体来看，Band还是比较困难的，推荐大家使用Chainlink.&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/images/oracle/oracle.png&quot; alt=&quot;Oracle Analysis&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="blockchain" scheme="http://yangxinqi.com/categories/blockchain/"/>
    
    
      <category term="oracle, band, chainlink" scheme="http://yangxinqi.com/tags/oracle-band-chainlink/"/>
    
  </entry>
  
  <entry>
    <title>DEFI深入浅出实战编程一入门篇</title>
    <link href="http://yangxinqi.com/2020/09/24/DEFI%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%AE%9E%E6%88%98%E7%BC%96%E7%A8%8B%E4%B8%80%E5%85%A5%E9%97%A8%E7%AF%87/"/>
    <id>http://yangxinqi.com/2020/09/24/DEFI深入浅出实战编程一入门篇/</id>
    <published>2020-09-24T10:47:25.000Z</published>
    <updated>2020-11-02T03:01:35.640Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Nov 02 2020 15:59:06 GMT+0900 (Japan Standard Time) --><p>翻译者： 大杨， 链因智能CEO， 一家初创区块链技术公司，DEFI布道者。</p><p>技术点： DEFI，ETH，NODEJS，SOLIDITY</p><p>今天抽出了一些时间，翻译了CoinBase的<a href="https://twitter.com/petejkim" target="_blank" rel="noopener"><em>Pete Kim</em></a> 写的【<a href="https://blog.coinbase.com/introduction-to-building-on-defi-with-ethereum-and-usdc-part-1-ea952295a6e2" target="_blank" rel="noopener">Introduction to Building on DeFi with Ethereum and USDC — Part 1</a>】DEFI编程入门学习的文章。</p><p>翻了下Pete Kim的twitter和他的github，发现是个全栈高手和社区活跃者，看上去应该是韩国人，技术很不错，人也很帅 😂。</p><p>最为美系的第一交易所CoinBase对整个Crypto生态的贡献是巨大的，本篇DEFI编程的入门文章也非常适合新手，看了有很想翻译的冲动，就花了2小时做了下整理，并在kovan的网络上实战了一把，对很多细节的地方做了补充，强烈推荐给大家。 经历DEFI，后续链因智能3年积累的相关技术都会进行开源，通过开源促进技术发展。</p><a id="more"></a><p><strong>以下是文章的内容：</strong></p><p>首先介绍 CoinBase 的价值观和愿景。</p><p>在Coinbase，我们的任务是建立一个开放的财务系统。我们坚信，促进经济自由将使世界变得更美好。分布式金融，简称DeFi-一种开放，无边界和可编程的金融-是我们伟大愿景不可分割的一部分。</p><h3 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h3><p>DeFi由运行在分布式网络（例如以太坊（“区块链”））上的数字货币（如美元代币（USDC））智能合约组成。智能合约的想法由来实际上很简单。数字货币和密码学的先驱尼克·萨博（Nick Szabo）最初在1997年提出了这个想法，他将<strong>自动售货机</strong>描述为<strong>智能合约的始祖</strong>。</p><p>自动售货机是合同的自动化版本，以电子硬件的形式表示：<br>您通过向机器中投入钱来支付显示的价格，机器将为您分配饮料<br>您不支付显示的价格，也不分配饮料<br>如果您支付了显示的价格但机器没有分配饮料，或者即使您没有支付显示的价格也分配了饮料，则违反了合同<br>自动售货机无需人工干预即可完全自主地管理其合同义务。<br>现代智能合约的工作方式相同，但是合约条款被表示为可执行的计算机代码，而不是在硬件中实现。在其上运行智能合约的网络的分散性确保了它们以书面形式执行，并且没有任何单个实体能够弯曲规则或操纵结果。一个重要的警告是，因为网络逐字执行代码，所以错误的智能合约代码可能会导致意外的后果（“代码就是法律”）。</p><h3 id="没有比现在更好的时机"><a href="#没有比现在更好的时机" class="headerlink" title="没有比现在更好的时机"></a><strong>没有比现在更好的时机</strong></h3><p>许多人发现基于加密技术构建的区块链非常令人生畏，并认为只有坚韧的计算机科学家才能使用它。尽管就在几年前，情况确实如此，但自那时以来，工具和开发人员用户体验已有了显着改善，任何具有基本编程技能的人都可以开始构建。<br>DeFi生态系统目前正在爆炸性增长。 USDC在不到2年的时间里达到了$1B的市值，并且在不到3年的时间内，存储在各种DeFi服务中的资产总值超过$2B。确实没有一个哪个领域有这么好的时机快速发展。</p><p><img src="/images/defi/defi_1.png" alt="DeFi Pulse"><br>来源：DeFi Pulse</p><p>以下教程是开始开发自己的DeFi智能合约的简单指南。<br>我们希望，<strong>这样的指南将有助于建立全球开放的民主化金融体系</strong>。</p><h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><p>本教程系列假定您具有JavaScript的经验，JavaScript是世界上使用最广泛的编程语言。您也可能被介绍过Solidity，这是一种在以太坊上使用的智能合约编程语言，这是世界上使用最广泛的智能合约区块链编程语言。最后，您将与DeFi应用常用稳定币USDC进行交互（这里我们Fake了一个USDC，不是真实USDC）。</p><h3 id="搭建开发环境"><a href="#搭建开发环境" class="headerlink" title="搭建开发环境"></a>搭建开发环境</h3><p>首先，我们需要一个类似Unix的环境，并在其上安装Node.js v12.x（最新的LTS版本）。 MacOS本质上是Unix环境，Windows用户可以通过从Microsoft Store在WSL上安装Ubuntu来获得它。在MacOS和Windows中可以找到更详细的步骤。对于代码编辑器，强烈建议使用 <strong>Visual Studio Code</strong>，因为您要使用的项目模板已经预先配置好了，但是从技术上讲，您可以使用任何编辑器。哦，我更喜欢Vim而不是Emacs。</p><h3 id="设置项目"><a href="#设置项目" class="headerlink" title="设置项目"></a>设置项目</h3><p>设置Solidity项目需要一些工作，老实说，分心对于这个阶段的学习不是很有用，因此已经为您准备了一个预先配置的模板。</p><p>这块作者提供了一个很好的模版来跑，原地址： <a href="https://github.com/CoinbaseStablecoin/solidity-tutorial" target="_blank" rel="noopener">https://github.com/CoinbaseStablecoin/solidity-tutorial</a> ，这里我做了一些修改，FORK了一个项目地址，大家需要看代码的可以用下面的地址，作者提供的模版非常方便，可以让动手，推荐使用作者的地址。</p><p>在终端中运行以下命令以下载并设置模板：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/CoinbaseStablecoin/solidity-tutorial.git <span class="comment"># 作者原模版地址</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/chaininout/solidity-tutorial.git  <span class="comment"># 这个是包含了最新代码的地址</span></span><br><span class="line"><span class="built_in">cd</span> solidity-tutorial</span><br><span class="line">npm install -g yarn        <span class="comment"># Install yarn package manager 安装包管理器</span></span><br><span class="line">yarn                       <span class="comment"># Install project dependencies 安装依赖</span></span><br></pre></td></tr></table></figure><p>当yarn尝试构建本机扩展时，您可能会看到一些编译错误。这些是可选的，可以忽略这些错误。只要您最后看到“完成”消息，就可以继续。</p><h3 id="在Visual-Studio-Code中打开项目"><a href="#在Visual-Studio-Code中打开项目" class="headerlink" title="在Visual Studio Code中打开项目"></a>在Visual Studio Code中打开项目</h3><p>在Visual Studio Code中打开项目文件夹（solidity-tutorial）。第一次打开项目时，Visual Studio Code可能会提示您安装扩展。继续并单击“全部安装”，这将向编辑器添加各种有用的扩展，例如自动代码格式和Solidity语法突出显示。</p><h3 id="在以太坊上创建账户"><a href="#在以太坊上创建账户" class="headerlink" title="在以太坊上创建账户"></a>在以太坊上创建账户</h3><p>在以太坊上进行任何操作之前，您需要拥有一个帐户。帐户通常称为“钱包”，因为它们可以包含ETH和USDC等数字资产。最终用户通常使用Coinbase Wallet或Metamask等以太坊钱包应用程序创建帐户，但是使用模板随附的出色的ethers.js库，以编程方式创建帐户也非常简单。</p><p>在src文件夹中创建一个名为createWallet.js的新JavaScript文件，然后输入以下代码：</p><p>保存文件，并使用Node执行代码，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ethers = <span class="built_in">require</span>(<span class="string">"ethers"</span>);</span><br><span class="line"><span class="keyword">const</span> wallet = ethers.Wallet.createRandom();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`Mnemonic: <span class="subst">$&#123;wallet.mnemonic.phrase&#125;</span>`</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`Address: <span class="subst">$&#123;wallet.address&#125;</span>`</span>);</span><br></pre></td></tr></table></figure><p>在shell命令行状态下执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node src/createWallet.js</span><br></pre></td></tr></table></figure><p>执行后生成如下结果, 生成助记词和地址：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mnemonic: viable glow tone pole input series weather slam blouse embark achieve position</span><br><span class="line">Address: 0x6598f11d48Da2bfA897d5Eb3968223f98dabc008</span><br></pre></td></tr></table></figure><p>刚才发生了什么？ <strong>好吧，您拥有了一个全新的以太坊账户。</strong> “助记符”或可能更普遍地称为“恢复短语”是从帐户执行操作所需的密钥的人类可读表示，并且地址是帐户的名称和标识符。将它们复制到某个地方。附带说明一下，<strong>本文中显示的助记符已稍作更改，以阻止您使用它，请使用您自己的助记符</strong>！</p><p>可以将它们视为银行帐户的密码和帐号，只需要几秒钟即可创建一个，并且不必填写申请表或共享任何个人信息。您也可以在任何地方运行此代码。<br>⚠️<strong>注意该帐户的记忆符号必须保密。如果丢失，您将永远无法访问您的帐户以及该帐户中存储的所有资产，没有人能够为您提供帮助！妥善保管！</strong><br>从技术上讲，您本身并没有真正“创建”帐户。相反，您创建的是<strong>私钥/公钥对</strong>。如果您对引擎盖下实际发生的事情感到好奇，请阅读椭圆曲线密码学以及比特币和以太坊规范BIP39，BIP32，EIP55及其在此项目中的实现。</p><h2 id="关于Gas燃料和挖矿"><a href="#关于Gas燃料和挖矿" class="headerlink" title="关于Gas燃料和挖矿"></a>关于Gas燃料和挖矿</h2><p>以太坊是一个分布式网络，由世界各地成千上万的计算机组成，它们并非完全免费。要在区块链上执行任何状态更改（例如存储和更新数据），您必须向网络运营商支付以太坊（ETH）的交易费，在以太坊上也称为“ GAS”。这与运营商为在链中添加新区块而获得的奖励一样，也激励着他们保持计算机正常运行。此过程称为“挖矿”，而网络运营商称为“矿工”。我们将在本教程的后面部分（GAS，GAS价格和GAS限制）再次讨论这一点。</p><h3 id="获取测试网ETH"><a href="#获取测试网ETH" class="headerlink" title="获取测试网ETH"></a>获取测试网ETH</h3><p>现在您已经有一个帐户，您应该存入一些ETH。我们不想在开发时浪费真钱，因此我们将获得一些假的ETH，用于在测试网络（“ testnet”）上进行开发和测试。有许多不同的以太坊测试网，但由于容易获得测试Token，因此我们将使用Kovan。首先，让我们使用以太坊的区块浏览器Etherscan检查当前余额。为此，您可以在浏览器中输入以下网址，然后用您之前创建的地址（从0x开始）替换 0x6598f11d48Da2bfA897d5Eb3968223f98dabc008。<br><a href="https://kovan.etherscan.io/address/0x6598f11d48Da2bfA897d5Eb3968223f98dabc008" target="_blank" rel="noopener">https://kovan.etherscan.io/address/0x6598f11d48Da2bfA897d5Eb3968223f98dabc008</a><br>您应该看到您的余额为0 ETH。保持此选项卡处于打开状态，然后在其他选项卡中打开Kovan Ethereum Faucet 地址： <a href="https://faucet.kovan.network。在页面中，输入您的地址，然后单击“发送给我”按钮。交易可能只需要几秒钟到一分钟或一两分钟即可完成。再次检查Etherscan，您应该在列表中看到1" target="_blank" rel="noopener">https://faucet.kovan.network。在页面中，输入您的地址，然后单击“发送给我”按钮。交易可能只需要几秒钟到一分钟或一两分钟即可完成。再次检查Etherscan，您应该在列表中看到1</a> ETH的新余额和一笔传入交易。</p><p><img src="/images/defi/defi_2.png" alt="DeFi Pulse"><br>资料来源：<a href="https://faucet.kovan.network" target="_blank" rel="noopener">https://faucet.kovan.network</a></p><h2 id="以编程方式获取ETH余额"><a href="#以编程方式获取ETH余额" class="headerlink" title="以编程方式获取ETH余额"></a>以编程方式获取ETH余额</h2><p>连接以太坊，使用Etherscan查看余额非常有用，但是也可以通过代码轻松查看余额。但是，在回到代码之前，我们需要一种连接到以太坊的方法。有很多方法可以做到这一点，包括自己在计算机上运行网络节点，但是到目前为止，最快，最简单的方法是通过诸如INFURA或Alchemy之类的托管节点提供程序来实现，也可以自建节点。前往INFURA，创建一个免费帐户并创建一个新项目以获取API密钥（项目ID），链接这里： <a href="https://infura.io/dashboard/ethereum" target="_blank" rel="noopener">https://infura.io/dashboard/ethereum</a> 注册后在面板中创建自己的Project，然后拿到APIKEY。如果要自己搭建节点，也可以使用Go Ethereum（“ geth”）和Open Ethereum（以前称为Parity Ethereum）是两种使用最广泛的以太坊节点软件，这里后续我会在后续章节中列举节点搭建。</p><h4 id="用代码查看ETH余额"><a href="#用代码查看ETH余额" class="headerlink" title="用代码查看ETH余额"></a>用代码查看ETH余额</h4><p>首先，让我们编写代码以从助记符中读取并获取帐户。在src文件夹中创建一个名为wallet.js的新JavaScript文件，然后输入以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ethers = <span class="built_in">require</span>(<span class="string">"ethers"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Replace the following with your own mnemonic 这里输入刚刚生成的助记词</span></span><br><span class="line"><span class="keyword">const</span> mnemonic =</span><br><span class="line">  <span class="string">"rabbit enforce proof always embrace tennis version reward scout shock license wing"</span>;</span><br><span class="line"><span class="keyword">const</span> wallet = ethers.Wallet.fromMnemonic(mnemonic);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`Mnemonic: <span class="subst">$&#123;wallet.mnemonic.phrase&#125;</span>`</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`Address: <span class="subst">$&#123;wallet.address&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = wallet;</span><br></pre></td></tr></table></figure><p>用您自己的代码替换助记符字符串。<strong>请注意，在生产代码中，助记符不应该这样硬编码</strong>。相反，应从配置文件或环境变量中读取它，以免例如由于将其检入源代码存储库而意外泄漏。<br>执行代码，您应该能够看到与之前获得的地址相同的地址：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  solidity-tutorial git:(master) ✗ node src/wallet.js</span><br><span class="line">Mnemonic: viable glow tone pole input series weather slam blouse embark achieve position</span><br><span class="line">Address: 0x6598f11d48Da2bfA897d5Eb3968223f98dabc008</span><br></pre></td></tr></table></figure><p>看到生成的地址：0x6598f11d48Da2bfA897d5Eb3968223f98dabc008<br>接下来，在同一文件夹中创建一个名为provider.js的新文件。在此文件中，我们将使用我们先前获得的INFURA API密钥初始化提供者对象。确保将API密钥字符串替换为您自己的字符串：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const ethers = require("ethers");</span><br><span class="line">// 注意这里我们使用的kovan的网络，下面是infura上申请的key</span><br><span class="line">const provider = ethers.getDefaultProvider("kovan", &#123;</span><br><span class="line">  // Replace the following with your own INFURA API key</span><br><span class="line">  infura: "c844845b06f84d379ba3fb3bba5a1f99",</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">module.exports = provider;</span><br></pre></td></tr></table></figure><p>注意这里需要在truffle-config.js进行网络配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">networks: &#123;</span><br><span class="line">    development: &#123;</span><br><span class="line">      host: <span class="string">"localhost"</span>,</span><br><span class="line">      port: <span class="number">8545</span>,</span><br><span class="line">      network_id: <span class="string">"*"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    mainnet: infuraProvider(<span class="string">"mainnet"</span>, <span class="number">1</span>),</span><br><span class="line">    ropsten: infuraProvider(<span class="string">"ropsten"</span>, <span class="number">3</span>),</span><br><span class="line">    kovan: infuraProvider(<span class="string">"kovan"</span>, <span class="number">42</span>), <span class="comment">//这个是我们加上的测试网络，因为比较快</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>最后，我们将使用在同一文件夹中新建名为getBalance.js的新文件，并通过wallet.js和provider.js来获取ETH余额：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const ethers = require("ethers");</span><br><span class="line">const wallet = require("./wallet");</span><br><span class="line">const provider = require("./provider");</span><br><span class="line"></span><br><span class="line">async function main() &#123;</span><br><span class="line">  const account = wallet.connect(provider);</span><br><span class="line">  const balance = await account.getBalance();</span><br><span class="line">  console.log(`ETH Balance: $&#123;ethers.utils.formatUnits(balance, 18)&#125;`);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main();</span><br></pre></td></tr></table></figure><p>运行代码，您将看到ETH余额！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">node src/getBalance.js</span><br><span class="line">Mnemonic: viable glow tone pole input series weather slam blouse embark achieve position</span><br><span class="line">Address: 0x6598f11d48Da2bfA897d5Eb3968223f98dabc008</span><br><span class="line">ETH Balance: 1.0</span><br></pre></td></tr></table></figure><h4 id="代币计价"><a href="#代币计价" class="headerlink" title="代币计价"></a>代币计价</h4><p>我们刚刚创建的代码很容易解释，但是您可能想知道ethers.utils.formatUnits（balance，18）的作用。好吧，ETH实际上可以整除到小数点后18位，最小的面额单位称为“ wei”（发音为“ way”）。换句话说，一个ETH等于1,000,000,000,000,000,000 wei。另一个常见的面额是Gwei（发音为“ Giga-way”），为10亿魏。 getBalance方法碰巧以wei返回结果，因此我们必须通过将结果乘以10⁸将其转换回ETH。可以在这里找到所有面额的清单。<br>您还可以使用ethers.utils.formatEther（balance），这是ethers.utils.formatUnits（balance，18）的简写。</p><h4 id="获取Testnet-USDC"><a href="#获取Testnet-USDC" class="headerlink" title="获取Testnet USDC"></a>获取Testnet USDC</h4><p>您帐户中的ETH感到有些孤单，所以我们也想获取其中的USDC。我在Kovan测试网上部署了一个FakeUSDC智能合约。它没有专门的水龙头网站，但合同包含一项功能，在调用该功能时，您将获得一些免费的Kovan测试网USDC。如果您导航到Etherscan中的合同代码选项卡，并在合同源代码中搜索gimmeSome。这就是我们要调用的功能，用于将一些USDC发送到我们的帐户。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity <span class="number">0.6</span><span class="number">.12</span>;</span><br><span class="line"></span><br><span class="line">contract FakeUSDC is Ownable, ERC20 &#123;</span><br><span class="line">    <span class="keyword">constructor</span>() public Ownable() ERC20("FakeUSDC", "USDC") &#123;</span><br><span class="line">        _setupDecimals(<span class="number">6</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">mint</span>(<span class="params">address account, uint256 amount</span>) <span class="title">external</span> <span class="title">onlyOwner</span> </span>&#123;</span><br><span class="line">        _mint(account, amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">burn</span>(<span class="params">address account, uint256 amount</span>) <span class="title">external</span> <span class="title">onlyOwner</span> </span>&#123;</span><br><span class="line">        _burn(account, amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @notice Give the caller 10 USDC (10,000,000 units)</span></span><br><span class="line"><span class="comment">     * 这里我们加了个给测试账户发送代币的方法，能够免费给账户发送USDC测试代币</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">gimmeSome</span>(<span class="params"></span>) <span class="title">external</span> </span>&#123;</span><br><span class="line">        _mint(msg.sender, <span class="number">10e6</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="进行交易以调用智能合约"><a href="#进行交易以调用智能合约" class="headerlink" title="进行交易以调用智能合约"></a>进行交易以调用智能合约</h4><p>在以太坊智能合约中主要有两种类型的功能：<strong>读写和只读</strong>。前者可能导致存储在区块链中的数据发生变化，而后者纯粹是读取但从未写入。可以在不创建事务的情况下调用只读函数，因此无需支付交易费用，除非作为读写函数的一部分进行调用。另一方面，<strong>必须在交易内部调用读写功能</strong>，并且必须支付交易费（GAS）。调用gimmeSome函数会导致存储在区块链中的USDC余额发生变化，因此<strong>必须在交易内部调用它</strong>。</p><p>调用智能合约功能需要一些额外的步骤，但这并不太困难。首先，我们需要找到我们要调用的函数的完整接口，也称为<strong>函数签名或函数原型</strong>。在合同源代码中再次查找gimmeSome，您将发现界面如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gimmeSome</span>(<span class="params"></span>) <span class="title">external</span></span></span><br></pre></td></tr></table></figure><p>这是一个非常简单的函数，不带任何参数，<strong>并且被标记为外部函数，这意味着该函数只能从外部调用，而不能从该协定内的其他函数调用</strong>。因为我们将在事务中直接调用此函数。<br>显而易见，在以太坊主网络上部署的“真实” USDC合约中 <strong>不存在gimmeSome功能</strong>。 下面需要去部署智能合约，才能获取合约的地址，以便在下面调用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MNEMONIC=<span class="string">"viable glow tone pole input series weather slam blouse embark achieve position"</span> INFURA_API_KEY=<span class="string">"c844845b06f84d379ba3fb3bba5a1f99"</span> truffle deploy --network=kovan</span><br></pre></td></tr></table></figure><p>我们执行 truffle deploy 命令，在kovan测试网络中发布我们写好的合约。 签名的2个是地址的私钥和INFURA的KEY，这样能够用这个账户部署合约，部署完成后将现实如下过程，部署的合约数量和总共花费的GAS的费用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">3_init_FakeUSDC.js</span><br><span class="line">==================</span><br><span class="line"></span><br><span class="line">   Deploying <span class="string">'FakeUSDC'</span></span><br><span class="line">   --------------------</span><br><span class="line">   &gt; transaction <span class="built_in">hash</span>:    0x239e6922e55957d964dec79ffc2a8667b375c87185e47a334d824ffea89d9c0f</span><br><span class="line">   &gt; Blocks: 1            Seconds: 5</span><br><span class="line">   &gt; contract address:    0x4bB2ef39DD99A01BD5C11dDd25F890FeB45081e9  <span class="comment"># 这个我们在后续要用到</span></span><br><span class="line">   &gt; block number:        21121362</span><br><span class="line">   &gt; block timestamp:     1600937752</span><br><span class="line">   &gt; account:             0x6598f11d48Da2bfA897d5Eb3968223f98dabc008</span><br><span class="line">   &gt; balance:             0.95161372</span><br><span class="line">   &gt; gas used:            1705672 (0x1a06c8)</span><br><span class="line">   &gt; gas price:           20 gwei</span><br><span class="line">   &gt; value sent:          0 ETH</span><br><span class="line">   &gt; total cost:          0.03411344 ETH</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   &gt; Saving migration to chain.</span><br><span class="line">   &gt; Saving artifacts</span><br><span class="line">   -------------------------------------</span><br><span class="line">   &gt; Total cost:          0.03411344 ETH</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Summary</span><br><span class="line">=======</span><br><span class="line">&gt; Total deployments:   3</span><br><span class="line">&gt; Final cost:          0.03985546 ETH</span><br></pre></td></tr></table></figure><p>拿到合约地址，在src文件夹中创建一个名为getTestnetUSDC.js的新文件，然后输入以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ethers = <span class="built_in">require</span>(<span class="string">"ethers"</span>);</span><br><span class="line"><span class="keyword">const</span> wallet = <span class="built_in">require</span>(<span class="string">"./wallet"</span>);</span><br><span class="line"><span class="keyword">const</span> provider = <span class="built_in">require</span>(<span class="string">"./provider"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> account = wallet.connect(provider);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> usdc = <span class="keyword">new</span> ethers.Contract(</span><br><span class="line">    <span class="string">"0x68ec573C119826db2eaEA1Efbfc2970cDaC869c4"</span>,   <span class="comment">//这里是我们发布的合约地址</span></span><br><span class="line">    [<span class="string">"function gimmeSome() external"</span>],   <span class="comment">//我们本次需要调用的函数名 </span></span><br><span class="line">    account</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> tx = <span class="keyword">await</span> usdc.gimmeSome(&#123; <span class="attr">gasPrice</span>: <span class="number">20e9</span> &#125;);  <span class="comment">//指定gas</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Transaction hash: <span class="subst">$&#123;tx.hash&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> receipt = <span class="keyword">await</span> tx.wait();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Transaction confirmed in block <span class="subst">$&#123;receipt.blockNumber&#125;</span>`</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Gas used: <span class="subst">$&#123;receipt.gasUsed.toString()&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main();</span><br></pre></td></tr></table></figure><p>该代码首先使用我们感兴趣的函数gimmeSome的接口实例化一个合同对象（新ethers.Contract），并将其指向testnet Fake USDC合同的地址：0x68ec⋯69c4。然后，您可以调用列出的任何功能。 gimmeSome函数本身不会接受任何参数，但是您可以将事务选项指定为最后一个参数。在这种情况下，我们给它20 Gwei的GAS价格，这将加快交易速度。本质上，与网络交互的所有方法都是异步的，并返回Promise，因此我们使用的是JavaScript的await表达式。然后，代码将打印交易哈希，这是您交易的唯一标识符，可用于跟踪进度。然后等待直到确认交易。<br>运行代码，您将看到类似以下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node src/getTestnetUSDC.js</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  solidity-tutorial git:(master) ✗ node src/getTestnetUSDC.js</span><br><span class="line">Mnemonic: viable glow tone pole input series weather slam blouse embark achieve position</span><br><span class="line">Address: 0x6598f11d48Da2bfA897d5Eb3968223f98dabc008</span><br><span class="line">Transaction <span class="built_in">hash</span>: 0xf7ca007d794ea7d530da36b8cc55f6dce3c99276d65d45e0d32ea10290505666</span><br><span class="line">Transaction confirmed <span class="keyword">in</span> block 21121386</span><br><span class="line">Gas used: 65221</span><br></pre></td></tr></table></figure><p>瞧！您已经使用代码进行了首次以太坊交易！在Kovan Etherscan中检查您的地址和交易哈希。现在您应该看到，由于执行交易所支付的汽油费用，您现在拥有10个测试网USDC和略少于1 ETH。</p><p>ℹ️如果您在Etherscan中检查交易，您会发现这是将 <strong>（0）ETH与4字节数据</strong>一起发送到合约地址的交易。如果函数调用具有参数，则将不止4个字节的数据。如果您想了解此数据的编码方式，请阅读以太坊合约ABI规范。</p><h4 id="GAS，GAS价格和GAS限额"><a href="#GAS，GAS价格和GAS限额" class="headerlink" title="GAS，GAS价格和GAS限额"></a>GAS，GAS价格和GAS限额</h4><p>之前，我提到过，我们为交易提供20 Gwei的价格，以加快交易速度，并且脚本还显示使用的GAS量。这些都是什么意思？嗯，以太坊是一个由网络运营商组成的网络。将其视为一台世界计算机。它不是一台免费的计算机，您在该计算机上运行的每条指令都需要钱。该计算机也被世界各地的所有人共享，这意味着每个人都必须互相竞争才能在此计算机上花费时间。</p><p>我们如何做到这一点？</p><p>好吧，我们可以在这台计算机上拍卖时间，而您愿意为在此计算机上运行的每条计算指令支付的费用越多，网络运营商（矿工）将给您更多的时间。这种确定不是完美的，因为它可能会导致只有富人才能使用此系统的特权。但是，这是我们拥有的最差的解决方案，直到系统具有更高的可伸缩性并可以容纳更多的交易为止。<br>回到区块链的术语上，“已使用的GAS”是您运行交易后消耗的计算资源量，“GAS价格”是您愿意为每单位天然气支付多少费用。通常，您愿意支付的费用越高，交易的优先级就越高，并且网络会更快地对其进行确认。在我们的案例中，我们使用20 Gwei作为GAS价格，使用的GAS为35121（您还可以通过在Etherscan中检查交易来找到此价格），因此总GAS成本为35121 <em>20 Gwei = 702,420 Gwei 或0.00070242 ETH。<br>由于用GAS要花钱，因此您可能需要设置您愿意花费的最大GAS上限。幸运的是，您可以设置“GAS限制”。如果交易最终需要的GAS超过指定的GAS上限，则交易将失败，而不是继续执行并消耗比您愿意支付的更多的GAS。要注意的一个副作用是，<em>*如果执行由于限制而最终失败，那么已花费的汽油量将不会退还给您</em></em>。</p><h4 id="调用智能合约功能以读取数据"><a href="#调用智能合约功能以读取数据" class="headerlink" title="调用智能合约功能以读取数据"></a>调用智能合约功能以读取数据</h4><p>您可以检查是否在Etherscan上收到了10 USDC，但请通过代码检查余额来确认这一点。<br>我们在src文件夹中的创建个新文件getFakeUSDCBalance.js，内容如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ethers = <span class="built_in">require</span>(<span class="string">"ethers"</span>);</span><br><span class="line"><span class="keyword">const</span> wallet = <span class="built_in">require</span>(<span class="string">"./wallet"</span>);</span><br><span class="line"><span class="keyword">const</span> provider = <span class="built_in">require</span>(<span class="string">"./provider"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> account = wallet.connect(provider);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Define FakeUSDC contract interface</span></span><br><span class="line">  <span class="keyword">const</span> usdc = <span class="keyword">new</span> ethers.Contract(</span><br><span class="line">    <span class="string">"0x4bB2ef39DD99A01BD5C11dDd25F890FeB45081e9"</span>,</span><br><span class="line">    [</span><br><span class="line">      <span class="string">"function balanceOf(address _owner) public view returns (uint256 balance)"</span>,</span><br><span class="line">    ],</span><br><span class="line">    account</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// get eth</span></span><br><span class="line">  <span class="keyword">const</span> ethBalance = <span class="keyword">await</span> account.getBalance();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`ETH Balance: <span class="subst">$&#123;ethers.utils.formatEther(ethBalance)&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Call FackUSDC balanceOf function</span></span><br><span class="line">  <span class="keyword">const</span> usdcBalance = <span class="keyword">await</span> usdc.balanceOf(account.address);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`USDC Balance: <span class="subst">$&#123;ethers.utils.formatUnits(usdcBalance, <span class="number">6</span>)&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main();</span><br></pre></td></tr></table></figure><p>USDC是ERC20代币，因此它包含ERC20规范中定义的所有方法。 balanceOf是其中之一，其接口直接来自规格。 balanceOf是一个只读函数，因此可以免费调用，不需要作为事务提交。 <strong>最后，重要的是要注意，USDC使用6个小数位精度，而许多其他ERC20令牌使用18个精度。</strong></p><p>您可以在此处了解有关Solidity函数的更多信息。<br>运行代码，现在您还将看到USDC余额：执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  solidity-tutorial git:(master) ✗ node src/getFakeUSDCBalance.js </span><br><span class="line">Mnemonic: viable glow tone pole input series weather slam blouse embark achieve position</span><br><span class="line">Address: 0x6598f11d48Da2bfA897d5Eb3968223f98dabc008</span><br><span class="line">ETH Balance: 0.9497621</span><br><span class="line">USDC Balance: 10.0   //这里拿到了 USDC返回的数量</span><br></pre></td></tr></table></figure><h4 id="转移ETH和USDC"><a href="#转移ETH和USDC" class="headerlink" title="转移ETH和USDC"></a>转移ETH和USDC</h4><p>现在，让我们看看如何使用帐户中的ETH和USDC。</p><h5 id="转移ETH"><a href="#转移ETH" class="headerlink" title="转移ETH"></a>转移ETH</h5><p>在src文件夹中创建transferETH.js并输入以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ethers = <span class="built_in">require</span>(<span class="string">"ethers"</span>);</span><br><span class="line"><span class="keyword">const</span> wallet = <span class="built_in">require</span>(<span class="string">"./wallet"</span>);</span><br><span class="line"><span class="keyword">const</span> provider = <span class="built_in">require</span>(<span class="string">"./provider"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> account = wallet.connect(provider);</span><br><span class="line">  <span class="keyword">let</span> to, value;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Parse the first argument - recipient address</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    to = ethers.utils.getAddress(args[<span class="number">0</span>]);</span><br><span class="line">  &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">`Invalid recipient address: <span class="subst">$&#123;args[<span class="number">0</span>]&#125;</span>`</span>);</span><br><span class="line">    process.exit(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Parse the second argument - amount</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    value = ethers.utils.parseEther(args[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (value.isNegative()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">`Invalid amount: <span class="subst">$&#123;args[<span class="number">1</span>]&#125;</span>`</span>);</span><br><span class="line">    process.exit(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> valueFormatted = ethers.utils.formatEther(value);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check that the account has sufficient balance</span></span><br><span class="line">  <span class="keyword">const</span> balance = <span class="keyword">await</span> account.getBalance();</span><br><span class="line">  <span class="keyword">if</span> (balance.lt(value)) &#123;</span><br><span class="line">    <span class="keyword">const</span> balanceFormatted = ethers.utils.formatEther(balance);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.error(</span><br><span class="line">      <span class="string">`Insufficient balance to send <span class="subst">$&#123;valueFormatted&#125;</span> (You have <span class="subst">$&#123;balanceFormatted&#125;</span>)`</span></span><br><span class="line">    );</span><br><span class="line">    process.exit(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Transferring <span class="subst">$&#123;valueFormatted&#125;</span> ETH to <span class="subst">$&#123;to&#125;</span>...`</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Submit transaction</span></span><br><span class="line">  <span class="keyword">const</span> tx = <span class="keyword">await</span> account.sendTransaction(&#123; to, value, <span class="attr">gasPrice</span>: <span class="number">20e9</span> &#125;);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Transaction hash: <span class="subst">$&#123;tx.hash&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> receipt = <span class="keyword">await</span> tx.wait();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Transaction confirmed in block <span class="subst">$&#123;receipt.blockNumber&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main(process.argv.slice(<span class="number">2</span>));</span><br></pre></td></tr></table></figure><p>这段代码虽然比以前的代码长，但实际上只是到目前为止<strong>所学到的一切的结合</strong>。该脚本接受两个命令行参数。<strong>第一个是收件人地址，第二个是发送金额</strong>。然后，它确保提供的地址有效，提供的金额不为负，<strong>并且帐户具有足够的余额以能够发送所请求的金额。然后，它提交交易并等待确认。</strong><br>使用我们之前创建的createWallet.js脚本<strong>创建一个新帐户，然后尝试向新地址汇款</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  solidity-tutorial git:(master) ✗ node src/createWallet.js </span><br><span class="line">Mnemonic: put among keep license two negative version uniform claw zebra health input</span><br><span class="line">Address: 0x7B6d22b2130e585f5dacb40dE9Ff9DbD23E5CDB0</span><br></pre></td></tr></table></figure><p>我们建了个新地址，在将0.1 ETH转移到 0x7B6d22b2130e585f5dacb40dE9Ff9DbD23E5CDB0 新地址上：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  solidity-tutorial git:(master) ✗ node src/transferETH.js 0x7B6d22b2130e585f5dacb40dE9Ff9DbD23E5CDB0 0.1</span><br><span class="line">Mnemonic: viable glow tone pole input series weather slam blouse embark achieve position</span><br><span class="line">Address: 0x6598f11d48Da2bfA897d5Eb3968223f98dabc008</span><br><span class="line">Transferring 0.1 ETH to 0x7B6d22b2130e585f5dacb40dE9Ff9DbD23E5CDB0...</span><br><span class="line">Transaction <span class="built_in">hash</span>: 0x91cb73c1ed608eec56eb6c81319bc232c8a0a7d0023eda87d1631ac45f29f49a</span><br><span class="line">Transaction confirmed <span class="keyword">in</span> block 21121715</span><br></pre></td></tr></table></figure><p>您可以在Etherscan中验证结果。</p><p>我们还要测试验证逻辑是否有效, 以下是一些无效的例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ node src/transferETH.js foo</span><br><span class="line">Address: 0xB3512cF013F71598F359bd5CA3f53C1F4260956a</span><br><span class="line">Invalid address: foo</span><br><span class="line">$ node src/transferETH.js 0xDdAC089Fe56F0a9C70e6a04C74DCE52F86a91e13 0.1.2</span><br><span class="line">Address: 0xB3512cF013F71598F359bd5CA3f53C1F4260956a</span><br><span class="line">Invalid amount: 0.1.2</span><br><span class="line">$ node src/transferETH.js 0xDdAC089Fe56F0a9C70e6a04C74DCE52F86a91e13 -0.1</span><br><span class="line">Address: 0xB3512cF013F71598F359bd5CA3f53C1F4260956a</span><br><span class="line">Invalid amount: -0.1</span><br><span class="line">$ node src/transferETH.js 0xDdAC089Fe56F0a9C70e6a04C74DCE52F86a91e13 100</span><br><span class="line">Address: 0xB3512cF013F71598F359bd5CA3f53C1F4260956a</span><br><span class="line">Insufficient balance to send 100.0 (You have 0.89328474)</span><br></pre></td></tr></table></figure><h3 id="转移USDC"><a href="#转移USDC" class="headerlink" title="转移USDC"></a>转移USDC</h3><p>您将能够复用大部分代码。主要区别在于USDC有6个小数位，并且您必须使用ERC20规格的传递函数来执行交易。您还需要将参数“ to”和“ value”传递给转让智能合约功能，而不是以太坊交易本身。在同一文件夹中创建transferUSDC.js并输入以下内容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ethers = <span class="built_in">require</span>(<span class="string">"ethers"</span>);</span><br><span class="line"><span class="keyword">const</span> wallet = <span class="built_in">require</span>(<span class="string">"./wallet"</span>);</span><br><span class="line"><span class="keyword">const</span> provider = <span class="built_in">require</span>(<span class="string">"./provider"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> account = wallet.connect(provider);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Define balanceOf and transfer functions in the contract</span></span><br><span class="line">  <span class="keyword">const</span> usdc = <span class="keyword">new</span> ethers.Contract(</span><br><span class="line">    <span class="string">"0x4bB2ef39DD99A01BD5C11dDd25F890FeB45081e9"</span>,</span><br><span class="line">    [</span><br><span class="line">      <span class="string">"function balanceOf(address _owner) public view returns (uint256 balance)"</span>,</span><br><span class="line">      <span class="string">"function transfer(address _to, uint256 _value) public returns (bool success)"</span>,</span><br><span class="line">    ],</span><br><span class="line">    account</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> to, value;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Parse the first argument - recipient address</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    to = ethers.utils.getAddress(args[<span class="number">0</span>]);</span><br><span class="line">  &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">`Invalid address: <span class="subst">$&#123;args[<span class="number">0</span>]&#125;</span>`</span>);</span><br><span class="line">    process.exit(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Parse the second argument - amount</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    value = ethers.utils.parseUnits(args[<span class="number">1</span>], <span class="number">6</span>);</span><br><span class="line">    <span class="keyword">if</span> (value.isNegative()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">`Invalid amount: <span class="subst">$&#123;args[<span class="number">1</span>]&#125;</span>`</span>);</span><br><span class="line">    process.exit(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> valueFormatted = ethers.utils.formatUnits(value, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check that the account has sufficient balance</span></span><br><span class="line">  <span class="keyword">const</span> balance = <span class="keyword">await</span> usdc.balanceOf(account.address);</span><br><span class="line">  <span class="keyword">if</span> (balance.lt(value)) &#123;</span><br><span class="line">    <span class="keyword">const</span> balanceFormatted = ethers.utils.formatUnits(balance, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.error(</span><br><span class="line">      <span class="string">`Insufficient balance to send <span class="subst">$&#123;valueFormatted&#125;</span> (You have <span class="subst">$&#123;balanceFormatted&#125;</span>)`</span></span><br><span class="line">    );</span><br><span class="line">    process.exit(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Transferring <span class="subst">$&#123;valueFormatted&#125;</span> USDC to <span class="subst">$&#123;to&#125;</span>...`</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Submit a transaction to call the transfer function</span></span><br><span class="line">  <span class="keyword">const</span> tx = <span class="keyword">await</span> usdc.transfer(to, value, &#123; <span class="attr">gasPrice</span>: <span class="number">20e9</span> &#125;);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Transaction hash: <span class="subst">$&#123;tx.hash&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> receipt = <span class="keyword">await</span> tx.wait();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Transaction confirmed in block <span class="subst">$&#123;receipt.blockNumber&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main(process.argv.slice(<span class="number">2</span>));</span><br></pre></td></tr></table></figure><p>尝试一下向新地址转1个FakeUSDC，它应该也可以正常工作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  solidity-tutorial git:(master) ✗ node src/transferUSDC.js 0x7B6d22b2130e585f5dacb40dE9Ff9DbD23E5CDB0 1</span><br><span class="line">Mnemonic: viable glow tone pole input series weather slam blouse embark achieve position</span><br><span class="line">Address: 0x6598f11d48Da2bfA897d5Eb3968223f98dabc008</span><br><span class="line">Transferring 1.0 USDC to 0x7B6d22b2130e585f5dacb40dE9Ff9DbD23E5CDB0...</span><br><span class="line">Transaction <span class="built_in">hash</span>: 0xb81d2844a086750f5b6e3a71778fc4362cc913cc9960aacdce7028c627e7f49d</span><br><span class="line">Transaction confirmed <span class="keyword">in</span> block 21121797</span><br></pre></td></tr></table></figure><p><strong>恭喜你，完成了！</strong></p><p>最后看看之前的地址还有多少个ETH和USDC</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  solidity-tutorial git:(master) ✗ node src/getFakeUSDCBalance.js                                        </span><br><span class="line">Mnemonic: viable glow tone pole input series weather slam blouse embark achieve position</span><br><span class="line">Address: 0x6598f11d48Da2bfA897d5Eb3968223f98dabc008</span><br><span class="line">ETH Balance: 0.84831602</span><br><span class="line">USDC Balance: 9.0    // 这里的USDC就剩下9个了</span><br></pre></td></tr></table></figure><p>在本教程中，您学习了如何<strong>生成帐户，查询余额，转移代币以及调用智能合约</strong>。您可能以为您对加密还不很了解，但是实际上您已经足够了解能够构建自己的加密钱包应用程序了。我们一直在编写命令行脚本来简化操作，但是如何使用基于Web的漂亮图形界面来完成作业来构建脚本呢？<br>在本教程系列的下一部分中，我们将使用Solidity从零开始编写我们自己的以太坊智能合约，并学习如何构建自己的可与USDC交换的代币。我们还将使用今天学到的技术与该合约进行互动。敬请关注。这个是之前作者的下一篇， 之后大杨会加上如何使用脚本自动化的调用Uniswap进行自动交易。</p><p>如果您对分布式金融DEFI的未来感兴趣，请关注Chaininout链因智能，大杨作为创始人，会努力的科普DEFI技能，促进生态发展。</p><p>作者原文中有CoinBase的免责声明，这里略过，以下也是常规的我们的免责声明。</p><p>以上表达的观点是作者的观点，并不代表Chaininout链因智能的观点和立场。信息仅用于一般教育目的，并不构成对金融产品的投资或其他建议。大杨和Chaininout对本篇内容上任何信息的准确性，完整性，及时性，适用性或有效性不做任何陈述，对于该信息的任何错误，遗漏或延误，或因其造成的任何损失，伤害或损害，概不负责。显示或使用。除非另有说明，否则本文提供的所有图像均为大杨的财产，所有商标均为其各自所有者的财产。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Nov 02 2020 15:59:06 GMT+0900 (Japan Standard Time) --&gt;&lt;p&gt;翻译者： 大杨， 链因智能CEO， 一家初创区块链技术公司，DEFI布道者。&lt;/p&gt;&lt;p&gt;技术点： DEFI，ETH，NODEJS，SOLIDITY&lt;/p&gt;&lt;p&gt;今天抽出了一些时间，翻译了CoinBase的&lt;a href=&quot;https://twitter.com/petejkim&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;em&gt;Pete Kim&lt;/em&gt;&lt;/a&gt; 写的【&lt;a href=&quot;https://blog.coinbase.com/introduction-to-building-on-defi-with-ethereum-and-usdc-part-1-ea952295a6e2&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Introduction to Building on DeFi with Ethereum and USDC — Part 1&lt;/a&gt;】DEFI编程入门学习的文章。&lt;/p&gt;&lt;p&gt;翻了下Pete Kim的twitter和他的github，发现是个全栈高手和社区活跃者，看上去应该是韩国人，技术很不错，人也很帅 😂。&lt;/p&gt;&lt;p&gt;最为美系的第一交易所CoinBase对整个Crypto生态的贡献是巨大的，本篇DEFI编程的入门文章也非常适合新手，看了有很想翻译的冲动，就花了2小时做了下整理，并在kovan的网络上实战了一把，对很多细节的地方做了补充，强烈推荐给大家。 经历DEFI，后续链因智能3年积累的相关技术都会进行开源，通过开源促进技术发展。&lt;/p&gt;
    
    </summary>
    
      <category term="blockchain" scheme="http://yangxinqi.com/categories/blockchain/"/>
    
    
      <category term="DEFI ETH NODEJS SOLIDITY" scheme="http://yangxinqi.com/tags/DEFI-ETH-NODEJS-SOLIDITY/"/>
    
  </entry>
  
  <entry>
    <title>数字金融数据科学系列-Tushare实战</title>
    <link href="http://yangxinqi.com/2020/07/28/%E6%95%B0%E5%AD%97%E9%87%91%E8%9E%8D%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%B3%BB%E5%88%97-Tushare%E5%AE%9E%E6%88%98/"/>
    <id>http://yangxinqi.com/2020/07/28/数字金融数据科学系列-Tushare实战/</id>
    <published>2020-07-28T07:47:23.000Z</published>
    <updated>2020-11-02T03:04:30.423Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Nov 02 2020 15:59:06 GMT+0900 (Japan Standard Time) --><h4 id="数据科学已经走入我们的生活"><a href="#数据科学已经走入我们的生活" class="headerlink" title="数据科学已经走入我们的生活"></a>数据科学已经走入我们的生活</h4><p>近年来AI很热，大部分人看AI的角度，或者说切入点都和实际商业场景有很大的落差，走的是存粹的优化，做的很研究，有时候模型很准，但是难以付之行动，比如金融模型常常是快速的杀进快速杀出，倒跌手续费还赔上时间。</p><p>大部分时候，做模型的成本太高，解决一个实际问题，需要不少预算来购买云端服务器，GPU资源来做大量运算，但是回归商业社会，不是实验室，不能重来，一切都得小心翼翼的向前，后退就意味着接受沉没成本，可能也因此给公司造成巨额损失。</p><p>经历过几个项目，也和不少同事一起共事，往往不是模型问题，大部分是数据问题，数据的获取和清洗，已经训练集的准备和调优基本上占去了70%的时间，模型选型基本不是重点。</p><p>所以说回来，还是先从数据科学的角度，来切入，底层基础搭好了，上层的模型才能稳固。</p><p>所以我认为，数据科学的本质： 就是认清现在能够拿到多少资源，想产出多大效益。</p><p>让我们一起来认识下数字金融模型下的数据科学的实际应用，本期给大家介绍Tushare数据组件。</p><p><img src="/images/tushare0.png?style=centerme" alt="Tushare"></p><a id="more"></a><h4 id="什么是Tushare"><a href="#什么是Tushare" class="headerlink" title="什么是Tushare"></a>什么是Tushare</h4><p>Tushare金融大数据开放社区，免费提供各类金融数据和区块链数据，助力智能投资和创新型投资。</p><p>平台特点：<br>数据丰富： 拥有丰富的数据维度，股票，基金，期货，数字货币等行情数据，公司财务数据，基金经历等基本面数据。</p><p>获取简单： SDK开发包支持语言，同时提供http restful接口，最大成都方便不同人群使用。</p><p>落地方便： 提供多种数据存储方式，如Mysql,MongoDB, HDF5,CSV等，为数据获取提供了性能保证。</p><p>Tushare自2014年12月起，经历了6年的发展，逐渐形成了自己的社区，与国内知名金融数据服务商，优矿，米筐，聚宽等量化平台合作，作者曾就职于通联数据，并和上海交大等高校建立合作，作为金融大数据的开源服务提供商，是一个很不错的选择。</p><h4 id="Tushare代码review"><a href="#Tushare代码review" class="headerlink" title="Tushare代码review"></a>Tushare代码review</h4><p>TuShare的github上的开源代码有段时间没有更新了。本次直接review安装后的lib代码，最新版本1.2.60。</p><p>github地址： <a href="https://github.com/waditu/tushare" target="_blank" rel="noopener">https://github.com/waditu/tushare</a></p><p>最核心的代码是 tushare/pro 目录下的 data_pro 以及 client 。 一个作为api调用的入口类，client作为api交互的client用来和服务器端收发数据用。</p><p><img src="/images/tushare1.png?style=centerme" alt="Tushare data_pro"></p><p>核心代码通过requests.post 拼接post params 的方式，发送请求，返回的结果用json的方式，解析并拼接成pandas Dataframe对象，返回给上层。</p><p><img src="/images/tushare2.png?style=centerme" alt="Tushare client"></p><p>其他的主要是util的一些辅助类，formula.py中有一些常见的指标方法，推荐可以使用。</p><p><img src="/images/tushare3.png?style=centerme" alt="Tushare formula"></p><h4 id="Tushare的数字金融数据介绍"><a href="#Tushare的数字金融数据介绍" class="headerlink" title="Tushare的数字金融数据介绍"></a>Tushare的数字金融数据介绍</h4><p>tushare的数字金融数据模块，包含基础数据，行情数据，资讯数据：<br>基础数据：<br>全球数字货币列表， 全球数字货币交易所，交易所交易对，以及项目和交易所LOGO， 很多交易所也停止维护了。</p><p>行情数据：<br>数字货币行情， 每日市值，交易所费率，比特币每日市值，比特币每日交易量，数字货币K线</p><p>资讯公告：<br>包含了，金色财经，巴比特，比世界，交易所公告，twitter数据， twitter大V数据等。</p><p>很不幸的是，大部分已经停止更新了。 最新的数据更新到6月10号，联系了维护的米哥，这块业务有个人维护，服务器费用的原因，已经暂停了部分数据的更新，缺钱来为开源的项目做贡献。 国内的开源项目，大杨也捐赠过几个，花了几千块rmb，在国内没有这样的捐助的氛围，很多开源项目很难维持下去。</p><h4 id="如何玩转TuShare"><a href="#如何玩转TuShare" class="headerlink" title="如何玩转TuShare"></a>如何玩转TuShare</h4><p>开箱即用：<br>使用pip来安装tushare:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install tushare</span><br></pre></td></tr></table></figure><p>安装好之后，开始些个测试来获取数据：<br>如果注册好了，在官方网站，申请了token了之后，就可以用token来访问api获取数据了：<br>这里申明那个交易所的那个时间段，哪个币种的数据，并将获取的数据打印出来。 最后保存成CSV文件。</p><pre><code>def test_coindayohlcv(self):    token = &apos;b3a30846b80**************:89db61bf236&apos;       pro = ts.pro_api(token)    ex = &apos;huobi&apos;    &quot;&quot;&quot;    1min    1分钟    5min    5分钟    15min    15分钟    30min    30分钟    60min    60分钟    daily    日线    week    周线    &quot;&quot;&quot;    df = pro.coinbar(exchange=ex, symbol=&apos;btcusdt&apos;, freq=&apos;daily&apos;, start_date=&apos;20200301&apos;, end_date=&apos;20200728&apos;)    print(df.columns)    print(df)    df.to_csv(&apos;{}.csv&apos;.format(ex), index=False)</code></pre><p><img src="/images/tushare4.png?style=centerme" alt="Tushare fetchohlcv"></p><h4 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h4><p>最后，测试了下指数数据，美股数据，期货数据，外汇数据，还有港股数据，作为学习来使用，还是挺适合的，但是作为生产环境的数据源头的话，还是推荐购买，米筐，聚宽等专业的数据服务商提供的稳定的数据源,当然每年的费用6-8万也是企业才能够承受的了的，个人还是相对困难。<br>数据的完整性还是没法保证，毕竟只有米哥一个人维护，而且通过大家捐助的方式，来收取一定的费用，来维持服务器，还有抓取程序。</p><p>作为开源的一份子，tushare还是做的不错的，坚持6年也相当的不容易，数据商业化，在中国还是相当难的。 大家多给一些鼓励，如果有用，并且学到东西，可以捐助下，捐助地址： <a href="https://waditu.com/document/1?doc_id=243。" target="_blank" rel="noopener">https://waditu.com/document/1?doc_id=243。</a></p><p>为开源点赞吧。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Nov 02 2020 15:59:06 GMT+0900 (Japan Standard Time) --&gt;&lt;h4 id=&quot;数据科学已经走入我们的生活&quot;&gt;&lt;a href=&quot;#数据科学已经走入我们的生活&quot; class=&quot;headerlink&quot; title=&quot;数据科学已经走入我们的生活&quot;&gt;&lt;/a&gt;数据科学已经走入我们的生活&lt;/h4&gt;&lt;p&gt;近年来AI很热，大部分人看AI的角度，或者说切入点都和实际商业场景有很大的落差，走的是存粹的优化，做的很研究，有时候模型很准，但是难以付之行动，比如金融模型常常是快速的杀进快速杀出，倒跌手续费还赔上时间。&lt;/p&gt;&lt;p&gt;大部分时候，做模型的成本太高，解决一个实际问题，需要不少预算来购买云端服务器，GPU资源来做大量运算，但是回归商业社会，不是实验室，不能重来，一切都得小心翼翼的向前，后退就意味着接受沉没成本，可能也因此给公司造成巨额损失。&lt;/p&gt;&lt;p&gt;经历过几个项目，也和不少同事一起共事，往往不是模型问题，大部分是数据问题，数据的获取和清洗，已经训练集的准备和调优基本上占去了70%的时间，模型选型基本不是重点。&lt;/p&gt;&lt;p&gt;所以说回来，还是先从数据科学的角度，来切入，底层基础搭好了，上层的模型才能稳固。&lt;/p&gt;&lt;p&gt;所以我认为，数据科学的本质： 就是认清现在能够拿到多少资源，想产出多大效益。&lt;/p&gt;&lt;p&gt;让我们一起来认识下数字金融模型下的数据科学的实际应用，本期给大家介绍Tushare数据组件。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/images/tushare0.png?style=centerme&quot; alt=&quot;Tushare&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="finance" scheme="http://yangxinqi.com/categories/finance/"/>
    
    
      <category term="数据科学 数字货币" scheme="http://yangxinqi.com/tags/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-%E6%95%B0%E5%AD%97%E8%B4%A7%E5%B8%81/"/>
    
  </entry>
  
  <entry>
    <title>进入数字金融行业</title>
    <link href="http://yangxinqi.com/2020/06/22/%E8%BF%9B%E5%85%A5%E6%95%B0%E5%AD%97%E9%87%91%E8%9E%8D%E8%A1%8C%E4%B8%9A/"/>
    <id>http://yangxinqi.com/2020/06/22/进入数字金融行业/</id>
    <published>2020-06-22T04:54:59.000Z</published>
    <updated>2020-06-22T05:02:31.725Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Nov 02 2020 15:59:06 GMT+0900 (Japan Standard Time) --><p>迷茫的时候，不知道自己的未来是如何的，做下人生规划，开始找份工作，从IT行业，进入数字金融行业。</p><p>以”Quantamental”为主线，开始努力学习，重新规划自己的人生。 需要补的英语，还有编程能力，还有AI能力。</p><p>36岁，从新开始自己的人生。 对于编程，是热爱的，数字金融可以改变生活的状态，做自己喜欢而且能够改变生活条件的事情，是很值得的，5年规划，希望5年之后，自己不会后悔自己做的选择。 因为后悔也没用，自己选的路，在这么艰难都要走下去。</p><p><img src="/images/quantamental.jpg?style=centerme" alt="数字金融Quantamental!"></p><h3 id="数字金融我来啦！"><a href="#数字金融我来啦！" class="headerlink" title="数字金融我来啦！"></a>数字金融我来啦！</h3><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Nov 02 2020 15:59:06 GMT+0900 (Japan Standard Time) --&gt;&lt;p&gt;迷茫的时候，不知道自己的未来是如何的，做下人生规划，开始找份工作，从IT行业，进入数字金融行业。&lt;/p&gt;&lt;p&gt;以”Quant
      
    
    </summary>
    
      <category term="finance" scheme="http://yangxinqi.com/categories/finance/"/>
    
    
      <category term="数字金融" scheme="http://yangxinqi.com/tags/%E6%95%B0%E5%AD%97%E9%87%91%E8%9E%8D/"/>
    
  </entry>
  
  <entry>
    <title>直面失败消除焦虑设计人生</title>
    <link href="http://yangxinqi.com/2020/06/22/%E7%9B%B4%E9%9D%A2%E5%A4%B1%E8%B4%A5%E6%B6%88%E9%99%A4%E7%84%A6%E8%99%91%E8%AE%BE%E8%AE%A1%E4%BA%BA%E7%94%9F/"/>
    <id>http://yangxinqi.com/2020/06/22/直面失败消除焦虑设计人生/</id>
    <published>2020-06-22T02:28:21.000Z</published>
    <updated>2020-06-22T04:52:43.567Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Nov 02 2020 15:59:06 GMT+0900 (Japan Standard Time) --><p>今天早晨，翻看朋友圈，看到lynne发到一篇读书笔记《斯坦福大学人生设计课》，看了下分析的读书笔记发现是一本蛮有见解的书，从另外的角度，来缓解焦虑，同时用简明扼要的大纲，来一步一步说明，如何克服迷茫，设计自己人生的重要性，而且给出了实际做法， 引起的读它的兴趣。</p><h3 id="读书是缓解的焦虑的好办法"><a href="#读书是缓解的焦虑的好办法" class="headerlink" title="读书是缓解的焦虑的好办法"></a>读书是缓解的焦虑的好办法</h3><p>最近疫情影响，还有创业的行业赛代也都经历的变化，思想和心态都跌入了低谷，也背上了很大的债务， 人也变得迷茫了，尝试了做新的领域，尝试了积极主动，但是内心深处，依旧是那么的迷茫。</p><p>跨过内心的徘徊，直面市场。失败没有大不了的，都是人生的一个阶段而已。</p><p><img src="/images/shejirensheng.jpg?style=centerme" alt="失败免疫!"></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Nov 02 2020 15:59:06 GMT+0900 (Japan Standard Time) --&gt;&lt;p&gt;今天早晨，翻看朋友圈，看到lynne发到一篇读书笔记《斯坦福大学人生设计课》，看了下分析的读书笔记发现是一本蛮有见解的书，从
      
    
    </summary>
    
      <category term="other" scheme="http://yangxinqi.com/categories/other/"/>
    
    
      <category term="人生" scheme="http://yangxinqi.com/tags/%E4%BA%BA%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>整理下简历</title>
    <link href="http://yangxinqi.com/2020/05/27/%E6%95%B4%E7%90%86%E4%B8%8B%E7%AE%80%E5%8E%86/"/>
    <id>http://yangxinqi.com/2020/05/27/整理下简历/</id>
    <published>2020-05-26T18:45:47.000Z</published>
    <updated>2020-05-26T19:04:57.473Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Nov 02 2020 15:59:06 GMT+0900 (Japan Standard Time) --><h3 id="简历"><a href="#简历" class="headerlink" title="简历"></a>简历</h3><p>停下来，整理下简历，继续前行，用jekyll生成了个新的，这10年来，做了不少项目，有4个开源的，接下来把项目中用到的开源出来。</p><p>体现出自己的价值，从整理简历开始，阳光的面对接下来的路。 让家里人过的幸福是最终的。</p><p><a href="/resume/">xinqiyang’s resume</a></p><p>重新进入职场，躲过危机，关注，数据，流量和交易。 让交易飞起来，才有可能实现理想。</p><p>github pages 会自动执行构建，出错就不更新了。</p><p>好吧，好久没更新了。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Nov 02 2020 15:59:06 GMT+0900 (Japan Standard Time) --&gt;&lt;h3 id=&quot;简历&quot;&gt;&lt;a href=&quot;#简历&quot; class=&quot;headerlink&quot; title=&quot;简历&quot;&gt;&lt;/a&gt;简历&lt;/h
      
    
    </summary>
    
      <category term="other" scheme="http://yangxinqi.com/categories/other/"/>
    
    
      <category term="简历" scheme="http://yangxinqi.com/tags/%E7%AE%80%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>2019年终总结</title>
    <link href="http://yangxinqi.com/2020/01/04/2019%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <id>http://yangxinqi.com/2020/01/04/2019年终总结/</id>
    <published>2020-01-03T18:14:43.000Z</published>
    <updated>2020-01-03T18:21:04.586Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Nov 02 2020 15:59:06 GMT+0900 (Japan Standard Time) --><h3 id="2019年，年终总结"><a href="#2019年，年终总结" class="headerlink" title="2019年，年终总结"></a>2019年，年终总结</h3><p>痛并快乐着的创业历程，战到最后，孤身一人，战至一兵一卒。</p><p>最后：</p><h1 id="卒"><a href="#卒" class="headerlink" title="卒"></a>卒</h1><p><img src="/images/20192020.png?style=centerme" alt="come back!"></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Nov 02 2020 15:59:06 GMT+0900 (Japan Standard Time) --&gt;&lt;h3 id=&quot;2019年，年终总结&quot;&gt;&lt;a href=&quot;#2019年，年终总结&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="other" scheme="http://yangxinqi.com/categories/other/"/>
    
    
      <category term="创业" scheme="http://yangxinqi.com/tags/%E5%88%9B%E4%B8%9A/"/>
    
  </entry>
  
  <entry>
    <title>低风险创业阅读笔记</title>
    <link href="http://yangxinqi.com/2019/10/25/%E4%BD%8E%E9%A3%8E%E9%99%A9%E5%88%9B%E4%B8%9A%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <id>http://yangxinqi.com/2019/10/25/低风险创业阅读笔记/</id>
    <published>2019-10-25T05:52:06.000Z</published>
    <updated>2019-10-28T16:14:05.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Nov 02 2020 15:59:06 GMT+0900 (Japan Standard Time) --><h3 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h3><p>经典名言： 千万不要卖房创业！ 千万不要卖房创业！ 千万不要卖房创业！</p><p>实践名言： 创业可能亏掉一套房！创业可能亏掉一套房！创业可能亏掉一套房！</p><p><img src="/images/chuxin.png?style=centerme" alt="img"></p><h3 id="读书笔记"><a href="#读书笔记" class="headerlink" title="读书笔记"></a>读书笔记</h3><h4 id="创业的初衷，你到底是为了什么？"><a href="#创业的初衷，你到底是为了什么？" class="headerlink" title="创业的初衷，你到底是为了什么？"></a>创业的初衷，你到底是为了什么？</h4><p>做企业最重要的是现金流，而不是净资产。</p><p>从最本质的肾上腺素粉笔，到感受到爱，善意拥抱世界，拥抱创业的过程。</p><p>出发点和初衷，带着爱与希望，而不是为了金钱，往往初衷不对会欲速不达，对于下属严苛，失去很多。</p><p>性格好的人，结果不会坏到哪里去。</p><a id="more"></a><h4 id="创业实践中"><a href="#创业实践中" class="headerlink" title="创业实践中"></a>创业实践中</h4><p>优雅的解决一个社会问题，才能影响寻常百姓的日常生活。</p><p>正确的时间，正确的姿势解决一个社会问题，是对的事情，也要天时，地利，人和。</p><p>创业一个是一件令人愉悦的事情， 花时间工作，然后剩下的时间陪孩子和家人。 最完美的创业模式，打造个人IP，同时还能够获得收入，这个过程是互利互惠的。</p><p>克服心理问题，把创业视为人生的修炼。</p><p>从用户抱怨的中，发现低风险创业的机会， 身边的人如何抱怨的，找到真正的需求点，然后着手解决。</p><p>做乙方的生意模式非常危险（外包，咨询），当你江郎才尽的那天，就是公司倒闭的日子。</p><p><strong>痛点： 挖掘小数据满足用户需求</strong></p><p>产品就是小数据加上一个好的用户体验的呈现， 大部分只是改变产品包装，而不是改变产品。</p><p>洞察的力量，进入实际场景，观察用户同时能够给出解决方案。</p><p>忘掉你的创始人身份，开始体验产品，作为第三个灵感来源。 <strong>亲自试用自己的产品，像小白一样体验产品</strong>。把产品做简单。</p><p>找到宏大的变革目标MTP， 找到目标市场足够大，存在问题，存在变革，解决的空间。</p><p><strong>我的MTP是什么？</strong> 需要详细的描述出来。</p><p>在客户最痛的点上突破，痛点到产品的一见钟情。</p><p>识别真痛点和假痛点，客户真的有购买动机，能够在客户口渴的时候递出水，递给他的是半瓶救命水。</p><p>没有秘密是创业者最大的风险，核心竞争力在哪里？</p><p>铁杆粉丝，1000个铁杆，拉起你的产品，用户是创业者的衣食父母，也是你的力量之源。</p><p>超越竞争的“10倍好”原则，如何才能拥有10倍的增长。</p><p>秘密是一个慢慢积累的过程，积累一批核心用户，有了口碑。</p><p>时间是最需要的东西，市场不会等待你和你的企业壮大，你只能自己真去时间，孕育出秘密之花。</p><p>一切没有找对秘密的创业都是谋财害命。 谋投资人，创始人的才，害员工的命。</p><p><strong>验证商业秘密最好的方法是卖而不是问。</strong></p><p>能够让客户带来客户的销售效果，才能让产品的销售持续增长。</p><p>足够价值的服务是会尖叫的。</p><p>打造最小化可行性的产品，幸苦做出来的产品没有人用，悲剧了。 得不到客户认可，才是创业公司最不该犯的错误。</p><p>好的用户体验，最小化，可行性。 少成本，又好用。</p><p>融资需有度，钱不是越多越好。 在发现商业秘密的过程中，一定要把现金流放在最重要的位置。</p><p>正向现金流，不靠融资续命。有不断流进来的现金，让自己的公司尽可能处于盈利状态。</p><p>反脆弱的结构设计，人和创业秘密，商业节奏和团队管理手段，离开特定环境和北京，都难以复制。</p><p>所谓反脆弱，其实就是如何应对黑天鹅时间，从随时可能发生的 不确定性中受益。</p><p><strong>人类总是过度相信经验，而不知道黑天鹅事件出现一次就足以颠覆一切。 而意外的必然性，一定会发生。</strong></p><p>黑天鹅事件，带有巨大的冲击性，会产生极端后果。发生后，可解释可预测。</p><p>创业的脆弱性越强，风险也越来越大。</p><p>具备反脆弱的能力，不等于坚强不屈，在必然出现的不确定风险发生时保全自我，还能让其变得更好，更有力量。</p><p>合作让双方都具备反脆弱能力，在不确定中，找到生存点和发展点。</p><p><strong>设计反脆弱的商业结构，成本有底线，收益无上限。</strong></p><p>找到问题，设计一套反脆弱的模型，IP生意，需要看到本质。</p><p>找到“非对称交易”的机会， 这个世界是曲线的。 损失和收益并不完全对应。</p><p>创业者可以不断试错，不断调整，以期实现收益最大化和风险最小化。</p><p>固定资产不产生任何收益，靠亏损维持不是长久之计。</p><p>创业需要情怀，员工有匠人精神。 情怀，热爱，真诚，专注。</p><p><strong>创业最痛苦的事，莫过于只把事业当作谋生的工具。</strong></p><p>没有经历过痛苦，不懂得欢乐。情怀的价值所在，人要经历痛苦才明白。</p><p>配置你的“创业杠铃”， 好的企业家不是善于冒风险，而是善于控制风险。</p><p>你在一个领域安全，另外一个领域才能创新。</p><p>修炼“君子不器”。让你成为全方位，多向度的人。不能够一条路走到黑，要有选择权。</p><p>只要我们能够在内容层面不断精进突破，就不担心某一天会遭遇不确定性。</p><p>通过思维方式的转变，扩大自己的生意的选择空间，让自己的风险发生时，有可以选择杠铃的另一端。</p><p>大前提保证自己的安全，成功最好，不成功也不会伤经动骨。</p><p>能力陷阱和资源陷阱，先看自己的能力和资源做什么，而不是设计一套反脆弱的商业结构。</p><p>赋能生物态团队，创业是孤独而寒冷的路，会渐渐失去热情而难以持久，容易迷失。需要“群智涌现，彼此协同”</p><p>创业团队是复杂体系，不能机械化管理，需要打造应对不确定性的敏捷团队。 需要为社会做贡献，不断成长。 要善待一起的兄弟，也不能过于安稳。</p><p>重新定义成功，成功的思维模式，倡导终生成长。 能够守住底线，让员工犯错误，能够一起承担错误。</p><p>建员工迟早会离开团队，离开才是最大的不稳定。</p><p>有些创业者格局不够大，从气量就可以看出来。</p><p>创业过程中，核心员工，兼职的千万不能要，三心二意的坚决清理。</p><h4 id="突产品"><a href="#突产品" class="headerlink" title="突产品"></a>突产品</h4><p>十万人说不错，不如一百人尖叫。 优质的产品，偏向于营销推广。</p><p>客户只会给你一次机会，学会珍惜自己的品牌。</p><p>不着急打广告和买流量。</p><p>产品重要，用户才会分享。</p><p>让客户为你带来新的客户。</p><p>让用户主动分享，专业化，简单化，情绪化，可视化，故事化。</p><p>广告是必须做的，广告要持续，定下来不能经常变。</p><p>唤醒大众情绪，才能被大量传播。</p><p>用故事打败只是的诅咒， 将一个好的故事，好想法和好故事，好IP才行。</p><p>学会用幂次法则思考，线性思想被幂次法则取代。 头部公司带来偏好链接，形成马太效应。 想法流，实现指数型增长。</p><h4 id="突运营"><a href="#突运营" class="headerlink" title="突运营"></a>突运营</h4><p>让边际成本为零的运营方法，增加一个用户所需要支付的成本，决定创业是否成功的关键。</p><p>内容和程序，生产的成本是一样的， 可以卖的人越来越多。</p><p><strong>只运营信息，</strong>杜绝将大部分精力用于维护用户和商家的平台系统，边际成本自然能够大幅降低。</p><p>学会撬动资源刚刚，用梦想感召他人，MTP，宏大的变革目标，用你的梦想去感召更多的人，一起实践这个梦想。</p><p>对于团队培养2个接班人。</p><p>找到指数型增长的关键节点，列出工作流，要点，注意事项。 清单管理时间，找出关键点。</p><p>手里有收入更好的更从容的解决问题，提高用户体验，找代理商。 在全球范围内找最合适的代理商。</p><p><strong>二周一个关键点，找到方向有实际结果。</strong></p><h4 id="保增长"><a href="#保增长" class="headerlink" title="保增长"></a>保增长</h4><p>搭建跨部门的增长小组，增长这件事人不能多。</p><p><strong>只有增长，最重要</strong></p><p>只有增长才能创造奇迹</p><p>下2周多目标，看这周的实际数据</p><p>企业的下一个增长方向应该取决于数据，它决定了你该做什么事，不该做什么事。</p><p>让增长小组进行实验，监控，反馈。 6个角色，增长负责人，产品经理，工程师，营销专员，数据分析师和设计师。 获得支持，多实验，高效沟通。</p><p>天下武功，唯快不破。</p><p>唯一限制我们的是我们的想象力。</p><h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>做最好的自己，终生成长，创业也许是一个过程，也是会持续一生，但是 勿忘初心，用爱前行。 我错了，我改正。 樊登读书真心很不错，强烈推荐下。 微信读书，每天的时间应该都给他。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Nov 02 2020 15:59:06 GMT+0900 (Japan Standard Time) --&gt;&lt;h3 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h3&gt;&lt;p&gt;经典名言： 千万不要卖房创业！ 千万不要卖房创业！ 千万不要卖房创业！&lt;/p&gt;&lt;p&gt;实践名言： 创业可能亏掉一套房！创业可能亏掉一套房！创业可能亏掉一套房！&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/images/chuxin.png?style=centerme&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;&lt;h3 id=&quot;读书笔记&quot;&gt;&lt;a href=&quot;#读书笔记&quot; class=&quot;headerlink&quot; title=&quot;读书笔记&quot;&gt;&lt;/a&gt;读书笔记&lt;/h3&gt;&lt;h4 id=&quot;创业的初衷，你到底是为了什么？&quot;&gt;&lt;a href=&quot;#创业的初衷，你到底是为了什么？&quot; class=&quot;headerlink&quot; title=&quot;创业的初衷，你到底是为了什么？&quot;&gt;&lt;/a&gt;创业的初衷，你到底是为了什么？&lt;/h4&gt;&lt;p&gt;做企业最重要的是现金流，而不是净资产。&lt;/p&gt;&lt;p&gt;从最本质的肾上腺素粉笔，到感受到爱，善意拥抱世界，拥抱创业的过程。&lt;/p&gt;&lt;p&gt;出发点和初衷，带着爱与希望，而不是为了金钱，往往初衷不对会欲速不达，对于下属严苛，失去很多。&lt;/p&gt;&lt;p&gt;性格好的人，结果不会坏到哪里去。&lt;/p&gt;
    
    </summary>
    
      <category term="other" scheme="http://yangxinqi.com/categories/other/"/>
    
    
      <category term="创业" scheme="http://yangxinqi.com/tags/%E5%88%9B%E4%B8%9A/"/>
    
  </entry>
  
  <entry>
    <title>践行时间管理</title>
    <link href="http://yangxinqi.com/2019/10/21/%E8%B7%B5%E8%A1%8C%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/"/>
    <id>http://yangxinqi.com/2019/10/21/践行时间管理/</id>
    <published>2019-10-21T02:28:55.000Z</published>
    <updated>2019-10-28T16:13:52.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Nov 02 2020 15:59:06 GMT+0900 (Japan Standard Time) --><h3 id="回归"><a href="#回归" class="headerlink" title="回归"></a>回归</h3><p>经历了近2年的全力创业历程，发现自己欠缺的太多太多。从本质上来讲，是自己的心态以及具体的执行层面，很多事情的抉择很容易受到心态的干扰。 做事情欠缺全盘考虑。</p><p>回到内心初衷， 进行深刻的反省。</p><p>先从时间管理开始，忙是一种状态，一直忙碌好几年，遵循着不好的时间分配原则，导致效率低下，还有花在某个点上的时间太多，导致面上整理出现不协调。 买了微信读书的会员，不知不觉，以及收藏了近300本书，认真的看着这些书，为自己充充电，才能继续前行。</p><p>​ <img src="/images/self_up.jpg?style=centerme" alt="img"></p><a id="more"></a><h3 id="时间管理和生活态度"><a href="#时间管理和生活态度" class="headerlink" title="时间管理和生活态度"></a>时间管理和生活态度</h3><p>好的经验别人告诉你，但是你自己不实践，没有意义。</p><p>时间对于每个人是一样的， 其多少是效率问题，更关乎自己的生活态度。</p><h3 id="一些不好的例子"><a href="#一些不好的例子" class="headerlink" title="一些不好的例子"></a>一些不好的例子</h3><p>残酷错误： 不整理。</p><p>解决方法： 整理东西，尽量少买，丢掉不需要的。 各种购物软件，淘宝，京东，尽量少打开，还有小红书。</p><p>残酷错误：拖来拖去，事情都在那里，只多不少</p><p>解决方法： 拖延因为没有开始，开始起来就好了。 行动吧。 马上行动，马上行动，马上行动。</p><p>残酷错误： 承若的大事情，不能善始善终</p><p>解决方法： 大事情分解成小事情，身体力行。 行动行动，先把小事情做好。</p><p>残酷错误： 决策遇上选择恐惧症</p><p>解决方法： 每天晚上列出明天应该必须做的5件最重要的事情。</p><p>残酷错误： 很多待办TODO列表</p><p>解决方法： 把待办变成必办，其他的事情就会迎刃而解。</p><p>残酷错误： 各种干扰以及时间顺序不当</p><p>解决方法： 有些事情说不，整理生活碎片，想干扰说不， 不给干扰开口的机会。</p><p>残酷错误： 忙得焦头烂额，嘴上还在说好好好</p><p>解决方法： 不经常说不，问题很严重， 不管是谁的拜托，应该权衡之后在去做。</p><p>残酷错误： 网络世界里经常欲罢不能</p><p>解决方法： 离开位置，离开电脑，说不，网络上的事情，尽量少打开各类必须软件。 特别是 微信，微博，twitter之类的，以及各种的视频软件。 整理自己的电脑及手机，把消耗自己时间的APP全部干掉，电脑上的不用的统统卸载。</p><p>残酷错误： 做了很多低于自己时间估值的事情</p><p>解决方法： 事情可不可以分出去给其他人做，低于自己时间价值的事情，坚决不做。</p><p>残酷错误： 开会花太多的时间</p><p>解决方法： 小会5分钟， 大会30-45分钟，切记不要超过45分钟。</p><p>残酷错误： 大部分时间在工作上，在客户那边</p><p>解决方法： 留时间给自己以及家人，这个世界安排第一优先，这样你才能做的更好。</p><p>残酷错误： 没有陪孩子，教育的时间太少</p><p>解决方法： 和家人和孩子一起用早餐和晚餐，具体询问一些具体的事情，学校还有朋友啊，相互问候，陪孩子玩游戏，单独带他们出去玩， 给他们分配清单培养他们独立购买的能力。 星期天一家人聚在床上说话，增加家庭温馨感。</p><p>残酷错误： 好久没有一家人旅行了</p><p>解决方法： 规划一个假期，提前规划好，不要因为公事而影响一家人的出游放松。 提早计划。</p><p>残酷错误： 没有在理财上花时间</p><p>解决方法： 定期一个月，一个季度，半年，一年，对家庭财务进行整理，列出花费，到年末了需要进行年末调整了。</p><p>残酷错误： 没有花时间在锻炼身体上</p><p>解决方法： 看着自己的大肚子，每天锻炼坚持10分钟，比如平板撑，还有做收肚子的5组运动，先锻炼起来，去掉大肚子。</p><p>残酷错误： 没有给自己留时间</p><p>解决方法： 自我日，关键日，事物日要分清，这样才能规划好，自我日最优先，先把自己的时间安排好，才能够做好关键和事物安排。 聚集5种最大收益的活动，每天必须完成5种活动。</p><p>残酷错误： 思想没有升级</p><p>解决方案： 对自己的细节，行为，举止，外观气质等没有很好的关注。 需要做到 少即是多， 倾听少说，不要乱买了， 特别是那些便宜的所谓性价比高的东西，必须买顶配，而且尽量少买。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>需要多花时间，看书，总结，践行自己的修改，类似程序写了后的review和打patch是一样的。 人需要打补丁，需要不断的循序渐进的优化自己的行为，提高自己的气质的，最基本的是做好自己的时间安排，将大部分的时间花在自己有益的事情上面。 对自己好了，只有自己好了，才能够带动其他人，好起来。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Nov 02 2020 15:59:06 GMT+0900 (Japan Standard Time) --&gt;&lt;h3 id=&quot;回归&quot;&gt;&lt;a href=&quot;#回归&quot; class=&quot;headerlink&quot; title=&quot;回归&quot;&gt;&lt;/a&gt;回归&lt;/h3&gt;&lt;p&gt;经历了近2年的全力创业历程，发现自己欠缺的太多太多。从本质上来讲，是自己的心态以及具体的执行层面，很多事情的抉择很容易受到心态的干扰。 做事情欠缺全盘考虑。&lt;/p&gt;&lt;p&gt;回到内心初衷， 进行深刻的反省。&lt;/p&gt;&lt;p&gt;先从时间管理开始，忙是一种状态，一直忙碌好几年，遵循着不好的时间分配原则，导致效率低下，还有花在某个点上的时间太多，导致面上整理出现不协调。 买了微信读书的会员，不知不觉，以及收藏了近300本书，认真的看着这些书，为自己充充电，才能继续前行。&lt;/p&gt;&lt;p&gt;​ &lt;img src=&quot;/images/self_up.jpg?style=centerme&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="other" scheme="http://yangxinqi.com/categories/other/"/>
    
    
      <category term="other" scheme="http://yangxinqi.com/tags/other/"/>
    
  </entry>
  
  <entry>
    <title>一年的产出</title>
    <link href="http://yangxinqi.com/2019/08/02/%E4%B8%80%E5%B9%B4%E7%9A%84%E4%BA%A7%E5%87%BA/"/>
    <id>http://yangxinqi.com/2019/08/02/一年的产出/</id>
    <published>2019-08-02T06:51:49.000Z</published>
    <updated>2019-10-28T16:13:30.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Nov 02 2020 15:59:06 GMT+0900 (Japan Standard Time) --><p>​ <img src="/images/projects.png?style=centerme" alt="img"></p><h3 id="一年积累下来"><a href="#一年积累下来" class="headerlink" title="一年积累下来"></a>一年积累下来</h3><p>23个项目，一年下来，忙活代码行数，超过10w+。 涵盖了数据库， app的， 后端模块， 发布模块，以及前端，还有网站，部署等等。</p><p>使用了包含java,python,php,js,sh,go, sodility 共计7种语言。</p><p>产品产品发布后，提供给用户使用，接下来做好定价后，开始买卖吧。</p><p>产品需要市场的体验，才行的。</p><p>在国内有各种卖法，如何让用户能够更容易的找到我们，还是很关键的。</p><a id="more"></a><h3 id="拥抱开源"><a href="#拥抱开源" class="headerlink" title="拥抱开源"></a>拥抱开源</h3><p>接下来，还是做一个开源的项目，让大家可以用的很happy，让大家能够放心，这样的话。</p><p>接下来我们的项目 <a href="https://github.com/coinphd" target="_blank" rel="noopener">https://github.com/coinphd</a> 项目都在这里，欢迎大家参观。</p><h3 id="拥抱区块链"><a href="#拥抱区块链" class="headerlink" title="拥抱区块链"></a>拥抱区块链</h3><p>拥抱区块链，在区块链上，做自己的应用，服务市场，服务客户。这个才是我们应该做的，这样的话，成本可以减少下来，但是我们的产品，能够得到大家的认同，这样才能够活下来，走出去。</p><h3 id="技术成就梦想"><a href="#技术成就梦想" class="headerlink" title="技术成就梦想"></a>技术成就梦想</h3><p>开发和运营集合起来，ansible很好用，docker也很好用，用技术实现梦想，才是最近这个阶段应该做的事情的。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Nov 02 2020 15:59:06 GMT+0900 (Japan Standard Time) --&gt;&lt;p&gt;​ &lt;img src=&quot;/images/projects.png?style=centerme&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;&lt;h3 id=&quot;一年积累下来&quot;&gt;&lt;a href=&quot;#一年积累下来&quot; class=&quot;headerlink&quot; title=&quot;一年积累下来&quot;&gt;&lt;/a&gt;一年积累下来&lt;/h3&gt;&lt;p&gt;23个项目，一年下来，忙活代码行数，超过10w+。 涵盖了数据库， app的， 后端模块， 发布模块，以及前端，还有网站，部署等等。&lt;/p&gt;&lt;p&gt;使用了包含java,python,php,js,sh,go, sodility 共计7种语言。&lt;/p&gt;&lt;p&gt;产品产品发布后，提供给用户使用，接下来做好定价后，开始买卖吧。&lt;/p&gt;&lt;p&gt;产品需要市场的体验，才行的。&lt;/p&gt;&lt;p&gt;在国内有各种卖法，如何让用户能够更容易的找到我们，还是很关键的。&lt;/p&gt;
    
    </summary>
    
      <category term="devops" scheme="http://yangxinqi.com/categories/devops/"/>
    
    
      <category term="devops" scheme="http://yangxinqi.com/tags/devops/"/>
    
  </entry>
  
  <entry>
    <title>创业一周年快乐</title>
    <link href="http://yangxinqi.com/2019/08/02/%E8%AE%B0%E5%9B%9E%E5%9B%BD%E5%88%9B%E4%B8%9A%E7%9A%84%E4%B8%80%E5%B9%B4/"/>
    <id>http://yangxinqi.com/2019/08/02/记回国创业的一年/</id>
    <published>2019-08-02T05:38:33.000Z</published>
    <updated>2019-10-28T16:13:44.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Nov 02 2020 15:59:06 GMT+0900 (Japan Standard Time) --><p>​</p><h3 id="一周年快乐"><a href="#一周年快乐" class="headerlink" title="一周年快乐"></a>一周年快乐</h3><p>2019年8月，距离去年回国创业已经整整一年了，一年里，时局变迁，做一个流水账的记录。 创业犹如踩坑，经历过，才知道，原来这么小的坑，有这么大，足以吞噬，在让你浴火重生。</p><p>帮助过的人，应该感恩，坑过的人，依旧应该感恩。</p><p>​ <img src="/images/yizhounian.png?style=centerme" alt="img"></p><a id="more"></a><h3 id="回到原点"><a href="#回到原点" class="headerlink" title="回到原点"></a>回到原点</h3><p>也许开始就是错的，那接下来不管怎么做都是错的。起点的配置已经决定了未来的结局。</p><h3 id="不能去撑"><a href="#不能去撑" class="headerlink" title="不能去撑"></a>不能去撑</h3><p>及时止损，受用一生，当一个团队，没有斗志，那么应该选择重来，而不应该撑。 可以的人，可以的事，自然而然，当你去硬撑的时候，未必有好的结果，反而会带来更多的伤害，不管是金钱上，还是精神上的。 闻到坏味道，就应该立即处理，OUT出团队，这个是最最关键的。</p><h3 id="孤独感"><a href="#孤独感" class="headerlink" title="孤独感"></a>孤独感</h3><p>当团队没有人的时候，应该控制好节奏，就算在孤独，也应该一步一步，不能忽视指标，一切以指标论英雄，才是最好的。 不管在孤独，也不应该失去心智，创业从来都是孤独的，很多时候，悲欢亦不可与人分享，在亲密的团队都是如此。 作为创始人，应该坚持走自己的路。</p><h3 id="指标指标"><a href="#指标指标" class="headerlink" title="指标指标"></a>指标指标</h3><p>指标指标，自己引以为要的 数据，流量，交易。 还是一直停留在数据上。</p><p>数据： 有用的数据，高质量的内容， 可以销售的服务，都算。</p><p>流量： 每天多少pv，多少uv，都在哪里，跑不掉的，一切以实际的数据说话，都在这边。</p><p>交易： 每天多少笔交易。 实际利润率多少，成单多少，未成单多少。</p><p>必须严格执行。 一切必须严格的执行。 对团队的懒散，是对自己最大的伤害。 所以一切回归初心。</p><h3 id="责任感"><a href="#责任感" class="headerlink" title="责任感"></a>责任感</h3><p>对投资人负责，也是对自己家里人负责。 减负之后，感觉好多了。没有那么多的负担，不用每天起来寻思着，今天公司花了多少钱，还有哪些事情没有做，还需要做哪些事情？</p><h3 id="网红思考"><a href="#网红思考" class="headerlink" title="网红思考"></a>网红思考</h3><p>现在的网红经济， 是一个很新颖的领域，一个小团队，发挥自己的能动性，带来不错的收入。 这里的网红，不单单指的是现在所谓的直播网红，是个泛指。其实通过网络的个性活动，还是能够带来不少流量，这些流量和这些粉丝还是可以变现的。 走小团队的路，在现在资本惨淡的环境下，还是很切合实际的。</p><h3 id="动动笔头"><a href="#动动笔头" class="headerlink" title="动动笔头"></a>动动笔头</h3><p>最近一年，一直在写代码，不断的填坑，不断的填坑，把坑都处理完后。 还是多输出，可以多些一些内容，这点其实很关键。 输出就是分享，能够和很多人，产生共鸣的同时，也能够提高自己。</p><h3 id="时间留给自己和家人"><a href="#时间留给自己和家人" class="headerlink" title="时间留给自己和家人"></a>时间留给自己和家人</h3><p>这一年，最应该说对不起的就是家里人， 一个人在国内，其实现在的状态和之前，还是发生了很大的变化的。 如何抽出更多的时间，需要养成一个习惯。</p><h3 id="回到原点重新开始"><a href="#回到原点重新开始" class="headerlink" title="回到原点重新开始"></a>回到原点重新开始</h3><p>如果还有一次机会摆在你面前，你会如何抉择呢。也许还是和现在一样吧。不过避免填坑了，填了这么多的坑，应该变的更果断，更现实，这样才行。</p><h3 id="人生追求是什么"><a href="#人生追求是什么" class="headerlink" title="人生追求是什么"></a>人生追求是什么</h3><p>家人健健康康，平平安安，我也能够陪伴在他们左右，现在这样过程，应该只是短暂的。 5年一闪而过，人生亦无几个5年。 其实走出来，简简单单就是福。 否极泰来，终其一生的追求，到最后，其实发现，简单就是美好。</p><p>END</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Nov 02 2020 15:59:06 GMT+0900 (Japan Standard Time) --&gt;&lt;p&gt;​&lt;/p&gt;&lt;h3 id=&quot;一周年快乐&quot;&gt;&lt;a href=&quot;#一周年快乐&quot; class=&quot;headerlink&quot; title=&quot;一周年快乐&quot;&gt;&lt;/a&gt;一周年快乐&lt;/h3&gt;&lt;p&gt;2019年8月，距离去年回国创业已经整整一年了，一年里，时局变迁，做一个流水账的记录。 创业犹如踩坑，经历过，才知道，原来这么小的坑，有这么大，足以吞噬，在让你浴火重生。&lt;/p&gt;&lt;p&gt;帮助过的人，应该感恩，坑过的人，依旧应该感恩。&lt;/p&gt;&lt;p&gt;​ &lt;img src=&quot;/images/yizhounian.png?style=centerme&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="other" scheme="http://yangxinqi.com/categories/other/"/>
    
    
      <category term="other" scheme="http://yangxinqi.com/tags/other/"/>
    
  </entry>
  
  <entry>
    <title>清明时节的回忆</title>
    <link href="http://yangxinqi.com/2019/04/05/%E6%B8%85%E6%98%8E%E6%97%B6%E8%8A%82%E7%9A%84%E5%9B%9E%E5%BF%86/"/>
    <id>http://yangxinqi.com/2019/04/05/清明时节的回忆/</id>
    <published>2019-04-05T13:17:54.000Z</published>
    <updated>2019-04-06T07:03:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Nov 02 2020 15:59:06 GMT+0900 (Japan Standard Time) --><h3 id="清明时节的回忆"><a href="#清明时节的回忆" class="headerlink" title="清明时节的回忆"></a>清明时节的回忆</h3><p>思念的日子，祭！</p><p>今天许久没聊的好哥们，好兄弟，晒娃了， 刚刚到北京的时候，备受他的照顾，聊及人生选择，一向如此。</p><p>聊到感触最深的，当遇到抉择的时候，总是选择出问题，导致没搭上好的车。BAT之间选择，总是看的比较近，没有着眼于潜在，对于未来发展的预估和判断都是有问题的。</p><h3 id="行业选择及跟对人"><a href="#行业选择及跟对人" class="headerlink" title="行业选择及跟对人"></a>行业选择及跟对人</h3><p>行业的选择，程序员是没错的，在外人看来，高收入，在的公司也挺好。 但是在跟对人这个基础上，看的还是很不寻常的，提早跟对人，比坚持下来，然后就发达的，作为公司股东的大有人在。 小米早进去的人，现在还在位置上的，做的好的，大有人在，就是这个道理。</p><h3 id="创业一种自虐的选择"><a href="#创业一种自虐的选择" class="headerlink" title="创业一种自虐的选择"></a>创业一种自虐的选择</h3><p>当机会错过， 没有跟对人，也没有赶上大环境，出来博一把的心态，这就是创业。</p><p>今年的创业环境要求很不一样，不比前2-3年的创投蜂拥而上，不比之前的宽松环境，现在还是需要靠谱的数据来支撑。</p><h3 id="清明当觉醒"><a href="#清明当觉醒" class="headerlink" title="清明当觉醒"></a>清明当觉醒</h3><p>创业公司，也同样存在生死生命线，年后很多公司和组织退出这个行业，区块链行业也从热门行业到现在的云淡风轻，而且还备受歧视。 当公司只有半年可以活的时候，是否拼尽全力继续活下来，还是说放弃抵抗，岁月静好的等着？</p><p><img src="/images/qingming.png?style=centerme" alt="img"></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Nov 02 2020 15:59:06 GMT+0900 (Japan Standard Time) --&gt;&lt;h3 id=&quot;清明时节的回忆&quot;&gt;&lt;a href=&quot;#清明时节的回忆&quot; class=&quot;headerlink&quot; title=&quot;清明时
      
    
    </summary>
    
    
      <category term="other" scheme="http://yangxinqi.com/tags/other/"/>
    
  </entry>
  
  <entry>
    <title>2018年年终总结主题活下去</title>
    <link href="http://yangxinqi.com/2018/12/28/2018%E5%B9%B4%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93%E4%B8%BB%E9%A2%98%E6%B4%BB%E4%B8%8B%E5%8E%BB/"/>
    <id>http://yangxinqi.com/2018/12/28/2018年年终总结主题活下去/</id>
    <published>2018-12-28T07:19:19.000Z</published>
    <updated>2018-12-28T07:28:35.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Nov 02 2020 15:59:06 GMT+0900 (Japan Standard Time) --><p><img src="/images/year-2018-end.jpg?style=centerme" alt="img"></p><h3 id="2018年-年终总结-主题-活下去"><a href="#2018年-年终总结-主题-活下去" class="headerlink" title="2018年 年终总结 主题  活下去"></a>2018年 年终总结 主题 活下去</h3><p>2018年的最后一个工作日，回顾下整年的发展，一切过往历历在目，在梳理下。</p><h3 id="展望2019"><a href="#展望2019" class="headerlink" title="展望2019"></a>展望2019</h3><p>2019年，小目标 500万 人民币营收</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>一切都是拼出来的，爱拼才会赢。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Nov 02 2020 15:59:06 GMT+0900 (Japan Standard Time) --&gt;&lt;p&gt;&lt;img src=&quot;/images/year-2018-end.jpg?style=centerme&quot; alt=&quot;img&quot;&gt;
      
    
    </summary>
    
    
      <category term="other" scheme="http://yangxinqi.com/tags/other/"/>
    
  </entry>
  
  <entry>
    <title>入行区块链金融</title>
    <link href="http://yangxinqi.com/2018/12/03/%E5%85%A5%E8%A1%8C%E5%8C%BA%E5%9D%97%E9%93%BE%E9%87%91%E8%9E%8D/"/>
    <id>http://yangxinqi.com/2018/12/03/入行区块链金融/</id>
    <published>2018-12-02T15:20:32.000Z</published>
    <updated>2018-12-02T15:35:10.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Nov 02 2020 15:59:06 GMT+0900 (Japan Standard Time) --><p>距离上一篇博文，已经过去整整10个月之多了。从踌躇的观望，到ALL IN区块链，到现在Lead公司杀入区块链金融行业，转眼又是12个月，一年即将过去，内心的不安和焦虑感与日俱增。 更是看到龙哥团队，所有的成员都在著书写博，我们不能落后。</p><p><img src="/images/blockchainfinance.png?style=centerme" alt="come back!"></p><h4 id="区块链的未来是什么样的？"><a href="#区块链的未来是什么样的？" class="headerlink" title="区块链的未来是什么样的？"></a>区块链的未来是什么样的？</h4><p>未来是什么样的，现在还是看不到，从ICO,STO的概念的突起，到近期的股票金融类专业人士，携大额资金杀入这一领域，传统的区块链老人，与之形成较大的对比，虽然现在这一领域，市场在逐渐萎靡，市值整体在减小，除了传统的BTC（以及衍生出来的BCHABC，BCHSV）以及有实际应用产品的Ripple，中国人市场主推的ETH，EOS，在最近的几个月，市值缩水更严重。 走出中国放眼世界，看区块链在各个国家的发展情况，整体来看，BTC的需求还是依然存在，但是BTC对整个区块链技术的发展，还是有推动作用的。</p><p>整体来看看好区块链金融的发展。</p><h4 id="个人资产管理及企业机构"><a href="#个人资产管理及企业机构" class="headerlink" title="个人资产管理及企业机构"></a>个人资产管理及企业机构</h4><p>个人资产管理，还是没有一个很好的工具来实际的做到这一点，从最早的个人资金记账，到现在支付宝及各种P2P理财公司，用户很难实际掌握自己的资产，以及实现资产的保值。</p><p>企业机构在传统的领域转型过来，针对全球的市场的数量增加，也没有很成熟的一套机制来保障资产的安全，以及能够套用现在其他市场中的工具来解决管理的问题。</p><p>这块是一个很好的点。</p><h4 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h4><p>先说这2点，最近需要更勤奋了。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Nov 02 2020 15:59:06 GMT+0900 (Japan Standard Time) --&gt;&lt;p&gt;距离上一篇博文，已经过去整整10个月之多了。从踌躇的观望，到ALL IN区块链，到现在Lead公司杀入区块链金融行业，转眼又
      
    
    </summary>
    
    
      <category term="blockchain" scheme="http://yangxinqi.com/tags/blockchain/"/>
    
  </entry>
  
  <entry>
    <title>区块链数据分析之保存币安历史数据</title>
    <link href="http://yangxinqi.com/2018/02/06/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8B%E4%BF%9D%E5%AD%98%E5%B8%81%E5%AE%89%E5%8E%86%E5%8F%B2%E6%95%B0%E6%8D%AE/"/>
    <id>http://yangxinqi.com/2018/02/06/区块链数据分析之保存币安历史数据/</id>
    <published>2018-02-06T01:29:25.000Z</published>
    <updated>2018-02-06T06:10:48.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Nov 02 2020 15:59:06 GMT+0900 (Japan Standard Time) --><p>最近币圈大跌，作为一棵吊在高处的韭菜，还是觉得好好的做开发比跟风靠谱多了，遂静下心来，好好的写点文章，做点数据分析，抓取进阶下。</p><p>接触区块链其实在三年前，一个朋友就提醒我们多关注区块链，那个时候的我们还是少不更事的认为那个虚的东西又撒好玩的，到现在回首看，眼界比技能和运气要重要得多。做人没有好的眼光，上不去的，还是捡起来好好的分析下区块链技术，后续会多些一些。</p><p>言归正传，最近在分析各个交易所的数据，对接了几个交易所（bitflyer， coincheck， binance，btcbox）后续在对接一些其他的。首先作为技术出身，还是好好的做数据分析吧，先爬一些数据下来，就到处找相关的接口文档，然后通过python来把数据抓下来。这块就需要大家提供的访问api，有很多人写了交易所第三方的访问api，发布在github上，我们就使用这些api来访问以获取数据。</p><p>看了好几篇文章，第一篇先给澳大利亚的一个大叔级高手打广告，翻译下他的文章，这个哥们写了好几个交易所的获取客户端。</p><p>原文链接： <a href="https://sammchardy.github.io/binance/2018/01/08/historical-data-download-binance.html" target="_blank" rel="noopener">https://sammchardy.github.io/binance/2018/01/08/historical-data-download-binance.html</a></p><a id="more"></a><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>任何交易策略的基础都是有一个好的回测方案，如果你没有数据，就没法回测，数据还是很重要的。</p><p>在这篇文章中，我将详细描述通过Binance API在指定时间范围内下载和保存币安的历史K线数据。</p><p>这个例子不需要有币安的账户，直接访问公开的API即可。</p><h3 id="首先需要处理时间格式"><a href="#首先需要处理时间格式" class="headerlink" title="首先需要处理时间格式"></a>首先需要处理时间格式</h3><p>因为币安服务器只接受毫秒级别的时间戳的时间段，所以需要将工作日时间转换为毫秒时间戳。</p><p>本次使用强大的python来进行处理，安装dateparser包。命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install dateparser</span><br></pre></td></tr></table></figure><p>我们可以得写个函数将日期字符串直接转换成毫秒格式。例子如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(date_to_milliseconds(<span class="string">"January 01, 2018"</span>))</span><br><span class="line">print(date_to_milliseconds(<span class="string">"11 hours ago UTC"</span>))</span><br><span class="line">print(date_to_milliseconds(<span class="string">"now UTC"</span>))</span><br></pre></td></tr></table></figure><h3 id="获取币安的K线数据"><a href="#获取币安的K线数据" class="headerlink" title="获取币安的K线数据"></a>获取币安的K线数据</h3><p>现在我们希望通过 get_klines API来获取实际的交易量数据。</p><p>先看下接口参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">symbol - e.g ETHBTC  币种数据</span><br><span class="line">interval - one of (1m, 3m, 5m, 15m, 30m, 1h, 2h, 4h, 6h, 8h, 12h, 1d, 3d, 1w, 1M) 时间范围</span><br><span class="line">limit - max 500  限制条数</span><br><span class="line">startTime - milliseconds  开始时间 单位毫秒</span><br><span class="line">endTime - milliseconds    结束时间 单位毫秒</span><br></pre></td></tr></table></figure><p>因为一次最多取500条，如果时间范围比较大，我们得循环获取。</p><p>返回结果格式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    <span class="number">1499040000000</span>,      <span class="comment"># Open time </span></span><br><span class="line">    <span class="string">"0.01634790"</span>,       <span class="comment"># Open</span></span><br><span class="line">    <span class="string">"0.80000000"</span>,       <span class="comment"># High</span></span><br><span class="line">    <span class="string">"0.01575800"</span>,       <span class="comment"># Low</span></span><br><span class="line">    <span class="string">"0.01577100"</span>,       <span class="comment"># Close</span></span><br><span class="line">    <span class="string">"148976.11427815"</span>,  <span class="comment"># Volume</span></span><br><span class="line">    <span class="number">1499644799999</span>,      <span class="comment"># Close time</span></span><br><span class="line">    <span class="string">"2434.19055334"</span>,    <span class="comment"># Quote asset volume</span></span><br><span class="line">    <span class="number">308</span>,                <span class="comment"># Number of trades</span></span><br><span class="line">    <span class="string">"1756.87402397"</span>,    <span class="comment"># Taker buy base asset volume</span></span><br><span class="line">    <span class="string">"28.46694368"</span>,      <span class="comment"># Taker buy quote asset volume</span></span><br><span class="line">    <span class="string">"17928899.62484339"</span> <span class="comment"># Ignore</span></span><br><span class="line">  ]</span><br></pre></td></tr></table></figure><p>我们把返回的结果都存储起来，有多少存多少。</p><h3 id="币安时间间隔intervals"><a href="#币安时间间隔intervals" class="headerlink" title="币安时间间隔intervals"></a>币安时间间隔intervals</h3><p>参数中的intervals是一个字符串，一次请求只能是在某个范围内，一次限制是500，所以需要获取较长时间段数据的话，需要对时间间隔进行毫秒转换。将API中设定的时间，转换成毫秒， 例子如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> binance.client <span class="keyword">import</span> Client</span><br><span class="line"></span><br><span class="line">print(interval_to_milliseconds(Client.KLINE_INTERVAL_1MINUTE))</span><br><span class="line">print(interval_to_milliseconds(Client.KLINE_INTERVAL_30MINUTE))</span><br><span class="line">print(interval_to_milliseconds(KLINE_INTERVAL_1WEEK))</span><br></pre></td></tr></table></figure><h3 id="获取K线数据"><a href="#获取K线数据" class="headerlink" title="获取K线数据"></a>获取K线数据</h3><p>准备好了之后，我们开始写方法来获取历史数据。 我们通过时间范围和intervals间隔参数很容易的获取。例子如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> binance.client <span class="keyword">import</span> Client</span><br><span class="line"></span><br><span class="line"><span class="comment"># fetch 1 minute klines for the last day up until now</span></span><br><span class="line">klines = get_historical_klines(<span class="string">"BNBBTC"</span>, Client.KLINE_INTERVAL_1MINUTE, <span class="string">"1 day ago UTC"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># fetch 30 minute klines for the last month of 2017</span></span><br><span class="line">klines = get_historical_klines(<span class="string">"ETHBTC"</span>, Client.KLINE_INTERVAL_30MINUTE, <span class="string">"1 Dec, 2017"</span>, <span class="string">"1 Jan, 2018"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># fetch weekly klines since it listed</span></span><br><span class="line">klines = get_historical_klines(<span class="string">"NEOBTC"</span>, KLINE_INTERVAL_1WEEK, <span class="string">"1 Jan, 2017"</span>)</span><br></pre></td></tr></table></figure><p>完整的代码可以从<a href="https://github.com/sammchardy/python-binance" target="_blank" rel="noopener">python-binance</a>项目的例子中获取，链接： <a href="https://github.com/sammchardy/python-binance/tree/master/examples" target="_blank" rel="noopener">examples folder</a></p><h3 id="保存到文件"><a href="#保存到文件" class="headerlink" title="保存到文件"></a>保存到文件</h3><p>获取到的数据后存到文件以方便后面使用。代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> binance.client <span class="keyword">import</span> Client</span><br><span class="line"></span><br><span class="line">symbol = <span class="string">"ETHBTC"</span></span><br><span class="line">start = <span class="string">"1 Dec, 2017"</span></span><br><span class="line">end = <span class="string">"1 Jan, 2018"</span></span><br><span class="line">interval = Client.KLINE_INTERVAL_30MINUTE</span><br><span class="line"></span><br><span class="line">klines = get_historical_klines(symbol, interval, start, end)</span><br><span class="line"></span><br><span class="line"><span class="comment"># open a file with filename including symbol, interval and start and end converted to milliseconds</span></span><br><span class="line"><span class="keyword">with</span> open(</span><br><span class="line">    <span class="string">"Binance_&#123;&#125;_&#123;&#125;_&#123;&#125;-&#123;&#125;.json"</span>.format(</span><br><span class="line">        symbol, </span><br><span class="line">        interval, </span><br><span class="line">        date_to_milliseconds(start),</span><br><span class="line">        date_to_milliseconds(end)</span><br><span class="line">    ),</span><br><span class="line">    <span class="string">'w'</span> <span class="comment"># set file write mode</span></span><br><span class="line">) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(json.dumps(klines))</span><br></pre></td></tr></table></figure><h3 id="打赏功能"><a href="#打赏功能" class="headerlink" title="打赏功能"></a>打赏功能</h3><p>这些好的方法，已经添加到<a href="https://github.com/sammchardy/python-binance" target="_blank" rel="noopener">python-binance</a>方便大家使用。</p><p><code>date_to_milliseconds</code> 和 <code>interval_to_milliseconds</code>已经添加到binance.helpers中。<code>get_historical_klines</code>已经添加到finance.client中，直接调用即可。代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> binance.client <span class="keyword">import</span> Client</span><br><span class="line"></span><br><span class="line">client = Client(<span class="string">""</span>, <span class="string">""</span>)</span><br><span class="line"></span><br><span class="line">klines = client.get_historical_klines(<span class="string">"ETHBTC"</span>, Client.KLINE_INTERVAL_30MINUTE, <span class="string">"1 Dec, 2017"</span>, <span class="string">"1 Jan, 2018"</span>)</span><br></pre></td></tr></table></figure><h3 id="接下来"><a href="#接下来" class="headerlink" title="接下来"></a>接下来</h3><p>使用这些获取的数据，我们可以在后续的回测中使用。</p><p>使用Kucoin交易所的用户同样使用<a href="https://github.com/sammchardy/python-kucoin" target="_blank" rel="noopener">python-kucoin</a> 也有这些功能。</p><p>后续还会写一些使用 <a href="https://pandas.pydata.org/" target="_blank" rel="noopener">pandas</a> 和 <a href="https://github.com/mrjbq7/ta-lib" target="_blank" rel="noopener">TA-Lib</a> 来进行简单的回测的文章。</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p><a href="https://twitter.com/sammchardy" target="_blank" rel="noopener">sammchardy</a> 是一个很帅的澳洲哥们，大家可以在twitter上关注他， 作为开源的api客户端，写的也非常的便捷，对于这样有分享的精神的哥们，大家是不是给点打赏呢，他也给了Donate地址了。大家可以查看原文。</p><p>我在最后也贴下全文例子的链接：</p><p><a href="https://github.com/sammchardy/python-binance/blob/master/examples/save_historical_data.py" target="_blank" rel="noopener">save_historical_data.py</a> 大家可以下下来实际的跑一下试试。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> dateparser</span><br><span class="line"><span class="keyword">import</span> pytz</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> binance.client <span class="keyword">import</span> Client</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">date_to_milliseconds</span><span class="params">(date_str)</span>:</span></span><br><span class="line">    <span class="string">"""Convert UTC date to milliseconds</span></span><br><span class="line"><span class="string">    If using offset strings add "UTC" to date string e.g. "now UTC", "11 hours ago UTC"</span></span><br><span class="line"><span class="string">    See dateparse docs for formats http://dateparser.readthedocs.io/en/latest/</span></span><br><span class="line"><span class="string">    :param date_str: date in readable format, i.e. "January 01, 2018", "11 hours ago UTC", "now UTC"</span></span><br><span class="line"><span class="string">    :type date_str: str</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># get epoch value in UTC</span></span><br><span class="line">    epoch = datetime.utcfromtimestamp(<span class="number">0</span>).replace(tzinfo=pytz.utc)</span><br><span class="line">    <span class="comment"># parse our date string</span></span><br><span class="line">    d = dateparser.parse(date_str)</span><br><span class="line">    <span class="comment"># if the date is not timezone aware apply UTC timezone</span></span><br><span class="line">    <span class="keyword">if</span> d.tzinfo <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> d.tzinfo.utcoffset(d) <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        d = d.replace(tzinfo=pytz.utc)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># return the difference in time</span></span><br><span class="line">    <span class="keyword">return</span> int((d - epoch).total_seconds() * <span class="number">1000.0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">interval_to_milliseconds</span><span class="params">(interval)</span>:</span></span><br><span class="line">    <span class="string">"""Convert a Binance interval string to milliseconds</span></span><br><span class="line"><span class="string">    :param interval: Binance interval string 1m, 3m, 5m, 15m, 30m, 1h, 2h, 4h, 6h, 8h, 12h, 1d, 3d, 1w</span></span><br><span class="line"><span class="string">    :type interval: str</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">         None if unit not one of m, h, d or w</span></span><br><span class="line"><span class="string">         None if string not in correct format</span></span><br><span class="line"><span class="string">         int value of interval in milliseconds</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    ms = <span class="keyword">None</span></span><br><span class="line">    seconds_per_unit = &#123;</span><br><span class="line">        <span class="string">"m"</span>: <span class="number">60</span>,</span><br><span class="line">        <span class="string">"h"</span>: <span class="number">60</span> * <span class="number">60</span>,</span><br><span class="line">        <span class="string">"d"</span>: <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span>,</span><br><span class="line">        <span class="string">"w"</span>: <span class="number">7</span> * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    unit = interval[<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">if</span> unit <span class="keyword">in</span> seconds_per_unit:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            ms = int(interval[:<span class="number">-1</span>]) * seconds_per_unit[unit] * <span class="number">1000</span></span><br><span class="line">        <span class="keyword">except</span> ValueError:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">return</span> ms</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_historical_klines</span><span class="params">(symbol, interval, start_str, end_str=None)</span>:</span></span><br><span class="line">    <span class="string">"""Get Historical Klines from Binance</span></span><br><span class="line"><span class="string">    See dateparse docs for valid start and end string formats http://dateparser.readthedocs.io/en/latest/</span></span><br><span class="line"><span class="string">    If using offset strings for dates add "UTC" to date string e.g. "now UTC", "11 hours ago UTC"</span></span><br><span class="line"><span class="string">    :param symbol: Name of symbol pair e.g BNBBTC</span></span><br><span class="line"><span class="string">    :type symbol: str</span></span><br><span class="line"><span class="string">    :param interval: Biannce Kline interval</span></span><br><span class="line"><span class="string">    :type interval: str</span></span><br><span class="line"><span class="string">    :param start_str: Start date string in UTC format</span></span><br><span class="line"><span class="string">    :type start_str: str</span></span><br><span class="line"><span class="string">    :param end_str: optional - end date string in UTC format</span></span><br><span class="line"><span class="string">    :type end_str: str</span></span><br><span class="line"><span class="string">    :return: list of OHLCV values</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># create the Binance client, no need for api key</span></span><br><span class="line">    client = Client(<span class="string">""</span>, <span class="string">""</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># init our list</span></span><br><span class="line">    output_data = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># setup the max limit</span></span><br><span class="line">    limit = <span class="number">500</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># convert interval to useful value in seconds</span></span><br><span class="line">    timeframe = interval_to_milliseconds(interval)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># convert our date strings to milliseconds</span></span><br><span class="line">    start_ts = date_to_milliseconds(start_str)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># if an end time was passed convert it</span></span><br><span class="line">    end_ts = <span class="keyword">None</span></span><br><span class="line">    <span class="keyword">if</span> end_str:</span><br><span class="line">        end_ts = date_to_milliseconds(end_str)</span><br><span class="line"></span><br><span class="line">    idx = <span class="number">0</span></span><br><span class="line">    <span class="comment"># it can be difficult to know when a symbol was listed on Binance so allow start time to be before list date</span></span><br><span class="line">    symbol_existed = <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="comment"># fetch the klines from start_ts up to max 500 entries or the end_ts if set</span></span><br><span class="line">        temp_data = client.get_klines(</span><br><span class="line">            symbol=symbol,</span><br><span class="line">            interval=interval,</span><br><span class="line">            limit=limit,</span><br><span class="line">            startTime=start_ts,</span><br><span class="line">            endTime=end_ts</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="comment"># handle the case where our start date is before the symbol pair listed on Binance</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> symbol_existed <span class="keyword">and</span> len(temp_data):</span><br><span class="line">            symbol_existed = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> symbol_existed:</span><br><span class="line">            <span class="comment"># append this loops data to our output data</span></span><br><span class="line">            output_data += temp_data</span><br><span class="line"></span><br><span class="line">            <span class="comment"># update our start timestamp using the last value in the array and add the interval timeframe</span></span><br><span class="line">            start_ts = temp_data[len(temp_data) - <span class="number">1</span>][<span class="number">0</span>] + timeframe</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># it wasn't listed yet, increment our start date</span></span><br><span class="line">            start_ts += timeframe</span><br><span class="line"></span><br><span class="line">        idx += <span class="number">1</span></span><br><span class="line">        <span class="comment"># check if we received less than the required limit and exit the loop</span></span><br><span class="line">        <span class="keyword">if</span> len(temp_data) &lt; limit:</span><br><span class="line">            <span class="comment"># exit the while loop</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># sleep after every 3rd call to be kind to the API</span></span><br><span class="line">        <span class="keyword">if</span> idx % <span class="number">3</span> == <span class="number">0</span>:</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> output_data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">symbol = <span class="string">"ETHBTC"</span></span><br><span class="line">start = <span class="string">"1 Dec, 2017"</span></span><br><span class="line">end = <span class="string">"1 Jan, 2018"</span></span><br><span class="line">interval = Client.KLINE_INTERVAL_30MINUTE</span><br><span class="line"></span><br><span class="line">klines = get_historical_klines(symbol, interval, start, end)</span><br><span class="line"></span><br><span class="line"><span class="comment"># open a file with filename including symbol, interval and start and end converted to milliseconds</span></span><br><span class="line"><span class="keyword">with</span> open(</span><br><span class="line">    <span class="string">"Binance_&#123;&#125;_&#123;&#125;_&#123;&#125;-&#123;&#125;.json"</span>.format(</span><br><span class="line">        symbol,</span><br><span class="line">        interval,</span><br><span class="line">        date_to_milliseconds(start),</span><br><span class="line">        date_to_milliseconds(end)</span><br><span class="line">    ),</span><br><span class="line">    <span class="string">'w'</span>  <span class="comment"># set file write mode</span></span><br><span class="line">) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(json.dumps(klines))</span><br></pre></td></tr></table></figure><p>执行例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 save_historical_data.py</span><br></pre></td></tr></table></figure><p>生成文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Binance_ETHBTC_30m_1512086400000-1514764800000.json</span><br></pre></td></tr></table></figure><p>返回结果例子：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [</span><br><span class="line">    <span class="number">1512086400000</span>,</span><br><span class="line">    <span class="string">"0.04368400"</span>,</span><br><span class="line">    <span class="string">"0.04375100"</span>,</span><br><span class="line">    <span class="string">"0.04334200"</span>,</span><br><span class="line">    <span class="string">"0.04366500"</span>,</span><br><span class="line">    <span class="string">"2081.85600000"</span>,</span><br><span class="line">    <span class="number">1512088199999</span>,</span><br><span class="line">    <span class="string">"90.79655078"</span>,</span><br><span class="line">    <span class="number">3904</span>,</span><br><span class="line">    <span class="string">"976.19100000"</span>,</span><br><span class="line">    <span class="string">"42.59074736"</span>,</span><br><span class="line">    <span class="string">"271480.34213668"</span></span><br><span class="line">  ],</span><br><span class="line">  [</span><br><span class="line">    <span class="number">1512088200000</span>,</span><br><span class="line">    <span class="string">"0.04360200"</span>,</span><br><span class="line">    <span class="string">"0.04369900"</span>,</span><br><span class="line">    <span class="string">"0.04325100"</span>,</span><br><span class="line">    <span class="string">"0.04350100"</span>,</span><br><span class="line">    <span class="string">"2420.48100000"</span>,</span><br><span class="line">    <span class="number">1512089999999</span>,</span><br><span class="line">    <span class="string">"105.27683806"</span>,</span><br><span class="line">    <span class="number">2775</span>,</span><br><span class="line">    <span class="string">"1133.24800000"</span>,</span><br><span class="line">    <span class="string">"49.31486895"</span>,</span><br><span class="line">    <span class="string">"271300.32546398"</span></span><br><span class="line">  ],</span><br><span class="line">  [</span><br><span class="line">    <span class="number">1512090000000</span>,</span><br><span class="line">    <span class="string">"0.04350100"</span>,</span><br><span class="line">    <span class="string">"0.04379400"</span>,</span><br><span class="line">    <span class="string">"0.04304900"</span>,</span><br><span class="line">    <span class="string">"0.04370500"</span>,</span><br><span class="line">    <span class="string">"2192.51500000"</span>,</span><br><span class="line">    <span class="number">1512091799999</span>,</span><br><span class="line">    <span class="string">"95.48824264"</span>,</span><br><span class="line">    <span class="number">2359</span>,</span><br><span class="line">    <span class="string">"1029.30200000"</span>,</span><br><span class="line">    <span class="string">"44.86783356"</span>,</span><br><span class="line">    <span class="string">"271143.81327337"</span></span><br><span class="line">  ],</span><br><span class="line">  [</span><br><span class="line">    <span class="number">1512091800000</span>,</span><br><span class="line">    <span class="string">"0.04374900"</span>,</span><br><span class="line">    <span class="string">"0.04392000"</span>,</span><br><span class="line">    <span class="string">"0.04361300"</span>,</span><br><span class="line">    <span class="string">"0.04378100"</span>,</span><br><span class="line">    <span class="string">"1482.24800000"</span>,</span><br><span class="line">    <span class="number">1512093599999</span>,</span><br><span class="line">    <span class="string">"64.86877196"</span>,</span><br><span class="line">    <span class="number">2112</span>,</span><br><span class="line">    <span class="string">"704.81600000"</span>,</span><br><span class="line">    <span class="string">"30.85380066"</span>,</span><br><span class="line">    <span class="string">"271394.84389969"</span></span><br><span class="line">  ],</span><br><span class="line">  [</span><br><span class="line">    <span class="number">1512093600000</span>,</span><br><span class="line">    <span class="string">"0.04375800"</span>,</span><br><span class="line">    <span class="string">"0.04424900"</span>,</span><br><span class="line">    <span class="string">"0.04364800"</span>,</span><br><span class="line">    <span class="string">"0.04403800"</span>,</span><br><span class="line">    <span class="string">"2073.49800000"</span>,</span><br><span class="line">    <span class="number">1512095399999</span>,</span><br><span class="line">    <span class="string">"90.95341447"</span>,</span><br><span class="line">    <span class="number">2763</span>,</span><br><span class="line">    <span class="string">"996.44700000"</span>,</span><br><span class="line">    <span class="string">"43.72006243"</span>,</span><br><span class="line">    <span class="string">"271126.63134592"</span></span><br><span class="line">  ],</span><br><span class="line">  [</span><br><span class="line">    <span class="number">1512095400000</span>,</span><br><span class="line">    <span class="string">"0.04400500"</span>,</span><br><span class="line">    <span class="string">"0.04421400"</span>,</span><br><span class="line">    <span class="string">"0.04380000"</span>,</span><br><span class="line">    <span class="string">"0.04389900"</span>,</span><br><span class="line">    <span class="string">"1675.47800000"</span>,</span><br><span class="line">    <span class="number">1512097199999</span>,</span><br><span class="line">    <span class="string">"73.62046216"</span>,</span><br><span class="line">    <span class="number">1817</span>,</span><br><span class="line">    <span class="string">"808.25500000"</span>,</span><br><span class="line">    <span class="string">"35.52008528"</span>,</span><br><span class="line">    <span class="string">"271368.11447690"</span></span><br><span class="line">  ],</span><br><span class="line">  [</span><br><span class="line">    <span class="number">1512097200000</span>,</span><br><span class="line">    <span class="string">"0.04390400"</span>,</span><br><span class="line">    <span class="string">"0.04413600"</span>,</span><br><span class="line">    <span class="string">"0.04364200"</span>,</span><br><span class="line">    <span class="string">"0.04400500"</span>,</span><br><span class="line">    <span class="string">"2138.10400000"</span>,</span><br><span class="line">    <span class="number">1512098999999</span>,</span><br><span class="line">    <span class="string">"93.95901243"</span>,</span><br><span class="line">    <span class="number">2260</span>,</span><br><span class="line">    <span class="string">"1157.93700000"</span>,</span><br><span class="line">    <span class="string">"50.88996640"</span>,</span><br><span class="line">    <span class="string">"271143.40315253"</span></span><br><span class="line">  ]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>大家可以试试，在后续回测中可以用到。</p><p>如果大家遇到报错，请升级下cryptography的包，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install -U cryptography</span><br></pre></td></tr></table></figure><p>后续我也会多些一些原创的区块链技术方面的文章。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Nov 02 2020 15:59:06 GMT+0900 (Japan Standard Time) --&gt;&lt;p&gt;最近币圈大跌，作为一棵吊在高处的韭菜，还是觉得好好的做开发比跟风靠谱多了，遂静下心来，好好的写点文章，做点数据分析，抓取进阶下。&lt;/p&gt;&lt;p&gt;接触区块链其实在三年前，一个朋友就提醒我们多关注区块链，那个时候的我们还是少不更事的认为那个虚的东西又撒好玩的，到现在回首看，眼界比技能和运气要重要得多。做人没有好的眼光，上不去的，还是捡起来好好的分析下区块链技术，后续会多些一些。&lt;/p&gt;&lt;p&gt;言归正传，最近在分析各个交易所的数据，对接了几个交易所（bitflyer， coincheck， binance，btcbox）后续在对接一些其他的。首先作为技术出身，还是好好的做数据分析吧，先爬一些数据下来，就到处找相关的接口文档，然后通过python来把数据抓下来。这块就需要大家提供的访问api，有很多人写了交易所第三方的访问api，发布在github上，我们就使用这些api来访问以获取数据。&lt;/p&gt;&lt;p&gt;看了好几篇文章，第一篇先给澳大利亚的一个大叔级高手打广告，翻译下他的文章，这个哥们写了好几个交易所的获取客户端。&lt;/p&gt;&lt;p&gt;原文链接： &lt;a href=&quot;https://sammchardy.github.io/binance/2018/01/08/historical-data-download-binance.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://sammchardy.github.io/binance/2018/01/08/historical-data-download-binance.html&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="blockchain" scheme="http://yangxinqi.com/categories/blockchain/"/>
    
    
      <category term="block chain, binance, historical data" scheme="http://yangxinqi.com/tags/block-chain-binance-historical-data/"/>
    
  </entry>
  
  <entry>
    <title>将blog迁移到hexo了</title>
    <link href="http://yangxinqi.com/2018/02/06/%E5%B0%86blog%E8%BF%81%E7%A7%BB%E5%88%B0hexo%E4%BA%86/"/>
    <id>http://yangxinqi.com/2018/02/06/将blog迁移到hexo了/</id>
    <published>2018-02-06T01:14:00.000Z</published>
    <updated>2018-02-06T09:53:38.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Nov 02 2020 15:59:06 GMT+0900 (Japan Standard Time) --><p><img src="/images/hexo.png?style=centerme" alt="img"></p><h2 id="总是别人的好"><a href="#总是别人的好" class="headerlink" title="总是别人的好"></a>总是别人的好</h2><p>看东西总是别人的好，之前用的octopress搭建在github page上的notes，折腾了2回了，之前因为换了机器了之后，ruby的环境丢了，重新整了下。 换了下octopress的theme，然后一年才写了2-3篇，战斗力严重下降。</p><p>最近一直在看不少技术者的blog，看他们写的都不错，都是使用hexo，所以查了下，hexo是重写过的，比起之前用ruby下的rake写的octopress，感觉看上去更好看一些，而且果然提供了很多的theme，感觉做的都很全也很漂亮。遂决定换到hexo了，用下来，感觉很方便，插件和风格也都很全。</p><p>插件这块，看到大家加了打赏功能了，我也默默的给加上了，不知道后续会不会有人给我打赏呢，入乡随俗啊，感觉国内这块的风气这点还是比较好的。 写文章的人很多，而且知识付费的意识也起来了。</p><a id="more"></a><h2 id="说到免费的https"><a href="#说到免费的https" class="headerlink" title="说到免费的https"></a>说到免费的https</h2><p>看到大家的个人域名都是使用https的，之前的github pages是不支持https绑定的，结果一查，发现cloudflare支持https的跳转，这块突然想到，其实他们就是拿到解析到自己的服务器，作为一个反向代理，在把后端的页面直接给返回就行，是能够实现https的，而且还是免费的，好吧，这里赞下cloudflare。美国的一些互联网公司的产品设计果然还是很赞的。</p><h2 id="复活yangxinqi-com"><a href="#复活yangxinqi-com" class="headerlink" title="复活yangxinqi.com"></a>复活yangxinqi.com</h2><p>去年忙活了一整年了，发现时间特别少，没有咋个动笔，2018也过去2个月了，今年目标每个月1-2篇文章吧。</p><p>这点还是可以实现的，停下来总结总结，总比每天忙个不停要好的多。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Nov 02 2020 15:59:06 GMT+0900 (Japan Standard Time) --&gt;&lt;p&gt;&lt;img src=&quot;/images/hexo.png?style=centerme&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;&lt;h2 id=&quot;总是别人的好&quot;&gt;&lt;a href=&quot;#总是别人的好&quot; class=&quot;headerlink&quot; title=&quot;总是别人的好&quot;&gt;&lt;/a&gt;总是别人的好&lt;/h2&gt;&lt;p&gt;看东西总是别人的好，之前用的octopress搭建在github page上的notes，折腾了2回了，之前因为换了机器了之后，ruby的环境丢了，重新整了下。 换了下octopress的theme，然后一年才写了2-3篇，战斗力严重下降。&lt;/p&gt;&lt;p&gt;最近一直在看不少技术者的blog，看他们写的都不错，都是使用hexo，所以查了下，hexo是重写过的，比起之前用ruby下的rake写的octopress，感觉看上去更好看一些，而且果然提供了很多的theme，感觉做的都很全也很漂亮。遂决定换到hexo了，用下来，感觉很方便，插件和风格也都很全。&lt;/p&gt;&lt;p&gt;插件这块，看到大家加了打赏功能了，我也默默的给加上了，不知道后续会不会有人给我打赏呢，入乡随俗啊，感觉国内这块的风气这点还是比较好的。 写文章的人很多，而且知识付费的意识也起来了。&lt;/p&gt;
    
    </summary>
    
      <category term="other" scheme="http://yangxinqi.com/categories/other/"/>
    
    
      <category term="octopress, hexo, next theme" scheme="http://yangxinqi.com/tags/octopress-hexo-next-theme/"/>
    
  </entry>
  
  <entry>
    <title>回顾2017</title>
    <link href="http://yangxinqi.com/2018/02/03/hui-gu-2017/"/>
    <id>http://yangxinqi.com/2018/02/03/hui-gu-2017/</id>
    <published>2018-02-03T14:11:27.000Z</published>
    <updated>2018-02-06T09:53:28.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Nov 02 2020 15:59:06 GMT+0900 (Japan Standard Time) --><p><img src="/images/shan.jpg?style=centerme" alt="img"></p><h3 id="回首"><a href="#回首" class="headerlink" title="回首"></a>回首</h3><p>2017年匆匆而过，回想下过去的一年，忙忙碌碌可始终还是两手空空，很充分的体会到初创公司，为之全力付出后商业模式无情的验证结果，一个公司是否能够赚钱，看结果就知道了。</p><p>用几个数字概括下：</p><p>开发了3个项目到上线</p><p>举办了10场亿咖啡的线下活动</p><p>投资了2家公司</p><a id="more"></a><h3 id="敏捷开发实践"><a href="#敏捷开发实践" class="headerlink" title="敏捷开发实践"></a>敏捷开发实践</h3><p>从1月开始到6月，都在为了客户的项目，作一个工程师应该做的事情，每天加班的把客户安排的活给清理掉。</p><p>转眼半年过去的很快。</p><p>开发还是挺有意思的，新的敏捷模式 + 使用N多的外部服务，用极少的工程师和时间快速的实现出业务流程，这点真的体会到卢兄的这种技术管理的思想还是很值得学习的。</p><p>在此感谢下卢兄。</p><h3 id="举办活动"><a href="#举办活动" class="headerlink" title="举办活动"></a>举办活动</h3><p>前半年活动也不少，弄了AI + 区块链的活动，吸引了不少朋友过来，也结交了很多新朋友。</p><p>在日本IT这个闷的不行的地方，我们也算尽了一点点力吧。</p><p>举办了10场活动，还是没有达到每月一场的目标，在这里感谢各位讲师，特别是王博士的AI基础普及课程。</p><h3 id="经历一场撕逼"><a href="#经历一场撕逼" class="headerlink" title="经历一场撕逼"></a>经历一场撕逼</h3><p>做为我们的客户，因为我们做了一个媒体的项目，居然过来要和我们撕逼，说我们也做了他们的行业，对于老熟人和创业者，心胸居然这么狭窄，这点让我比较难以接收，也撕逼了一场，不知道现在的项目还活着么？现在都记不起这个项目的名字了。</p><h3 id="投资一个新媒体项目"><a href="#投资一个新媒体项目" class="headerlink" title="投资一个新媒体项目"></a>投资一个新媒体项目</h3><p>为去年一起的项目启动了一个新媒体项目，投资人想打造一个类似今日头条一样的日本本地生活服务的APP，我们开发了个，但是陷入长期的没有推广的情况，体会到做一个项目容易，但是推广和坚持一个项目有多难。</p><p>也体会到项目没有投入继续维持的痛苦。最终妥协了，团队成员都派遣了。</p><h3 id="做了最不想做却不得不做的事情"><a href="#做了最不想做却不得不做的事情" class="headerlink" title="做了最不想做却不得不做的事情"></a>做了最不想做却不得不做的事情</h3><p>项目失败，无力支撑公司的运转，进而把团队的兄弟们都放到现场去了。 为了维持我们也都没有办法，作为一个项目负责人，是大家的带头大哥，我也比较抱歉，对于未来如何，现在也无可知晓了。 派遣还在继续，事情还是得继续推动下去，团队散出去容易，回来相对还是挺难的。这块多亏了张总的照顾，在这里表示感谢。</p><h3 id="等的花儿都谢了的一年也没等到"><a href="#等的花儿都谢了的一年也没等到" class="headerlink" title="等的花儿都谢了的一年也没等到"></a>等的花儿都谢了的一年也没等到</h3><p>合伙人归来，作为一个单枪匹马的创业者，公司从多个股东干到就剩下一个，也是没有谁了。 这点现在看来还是很需要我们把事情干好的，对于一个烂摊子谁也不想出来收拾，当然对于一个没有未来感的公司，大家也都不想投入是一样的。这块我们应该如何来分清主次呢？ 孤独感和协作感很考验一个创始团队。合伙人之于家里是同等重要的。</p><h3 id="出走国内"><a href="#出走国内" class="headerlink" title="出走国内"></a>出走国内</h3><p>对于没有安全感的我来讲，坚持到最后也坚持不下去的情况下，选择一口饭吃成为排解公司危机的主要方式。在坚持不下去的时候，选择了冷冻，开拓新的战场，在国内AI蓬勃发展的时机，回来体验下这样紧密的加班开发的环境。 国内的公司的工作氛围和日本完全不同，经历过熟悉又陌生的工作及生活后，陷入迷茫，未来会是什么样的？</p><p>其实国内之于日本没有好和不好之说，最关键的还是在一起做事情的人，国内优秀的人很多，优秀的公司也很多，其实相对于日本，竞争更为激烈，作为一个工程师需要做的事情更多。作为管理职位的人，需要发挥的更多，这块需要投入的也更多，不比自己创业付出的少，想成就一个伟大的事业，必须需要一个比较大的付出，其实如果只有一个目标，我们还是可以好好的来处理的。</p><h3 id="实战AI"><a href="#实战AI" class="headerlink" title="实战AI"></a>实战AI</h3><p>回国后的3个月，做了3个项目，上线1个，搁浅了2个，对于AI的初步认识以及实际使用有了一些更深入的了解。AI之于普通的企业来讲，还需要一个过程，但是降低成本提高效率这块，技术还是可以付出很多，有一定的提升空间。 在这边带的2个小朋友我也是刮目相看，这点真心的感觉不错，有些人战斗力爆棚，稍稍带下就可以发挥出来，有些人就不行了，上手很慢的说。</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>一年在忙碌中匆匆而过，最对不起的还是儿子和女儿，暂时的分离只是为了将来更好的生活。</p><p>2017年努力却没有什么回报，算账目是有盈余的，实际则不然，这也许就是商业的规则。作为局中人在没有退出时机的时候，剩下的只有投入，不断的投入。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Nov 02 2020 15:59:06 GMT+0900 (Japan Standard Time) --&gt;&lt;p&gt;&lt;img src=&quot;/images/shan.jpg?style=centerme&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;&lt;h3 id=&quot;回首&quot;&gt;&lt;a href=&quot;#回首&quot; class=&quot;headerlink&quot; title=&quot;回首&quot;&gt;&lt;/a&gt;回首&lt;/h3&gt;&lt;p&gt;2017年匆匆而过，回想下过去的一年，忙忙碌碌可始终还是两手空空，很充分的体会到初创公司，为之全力付出后商业模式无情的验证结果，一个公司是否能够赚钱，看结果就知道了。&lt;/p&gt;&lt;p&gt;用几个数字概括下：&lt;/p&gt;&lt;p&gt;开发了3个项目到上线&lt;/p&gt;&lt;p&gt;举办了10场亿咖啡的线下活动&lt;/p&gt;&lt;p&gt;投资了2家公司&lt;/p&gt;
    
    </summary>
    
      <category term="other" scheme="http://yangxinqi.com/categories/other/"/>
    
    
  </entry>
  
  <entry>
    <title>请停止无效努力</title>
    <link href="http://yangxinqi.com/2017/11/12/qing-ting-zhi-wu-xiao-nu-li/"/>
    <id>http://yangxinqi.com/2017/11/12/qing-ting-zhi-wu-xiao-nu-li/</id>
    <published>2017-11-12T13:43:26.000Z</published>
    <updated>2018-02-06T09:53:22.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Nov 02 2020 15:59:06 GMT+0900 (Japan Standard Time) --><p><img src="/images/sign.jpg?style=centerme" alt="img"></p><p>往往的往往，都是到最后的时间，开始做事情，几十年来依然是如此，从未改变过，为什么会这样呢？习惯吧，一个习惯的习惯，一直持续自己的各种做事方式，不尝试去改变自己，这样肯定是不行的说。</p><p>休息了一天，其实呢，感触比较深的是，做公司做人都是一样，盈利的目的性太强了，这个看过去不是什么好事，前期野蛮生长是必须的，壮大之后，你可以考虑生态，考虑到大家的幸福指数，但是在一切未安定之前，很难做到这块。</p><a id="more"></a><h4 id="自我效能"><a href="#自我效能" class="headerlink" title="自我效能"></a>自我效能</h4><p>勤奋一直都很勤奋的，每天不浪费时间，每周也不浪费时间，每个月更是如此，各种杂事及各种开发任务，客户维系，现在静下来，好好的梳理下，其实发现，真心需要整理下，迫切需要停止掉无谓的勤奋，一直很努力，依旧很失败，这块也许是很多人的写照吧。</p><h4 id="团队"><a href="#团队" class="headerlink" title="团队"></a>团队</h4><p>找优秀的人，有优秀的人加盟，或者是一直培养，让她成长起来，这2种方式对于人，是应该如何衡量呢？人又有拼劲，又能和团队的其他人相处，又有很好的技术，又很有责任心，其实要求很多，大部分很难做到，哪怕是你的合作伙伴都是如此的说。 所以从自身的性格上来看，很难找到和你一起的付出而不图回报的人，随着年龄的增大，冲劲和抗风险的能力都在持续的下降，所以人还是很难能够一直一直的走下去，更是拼劲全力的一起走下去。所以心态上放开来，很多事情，都是可遇而不可求的，人生总是如此，好朋友和知己总是寥寥无几，能够一起奋斗的都是在少数，我不是一个好的商人，但是可以做一个好的朋友，虽然大家都是在道上，时间流逝，一切随缘。</p><p>接下来，期望给自己找一个导师montor，急切需要一位人生导师，能够开导开导下，未来的方向在哪里？</p><p>找一些死党，当你在怎么不行的时候，也有人能够帮助你，能够让你重新出发。</p><h4 id="财务"><a href="#财务" class="headerlink" title="财务"></a>财务</h4><p>避税及年金保险，国内的五险一金以及各种税务法务方面的事情，这块都需要特别的注意，关于公司的固定资产和固定支出，这块也需要强烈的关注下，对于初创公司来讲，房租成本和其他的成本及年金保险这块每个月需要交的都是挺多的。</p><p>这块需要特别特别的注意，关注财务及正常的流水，保证正常的现金流，这块非常非常重要，这块特别要说到最推广预算方面，产品研发的水平可以控制，但是推广的成本很难控制住，所以提取做好预算是非常关键的。</p><p>还有对接在线支付，当我们需要在网上的做支付方式的时候，这块尤为重要，对接上了之后，我们能够实现正向收入并使得产品可以运营起来。</p><h4 id="方向"><a href="#方向" class="headerlink" title="方向"></a>方向</h4><p>区块链，人工智能，机器学习，未来的方向是在哪里，我们需要在哪个领域内扎根，好好的运营3年，未来很快，现在的数据内容很多，我们如何来进行很好的定位及突破方向，这块非常的重要。</p><p>选择一个好方向，现在如何金融领域深入，这块对我们来讲是一个很好的课题，金融领域结合人工智能及区块链技术，做一个稳定的定投产品出来。看好的方向及未来的发展，如何在方向压对上，赚到第一桶金，这块也非常的重要的说。</p><h4 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h4><p>先有的技术资源，各种外面已经做的很好的开源的项目及产品，我们都可以很好的用起来，虽然很多都需要另外付费的，有一些服务是能够长久使用的。</p><p>能够拿到的宣传资源，合作资源，这块也是需要很好的去梳理去实现的。</p><h4 id="人脉"><a href="#人脉" class="headerlink" title="人脉"></a>人脉</h4><p>如何认识和自己不是一个圈子的人，并把人脉维护好，需要跨界合作，现在花的时间还很少的说，这块需要强力的合作下。</p><p>跨界的人脉多认识一些，下班时间，多出去聚聚喝喝酒，有自己的圈子还是得要的说，人脉圈子还是挺重要的。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>多出去走走，把时间用在对的地方，做对的决策。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Nov 02 2020 15:59:06 GMT+0900 (Japan Standard Time) --&gt;&lt;p&gt;&lt;img src=&quot;/images/sign.jpg?style=centerme&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;&lt;p&gt;往往的往往，都是到最后的时间，开始做事情，几十年来依然是如此，从未改变过，为什么会这样呢？习惯吧，一个习惯的习惯，一直持续自己的各种做事方式，不尝试去改变自己，这样肯定是不行的说。&lt;/p&gt;&lt;p&gt;休息了一天，其实呢，感触比较深的是，做公司做人都是一样，盈利的目的性太强了，这个看过去不是什么好事，前期野蛮生长是必须的，壮大之后，你可以考虑生态，考虑到大家的幸福指数，但是在一切未安定之前，很难做到这块。&lt;/p&gt;
    
    </summary>
    
      <category term="project" scheme="http://yangxinqi.com/categories/project/"/>
    
    
  </entry>
  
</feed>
