<!-- build time:Tue Apr 06 2021 22:51:16 GMT+0900 (Japan Standard Time) --><!DOCTYPE html><html class="theme-next muse use-motion" lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=6.0.3" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.0.3"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.0.3"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.0.3"><link rel="mask-icon" href="/images/logo.svg?v=6.0.3" color="#222"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Muse",version:"6.0.3",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!1,fastclick:!1,lazyload:!1,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><meta name="keywords" content="solidity,"><meta name="description" content="前言做区块链相关的创业已经有4年了，都是做ETL方面的，对于真正的合约以及Trading，其实没有真正的使用，技术就是这样，用了就会发现有意思，从最早的没有信仰，到现在的信心满满，虽然BTC的价格还是3年前BTC的价格，但是市场已经今非昔比了，从DEFI的火热，到各种POOL的出现，区块链的运营方式和目标人群都巨大的变化了。在大经济形势周期的转变下，我也从数据，转战到了DEFI，因为DEFI才是代"><meta name="keywords" content="solidity"><meta property="og:type" content="article"><meta property="og:title" content="solidity学习笔记"><meta property="og:url" content="http://yangxinqi.com/2020/11/02/solidity学习笔记/index.html"><meta property="og:site_name" content="xinqiyang notes"><meta property="og:description" content="前言做区块链相关的创业已经有4年了，都是做ETL方面的，对于真正的合约以及Trading，其实没有真正的使用，技术就是这样，用了就会发现有意思，从最早的没有信仰，到现在的信心满满，虽然BTC的价格还是3年前BTC的价格，但是市场已经今非昔比了，从DEFI的火热，到各种POOL的出现，区块链的运营方式和目标人群都巨大的变化了。在大经济形势周期的转变下，我也从数据，转战到了DEFI，因为DEFI才是代"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="http://yangxinqi.com/images/solidity.jpeg"><meta property="og:updated_time" content="2020-11-02T06:58:48.604Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="solidity学习笔记"><meta name="twitter:description" content="前言做区块链相关的创业已经有4年了，都是做ETL方面的，对于真正的合约以及Trading，其实没有真正的使用，技术就是这样，用了就会发现有意思，从最早的没有信仰，到现在的信心满满，虽然BTC的价格还是3年前BTC的价格，但是市场已经今非昔比了，从DEFI的火热，到各种POOL的出现，区块链的运营方式和目标人群都巨大的变化了。在大经济形势周期的转变下，我也从数据，转战到了DEFI，因为DEFI才是代"><meta name="twitter:image" content="http://yangxinqi.com/images/solidity.jpeg"><link rel="alternate" href="/atom.xml" title="xinqiyang notes" type="application/atom+xml"><link rel="canonical" href="http://yangxinqi.com/2020/11/02/solidity学习笔记/"><script type="text/javascript" id="page.configurations">CONFIG.page={sidebar:""}</script><title>solidity学习笔记 | xinqiyang notes</title><noscript><style type="text/css">.sidebar-inner,.use-motion .brand,.use-motion .collection-title,.use-motion .comments,.use-motion .menu-item,.use-motion .motion-element,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .logo,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">xinqiyang notes</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">Nothing behind me, everything ahead of me,as is ever so on the road.</p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-finance"><a href="/categories/finance" rel="section"><i class="menu-item-icon fa fa-fw fa-money"></i><br>finance</a></li><li class="menu-item menu-item-blockchain"><a href="/categories/blockchain" rel="section"><i class="menu-item-icon fa fa-fw fa-bitcoin"></i><br>blockchain</a></li><li class="menu-item menu-item-ai"><a href="/categories/ai" rel="section"><i class="menu-item-icon fa fa-fw fa-star"></i><br>ai</a></li><li class="menu-item menu-item-devops"><a href="/categories/devops" rel="section"><i class="menu-item-icon fa fa-fw fa-code"></i><br>devops</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-other"><a href="/categories/other" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>other</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://yangxinqi.com/2020/11/02/solidity学习笔记/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="xinqiyang"><meta itemprop="description" content=""><meta itemprop="image" content="/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="xinqiyang notes"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">solidity学习笔记</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-11-02T14:06:16+09:00">2020-11-02</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/blockchain/" itemprop="url" rel="index"><span itemprop="name">blockchain</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>做区块链相关的创业已经有4年了，都是做ETL方面的，对于真正的合约以及Trading，其实没有真正的使用，技术就是这样，用了就会发现有意思，从最早的没有信仰，到现在的信心满满，虽然BTC的价格还是3年前BTC的价格，但是市场已经今非昔比了，从DEFI的火热，到各种POOL的出现，区块链的运营方式和目标人群都巨大的变化了。在大经济形势周期的转变下，我也从数据，转战到了DEFI，因为DEFI才是代表了未来真正的放下，大环境下，随着疫情，越来越多的政府和国家地区更深入的隔绝，对于崇尚自由的人来说，我们更应该获得真正意义上的金融自由。虽然现在Blockchain还是被美帝把持着。</p><p>闲话不多说，我们开始真正的来玩转合约，合约从Ether起，也和Ether的创始团队息息相关，从V神，还有WOOD博士开始，Ether的出现也带来了Solidity和Vyper,智能合约语言，目前来看Vyper更安全，而Solidity使用更广泛，本文主要讲Solidity的开发和使用。</p><p>Solidity文档： <a href="https://learnblockchain.cn/docs/solidity/introduction-to-smart-contracts.html" target="_blank" rel="noopener">https://learnblockchain.cn/docs/solidity/introduction-to-smart-contracts.html</a></p><p><img src="/images/solidity.jpeg" alt="Solidity"></p><a id="more"></a><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><h4 id="Solidity语法"><a href="#Solidity语法" class="headerlink" title="Solidity语法"></a>Solidity语法</h4><p>Solidity 是一门面向合约的、为实现智能合约而创建的高级编程语言。这门语言受到了 C++，Python 和 Javascript 语言的影响，设计的目的是能在 <a href="https://learnblockchain.cn/2019/04/09/easy-evm/" target="_blank" rel="noopener">以太坊虚拟机（EVM）</a> 上运行。Solidity 是静态类型语言，支持继承、库和复杂的用户定义类型等特性。在部署合约时，应该尽量使用最新版本，因为新版本会有一些重大的新特性以及bug修复。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: GPL-3.0 </span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.4</span><span class="number">.16</span> &lt;<span class="number">0.8</span><span class="number">.0</span>; </span><br><span class="line"></span><br><span class="line">contract SimpleStorage &#123;</span><br><span class="line">  uint storedData;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">set</span>(<span class="params">uint x</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">  storedData = x;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> storedData;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>pragmas（编译指令）是告知编译器如何处理源代码的指令, Solidity中合约的含义就是一组代码（它的 <em>函数</em> )和数据（它的 <em>状态</em> ），它们位于以太坊区块链的一个特定地址上。该合约能完成的事情并不多（由于以太坊构建的基础架构的原因）：它能允许任何人在合约中存储一个单独的数字，并且这个数字可以被世界上任何人访问，且没有可行的办法阻止你发布这个数字。当然，任何人都可以再次调用 <code>set</code> ，传入不同的值，覆盖你的数字，但是这个数字仍会被存储在区块链的历史记录中。随后，我们会看到怎样施加访问限制，以确保只有你才能改变这个数字。 所有的标识符（合约名称，函数名称和变量名称）都只能使用ASCII字符集。UTF-8编码的数据可以用字符串变量的形式存储。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: GPL-3.0</span></span><br><span class="line">pragma solidity  &gt;<span class="number">0.5</span><span class="number">.99</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract Coin &#123;</span><br><span class="line">    <span class="comment">// 关键字“public”让这些变量可以从外部读取</span></span><br><span class="line">    address public minter;</span><br><span class="line">    mapping (<span class="function"><span class="params">address</span> =&gt;</span> uint) public balances;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 轻客户端可以通过事件针对变化作出高效的反应</span></span><br><span class="line">    event Sent(address <span class="keyword">from</span>, address to, uint amount);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这是构造函数，只有当合约创建时运行</span></span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        minter = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 铸币操作</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">mint</span>(<span class="params">address receiver, uint amount</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(msg.sender == minter);</span><br><span class="line">        <span class="built_in">require</span>(amount &lt; <span class="number">1e60</span>);</span><br><span class="line">        balances[receiver] += amount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 转币操作</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">send</span>(<span class="params">address receiver, uint amount</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(amount &lt;= balances[msg.sender], <span class="string">"Insufficient balance."</span>);</span><br><span class="line">        balances[msg.sender] -= amount;</span><br><span class="line">        balances[receiver] += amount;</span><br><span class="line">        emit Sent(msg.sender, receiver, amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>address public minter;</code> 这一行声明了一个可以被公开访问的 <code>address</code> 类型的状态变量。 <code>address</code> 类型是一个160位的值，且不允许任何算数操作。mapping (address =&gt; uint) public balances;` 也创建一个公共状态变量，但它是一个更复杂的数据类型。 该类型将address映射为无符号整数。 Mappings 可以看作是一个 <a href="https://en.wikipedia.org/wiki/Hash_table" target="_blank" rel="noopener">哈希表</a> 它会执行虚拟初始化，以使所有可能存在的键都映射到一个字节表示为全零的值。 但是，这种类比并不太恰当，因为它既不能获得映射的所有键的列表，也不能获得所有值的列表。</p><p><code>event Sent(address from, address to, uint amount);</code> 这行声明了一个所谓的“事件（event）”，它会在 <code>send</code> 函数的最后一行被发出。</p><p>对于程序员来说，区块链这个概念并不难理解，这是因为大多数难懂的东西 (挖矿, <a href="https://en.wikipedia.org/wiki/Cryptographic_hash_function" target="_blank" rel="noopener">哈希</a> ，<a href="https://en.wikipedia.org/wiki/Elliptic_curve_cryptography" target="_blank" rel="noopener">椭圆曲线密码学</a> ，<a href="https://en.wikipedia.org/wiki/Peer-to-peer" target="_blank" rel="noopener">点对点网络（P2P）</a> 等) 都只是用于提供特定的功能和承诺。</p><p><strong>区块，交易，事务</strong></p><p>区块链是全球共享的事务性数据库，这意味着每个人都可加入网络来阅读数据库中的记录。如果你想改变数据库中的某些东西，你必须创建一个被所有其他人所接受的事务。此外，交易总是由发送人（创建者）签名。</p><p>在比特币中，要解决的一个主要难题，被称为“双花攻击 (double-spend attack)”：如果网络存在两笔交易，都想花光同一个账户的钱时（即所谓的冲突）会发生什么情况？交易互相冲突？</p><p><strong>以太仿虚拟机EVM</strong></p><p>以太坊虚拟机 EVM 是智能合约的运行环境。它不仅是沙盒封装的，而且是完全隔离的，也就是说在 EVM 中运行代码是无法访问网络、文件系统和其他进程的。甚至智能合约之间的访问也是受限的。以太坊中有两类账户（它们共用同一个地址空间）： <strong>外部账户</strong> 由公钥-私钥对（也就是人）控制； <strong>合约账户</strong> 由和账户一起存储的代码控制.每个账户都有一个键值对形式的持久化存储。其中 key 和 value 的长度都是256位，我们称之为 <strong>存储</strong> 。此外，每个账户有一个以太币余额（ <strong>balance</strong> ）（单位是“Wei”, <code>1 ether</code> 是 <code>10**18 wei</code>），余额会因为发送包含以太币的交易而改变。交易可以看作是从一个帐户发送到另一个帐户的消息（这里的账户，可能是相同的或特殊的零帐户，请参阅下文）。它能包含一个二进制数据（合约负载）和以太币。如果目标账户含有代码，此代码会被执行，并以 payload 作为入参。如果目标账户是零账户（账户地址为 <code>0</code> )，此交易将创建一个 <strong>新合约</strong> 。 如前文所述，合约的地址不是零地址，而是通过合约创建者的地址和从该地址发出过的交易数量计算得到的（所谓的“nonce”）。 这个用来创建合约的交易的 payload 会被转换为 EVM 字节码并执行。执行的输出将作为合约代码被永久存储。这意味着，为创建一个合约，你不需要发送实际的合约代码，而是发送能够产生合约代码的代码。</p><p>一经创建，每笔交易都收取一定数量的 <strong>gas</strong> ，目的是限制执行交易所需要的工作量和为交易支付手续费。EVM 执行交易时，gas 将按特定规则逐渐耗尽。<strong>gas price</strong> 是交易发送者设置的一个值，发送者账户需要预付的手续费= <code>gas_price * gas</code> 。如果交易执行后还有剩余， gas 会原路返还。无论执行到什么位置，一旦 gas 被耗尽（比如降为负值），将会触发一个 out-of-gas 异常。当前调用帧（call frame）所做的所有状态修改都将被回滚。译者注：调用帧（call frame），指的是下文讲到的EVM的运行栈（stack）中当前操作所需要的若干元素。</p><p>每个账户有一块持久化内存区称为 <strong>存储</strong> 。 存储是将256位字映射到256位字的键值存储区。 在合约中枚举存储是不可能的，且读存储的相对开销很高，修改存储的开销甚至更高。合约只能读写存储区内属于自己的部分。</p><p>第二个内存区称为 <strong>内存</strong> ，合约会试图为每一次消息调用获取一块被重新擦拭干净的内存实例。 内存是线性的，可按字节级寻址，但读的长度被限制为256位，而写的长度可以是8位或256位。当访问（无论是读还是写）之前从未访问过的内存字（word）时（无论是偏移到该字内的任何位置），内存将按字进行扩展（每个字是256位）。扩容也将消耗一定的gas。 随着内存使用量的增长，其费用也会增高（以平方级别）。</p><p>EVM 不是基于寄存器的，而是基于栈的，因此所有的计算都在一个被称为 <strong>栈（stack）</strong> 的区域执行。 栈最大有1024个元素，每个元素长度是一个字（256位）。对栈的访问只限于其顶端，限制方式为：允许拷贝最顶端的16个元素中的一个到栈顶，或者是交换栈顶元素和下面16个元素中的一个。所有其他操作都只能取最顶的两个（或一个，或更多，取决于具体的操作）元素，运算后，把结果压入栈顶。当然可以把栈上的元素放到存储或内存中。但是无法只访问栈上指定深度的那个元素，除非先从栈顶移除其他元素。</p><p>EVM的指令集量应尽量少，以最大限度地避免可能导致共识问题的错误实现。所有的指令都是针对”256位的字（word）”这个基本的数据类型来进行操作。具备常用的算术、位、逻辑和比较操作。也可以做到有条件和无条件跳转。此外，合约可以访问当前区块的相关属性，比如它的编号和时间戳。</p><p>有一种特殊类型的消息调用，被称为 <strong>委托调用(delegatecall)</strong> 。它和一般的消息调用的区别在于，目标地址的代码将在发起调用的合约的上下文中执行，并且 <code>msg.sender</code> 和 <code>msg.value</code> 不变。 这意味着一个合约可以在运行时从另外一个地址动态加载代码。存储、当前地址和余额都指向发起调用的合约，只有代码是从被调用地址获取的。 这使得 Solidity 可以实现”库“能力：可复用的代码库可以放在一个合约的存储上，如用来实现复杂的数据结构的库。</p><p>有一种特殊的可索引的数据结构，其存储的数据可以一路映射直到区块层级。这个特性被称为 <strong>日志(logs)</strong> ，Solidity用它来实现 <strong>事件(events)</strong> 。合约创建之后就无法访问日志数据，但是这些数据可以从区块链外高效的访问。因为部分日志数据被存储在 <a href="https://en.wikipedia.org/wiki/Bloom_filter" target="_blank" rel="noopener">布隆过滤器（Bloom filter)</a> 中，我们可以高效并且加密安全地搜索日志，所以那些没有下载整个区块链的网络节点（轻客户端）也可以找到这些日志。</p><p>合约代码从区块链上移除的唯一方式是合约在合约地址上的执行自毁操作 <code>selfdestruct</code> 。合约账户上剩余的以太币会发送给指定的目标，然后其存储和代码从状态中被移除。移除一个合约听上去不错，但其实有潜在的危险，如果有人发送以太币到移除的合约，这些以太币将永远提丢失。</p><h4 id="安装Solidity"><a href="#安装Solidity" class="headerlink" title="安装Solidity"></a>安装Solidity</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### 最常用的还是通过nodejs来安装</span></span><br><span class="line">npm install -g solc</span><br><span class="line"></span><br><span class="line">docker run ethereum/solc:stable solc --version</span><br><span class="line"></span><br><span class="line">sudo add-apt-repository ppa:ethereum/ethereum</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install solc</span><br><span class="line"></span><br><span class="line"><span class="comment">## 从源码安装</span></span><br><span class="line">sudo xcodebuild -license accept</span><br></pre></td></tr></table></figure><h4 id="Solidity源文件结构"><a href="#Solidity源文件结构" class="headerlink" title="Solidity源文件结构"></a>Solidity源文件结构</h4><p>源文件中可以包含任意多个 <a href="https://learnblockchain.cn/docs/solidity/structure-of-a-contract.html#contract-structure" target="_blank" rel="noopener">合约定义</a> 、<a href="https://learnblockchain.cn/docs/solidity/layout-of-source-files.html#import" target="_blank" rel="noopener">导入源文件指令</a> 、 <a href="https://learnblockchain.cn/docs/solidity/layout-of-source-files.html#pragma" target="_blank" rel="noopener">版本标识</a> 指令、 <a href="https://learnblockchain.cn/docs/solidity/types.html#structs" target="_blank" rel="noopener">结构体</a> , <a href="https://learnblockchain.cn/docs/solidity/types.html#enums" target="_blank" rel="noopener">枚举</a> 和 <a href="https://learnblockchain.cn/docs/solidity/contracts.html#functions" target="_blank" rel="noopener">函数</a> 定义.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.5</span><span class="number">.2</span>;</span><br></pre></td></tr></table></figure><p>这样，源文件将既不允许低于 0.5.2 版本的编译器编译， 也不允许高于（包含） <code>0.6.0</code> 版本的编译器编译（第二个条件因使用 <code>^</code> 被添加）。 这种做法的考虑是，编译器在 0.6.0 版本之前不会有重大变更，所以可确保源代码始终按预期被编译。 上面例子中不固定编译器的具体版本号，因此编译器的补丁版也可以使用。</p><p>Pragma 是 pragmatic information 的简称，微软 Visual C++ <a href="https://msdn.microsoft.com/zh-cn/library/d9x1s805.aspx" target="_blank" rel="noopener">文档</a> 中译为标识。 Solidity 中沿用 C ，C++ 等中的编译指令概念，用于告知编译器 <strong>如何</strong> 编译。 ——译者注</p><p>第2个标注是用来标注实验性阶段的功能，它可以用来启用一些新的编译器功能或语法特性。 当前支持下面的一些实验性标注: ABIEncoderV2</p><p>新的 ABI 编码器可以用来编码和解码嵌套的数组和结构体，当然这部分代码还在优化之中，他没有像之前 ABI 编码器 那样经过严格的测试，我们可以使用下面的语法来启用它</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pragma experimental ABIEncoderV2;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"filename"</span>;</span><br></pre></td></tr></table></figure><p>ES6 即 ECMAScript 6.0，ES6是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布。 ——译者注</p><p>通常使用相对引用 <code>import &quot;./filename.sol&quot;;</code> 并且避免使用 <code>..</code> ，后面这种方式可以使用全局路径并设置映射，下面会有解释。</p><p>可以使用单行注释（<code>//</code>）和多行注释（<code>/*...*/</code>）</p><p>在 Solidity 语言中，合约类似于其他面向对象编程语言中的<strong>类</strong>。</p><p>每个合约中可以包含 <a href="https://learnblockchain.cn/docs/solidity/structure-of-a-contract.html#structure-state-variables" target="_blank" rel="noopener">状态变量</a>、 <a href="https://learnblockchain.cn/docs/solidity/structure-of-a-contract.html#structure-functions" target="_blank" rel="noopener">函数</a>、<a href="https://learnblockchain.cn/docs/solidity/structure-of-a-contract.html#structure-events" target="_blank" rel="noopener">事件 Event</a>、 <a href="https://learnblockchain.cn/docs/solidity/structure-of-a-contract.html#structure-struct-types" target="_blank" rel="noopener">结构体</a>、 和 <a href="https://learnblockchain.cn/docs/solidity/structure-of-a-contract.html#structure-enum-types" target="_blank" rel="noopener">枚举类型</a> 的声明，且合约可以从其他合约继承。</p><p>还有一些特殊的合约，如： <a href="https://learnblockchain.cn/docs/solidity/contracts.html#libraries" target="_blank" rel="noopener">库</a> 和 <a href="https://learnblockchain.cn/docs/solidity/contracts.html#interfaces" target="_blank" rel="noopener">接口</a>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=<span class="number">0.4</span><span class="number">.0</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract TinyStorage &#123;</span><br><span class="line">    uint storedXlbData; <span class="comment">// 状态变量</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: GPL-3.0</span></span><br><span class="line">pragma solidity &gt;<span class="number">0.7</span><span class="number">.0</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract TinyAuction &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Mybid</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">payable</span> </span>&#123; <span class="comment">// 定义函数</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Helper function defined outside of a contract</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">helper</span>(<span class="params">uint x</span>) <span class="title">pure</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=<span class="number">0.4</span><span class="number">.22</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract MyPurchase &#123;</span><br><span class="line">    address public seller;</span><br><span class="line"></span><br><span class="line">    modifier onlySeller() &#123; <span class="comment">// 修改器</span></span><br><span class="line">        <span class="built_in">require</span>(</span><br><span class="line">            msg.sender == seller,</span><br><span class="line">            <span class="string">"Only seller can call this."</span></span><br><span class="line">        );</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">abort</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">onlySeller</span> </span>&#123; <span class="comment">// 修改器用法</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数 修改器modifier 可以用来以声明的方式修改函数语义（参阅合约章节中 <a href="https://learnblockchain.cn/docs/solidity/contracts.html#modifiers" target="_blank" rel="noopener">函数修改器</a>）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=<span class="number">0.4</span><span class="number">.21</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line">contract TinyAuction &#123;</span><br><span class="line">    event HighestBidIncreased(address bidder, uint amount); <span class="comment">// 事件</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bid</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">payable</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        emit HighestBidIncreased(msg.sender, msg.value); <span class="comment">// 触发事件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事件是能方便地调用以太坊虚拟机日志功能的接口。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=<span class="number">0.4</span><span class="number">.0</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract TinyBallot &#123;</span><br><span class="line">    struct Voter &#123; <span class="comment">// 结构体 结构体是可以将几个变量分组的自定义类型</span></span><br><span class="line">        uint weight;</span><br><span class="line">        bool voted;</span><br><span class="line">        address delegate;</span><br><span class="line">        uint vote;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=<span class="number">0.4</span><span class="number">.0</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract Upchain &#123;</span><br><span class="line">    enum State &#123; Created, Locked, InValid &#125; <span class="comment">// 枚举 枚举可用来创建由一定数量的“常量值”构成的自定义类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h4><p><code>bool</code> ：可能的取值为字面常量值 <code>true</code> 和 <code>false</code> 。</p><p>运算符：</p><ul><li><p><code>!</code> （逻辑非）</p></li><li><p><code>&amp;&amp;</code> （逻辑与， “and” ）</p></li><li><p><code>||</code> （逻辑或， “or” ）</p></li><li><p><code>==</code> （等于）</p></li><li><p><code>!=</code> （不等于）</p><p>运算符 <code>||</code> 和 <code>&amp;&amp;</code> 都遵循同样的短路（ short-circuiting ）规则。就是说在表达式 <code>f(x) || g(y)</code> 中， 如果 <code>f(x)</code> 的值为 <code>true</code> ，那么 <code>g(y)</code> 就不会被执行，即使会出现一些副作用。</p></li></ul><p><code>int</code> / <code>uint</code> ：分别表示有符号和无符号的不同位数的整型变量。 支持关键字 <code>uint8</code> 到 <code>uint256</code> （无符号，从 8 位到 256 位）以及 <code>int8</code> 到 <code>int256</code>，以 <code>8</code> 位为步长递增。 <code>uint</code> 和 <code>int</code> 分别是 <code>uint256</code> 和 <code>int256</code> 的别名。</p><p>运算符：</p><ul><li>比较运算符： <code>&lt;=</code> ， <code>&lt;</code> ， <code>==</code> ， <code>!=</code> ， <code>&gt;=</code> ， <code>&gt;</code> （返回布尔值）</li><li>位运算符： <code>&amp;</code> ， <code>|</code> ， <code>^</code> （异或）， <code>~</code> （位取反）</li><li>移位运算符： <code>&lt;&lt;</code> （左移位） ， <code>&gt;&gt;</code> （右移位）</li><li>算数运算符： <code>+</code> ， <code>-</code> ， 一元运算 <code>-</code> ， 一元运算 <code>+</code> ， <code>*</code> ， <code>/</code> ， <code>%</code> （取余或叫模运算） ， <code>**</code> （幂）</li></ul><p>对于整形 <code>X</code>，可以使用 <code>type(X).min</code> 和 <code>type(X).max</code> 去获取这个类型的最小值与最大值。</p><p>加法，减法和乘法具有通常的语义，值用两进制补码表示，意思是比如：<code>uint256（0） - uint256（1）== 2 ** 256 - 1</code> 。 我们在设计和编写智能合约时必须考虑到溢出问题。</p><p>表达式 <code>-x</code> 相当于 <code>(T(0) - x)</code> 这里 <code>T</code> 是指 <code>x</code> 的类型。 这意味着如果 <code>x</code> 的类型的类型是无符号整数类型 <code>-x</code> 不会是负数。 另外，如果 <code>x</code> 为负数， <code>-x</code> 也可以为正数。 由于两进制补码表示还需要小心:</p><p>除法运算结果的类型始终是其中一个操作数的类型，整数除法总是产生整数。 在Solidity中，分数会取零。 这意味着 <code>int256(-5) / int256(2) == int256(-2)</code></p><p>注意在智能合约中，在 <a href="https://learnblockchain.cn/docs/solidity/types.html#rational-literals" target="_blank" rel="noopener">字面常量</a> 上进行除法会保留精度（保留小数位）。</p><p><strong>除以0 会发生错误（assert 类型错误）。</strong></p><p>模运算 <code>a％n</code> 是在操作数 <code>a</code> 的除以 <code>n</code> 之后产生余数 <code>r</code> ，其中 <code>q = int(a / n)</code> 和 <code>r = a - (n * q)</code> 。 这意味着模运算结果与左操作数相同的符号相同（或零）。 对于 负数的a : <code>a % n == -(a % n)</code>， 几个例子：</p><blockquote><ul><li><code>int256(5) % int256(2) == int256(1)</code></li><li><code>int256(5) % int256(-2) == int256(1)</code></li><li><code>int256(-5) % int256(2) == int256(-1)</code></li><li><code>int256(-5) % int256(-2) == int256(-1)</code></li></ul></blockquote><p>注解, 对0取模会发生错误（assert 类型错误）。</p><p><strong>注意 `0</strong>0<code>在EVM中定义为</code>1` 。**</p><p><code>fixed</code> / <code>ufixed</code>：表示各种大小的有符号和无符号的定长浮点型。 在关键字 <code>ufixedMxN</code> 和 <code>fixedMxN</code> 中，<code>M</code> 表示该类型占用的位数，<code>N</code> 表示可用的小数位数。 <code>M</code> 必须能整除 8，即 8 到 256 位。 <code>N</code> 则可以是从 0 到 80 之间的任意数。 <code>ufixed</code> 和 <code>fixed</code> 分别是 <code>ufixed128x19</code> 和 <code>fixed128x19</code> 的别名。</p><p>地址类型有两种形式，他们大致相同：</p><blockquote><ul><li><code>address</code>：保存一个20字节的值（以太坊地址的大小）。</li><li><code>ddress payable</code> ：可支付地址，与 <code>address</code> 相同，不过有成员函数 <code>transfer</code> 和 <code>send</code> 。</li></ul></blockquote><p>这种区别背后的思想是 <strong><code>address payable</code> 可以接受以太币的地址，而一个普通的 <code>address</code> 则不能</strong>。</p><p>可以使用 <code>balance</code> 属性来查询一个地址的余额， 也可以使用 <code>transfer</code> 函数向一个可支付地址（payable address）发送 以太币Ether （以 wei 为单位）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">address x = 0x123;</span><br><span class="line">address myAddress = this;</span><br><span class="line"><span class="keyword">if</span> (x.balance &lt; 10 &amp;&amp; myAddress.balance &gt;= 10) x.transfer(10);</span><br></pre></td></tr></table></figure><p>如果当前合约的余额不够多，则 <code>transfer</code> 函数会执行失败，或者如果以太转移被接收帐户拒绝， <code>transfer</code> 函数同样会失败而进行回退。</p><p>如果 <code>x</code> 是一个合约地址，它的代码（更具体来说是, 如果有receive函数, 执行 <a href="https://learnblockchain.cn/docs/solidity/contracts.html#receive-ether-function" target="_blank" rel="noopener">receive 接收以太函数</a>, 或者存在fallback函数,执行 <a href="https://learnblockchain.cn/docs/solidity/contracts.html#fallback-function" target="_blank" rel="noopener">Fallback 回退函数</a> 函数）会跟 <code>transfer</code> 函数调用一起执行（这是 EVM 的一个特性，无法阻止）。 如果在执行过程中用光了 gas 或者因为任何原因执行失败，以太币Ether 交易会被打回，当前的合约也会在终止的同时抛出异常。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">警告⚠️：</span><br><span class="line">在使用 send 的时候会有些风险：如果调用栈深度是 1024 会导致发送失败（这总是可以被调用者强制），如果接收者用光了 gas 也会导致发送失败。 所以为了保证 以太币Ether 发送的安全，一定要检查 send 的返回值，使用 transfer 或者更好的办法： 使用接收者自己取回资金的模式。</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bytes memory payload = abi.encodeWithSignature(<span class="string">"register(string)"</span>, <span class="string">"MyName"</span>);</span><br><span class="line">(bool success, bytes memory returnData) = address(nameReg).call(payload);</span><br><span class="line"><span class="built_in">require</span>(success);</span><br><span class="line"></span><br><span class="line">address nameReg = <span class="number">0x72ba7d8e73fe8eb666ea66babc8116a41bfb10e2</span>;</span><br><span class="line">nameReg.call(<span class="string">"register"</span>, <span class="string">"MyName"</span>);</span><br><span class="line">nameReg.call(bytes4(keccak256(<span class="string">"fun(uint256)"</span>)), a);</span><br></pre></td></tr></table></figure><p>所有这些函数都是低级函数，应谨慎使用。 具体来说，任何未知的合约都可能是恶意的，我们在调用一个合约的同时就将控制权交给了它，而合约又可以回调合约，所以要准备好在调用返回时改变相应的状态变量（可参考 <a href="https://learnblockchain.cn/docs/solidity/security-considerations.html#re-entance" target="_blank" rel="noopener">可重入</a> )， 与其他合约交互的常规方法是在合约对象上调用函数（x.f()）。</p><p>所有三个函数 <code>call</code> ，<code>delegatecall</code> 和 <code>staticcall</code> 都是非常低级的函数，应该只把它们当作 <em>最后一招</em> 来使用，因为它们破坏了 Solidity 的类型安全性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">uint128 a = <span class="number">1</span>;</span><br><span class="line">uint128 b = <span class="number">2.5</span> + a + <span class="number">0.5</span>;</span><br><span class="line"></span><br><span class="line">bytes32 samevar = <span class="string">"stringliteral"</span>;</span><br><span class="line">string memory a = unicode<span class="string">"Hello 😃"</span>;</span><br><span class="line">hex<span class="string">"0011223344556677"</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: GPL-3.0</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.4</span><span class="number">.16</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract test &#123;</span><br><span class="line">    enum ActionChoices &#123; GoLeft, GoRight, GoStraight, SitStill &#125;</span><br><span class="line">    ActionChoices choice;</span><br><span class="line">    ActionChoices constant defaultChoice = ActionChoices.GoStraight;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setGoStraight</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        choice = ActionChoices.GoStraight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于枚举类型不属于 |ABI| 的一部分，因此对于所有来自 Solidity 外部的调用，</span></span><br><span class="line">    <span class="comment">// "getChoice" 的签名会自动被改成 "getChoice() returns (uint8)"。</span></span><br><span class="line">    <span class="comment">// 整数类型的大小已经足够存储所有枚举类型的值，随着值的个数增加，</span></span><br><span class="line">    <span class="comment">// 可以逐渐使用 `uint16` 或更大的整数类型。</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getChoice</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">ActionChoices</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> choice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getDefaultChoice</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> uint(defaultChoice);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">&lt;parameter types&gt;</span>) </span>&#123;internal|external&#125; [pure|constant|view|payable] [returns (&lt;return types&gt;)]</span><br></pre></td></tr></table></figure><ul><li><p>内存memory 即数据在内存中，因此数据仅在其生命周期内（函数调用期间）有效。不能用于外部调用。</p></li><li><p>存储storage 状态变量保存的位置，只要合约存在就一直存储．</p></li><li><p>调用数据calldata 用来保存函数参数的特殊数据位置，是一个只读位置。</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: GPL-3.0</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.5</span><span class="number">.0</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract Tiny &#123;</span><br><span class="line">    uint[] x; <span class="comment">// x 的数据存储位置是 storage，　位置可以忽略</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// memoryArray 的数据存储位置是 memory</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">uint[] memory memoryArray</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        x = memoryArray; <span class="comment">// 将整个数组拷贝到 storage 中，可行</span></span><br><span class="line">        uint[] storage y = x;  <span class="comment">// 分配一个指针（其中 y 的数据存储位置是 storage），可行</span></span><br><span class="line">        y[<span class="number">7</span>]; <span class="comment">// 返回第 8 个元素，可行</span></span><br><span class="line">        y.pop(); <span class="comment">// 通过 y 修改 x，可行</span></span><br><span class="line">        <span class="keyword">delete</span> x; <span class="comment">// 清除数组，同时修改 y，可行</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面的就不可行了；需要在 storage 中创建新的未命名的临时数组，</span></span><br><span class="line">        <span class="comment">// 但 storage 是“静态”分配的：</span></span><br><span class="line">        <span class="comment">// y = memoryArray;</span></span><br><span class="line">        <span class="comment">// 下面这一行也不可行，因为这会“重置”指针，</span></span><br><span class="line">        <span class="comment">// 但并没有可以让它指向的合适的存储位置。</span></span><br><span class="line">        <span class="comment">// delete y;</span></span><br><span class="line"></span><br><span class="line">        g(x); <span class="comment">// 调用 g 函数，同时移交对 x 的引用</span></span><br><span class="line">        h(x); <span class="comment">// 调用 h 函数，同时在 memory 中创建一个独立的临时拷贝</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params">uint[] storage </span>) <span class="title">internal</span> <span class="title">pure</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">h</span>(<span class="params">uint[] memory</span>) <span class="title">public</span> <span class="title">pure</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=<span class="number">0.6</span><span class="number">.99</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract <span class="built_in">Proxy</span> &#123;</span><br><span class="line">    <span class="comment">/// 被当前合约管理的 客户端合约地址</span></span><br><span class="line">    address client;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(address _client) &#123;</span><br><span class="line">        client = _client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 在进行参数验证之后，转发到由client实现的 "setOwner(address)"</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">forward</span>(<span class="params">bytes calldata _payload</span>) <span class="title">external</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 由于 ABI 解码要求填充的数据（padded data）不能使用</span></span><br><span class="line">        <span class="comment">// abi.decode(_payload[:4], (bytes4)).</span></span><br><span class="line">        bytes4 sig =</span><br><span class="line">            _payload[<span class="number">0</span>] |</span><br><span class="line">            (bytes4(_payload[<span class="number">1</span>]) &gt;&gt; <span class="number">8</span>) |</span><br><span class="line">            (bytes4(_payload[<span class="number">2</span>]) &gt;&gt; <span class="number">16</span>) |</span><br><span class="line">            (bytes4(_payload[<span class="number">3</span>]) &gt;&gt; <span class="number">24</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sig == bytes4(keccak256(<span class="string">"setOwner(address)"</span>))) &#123;</span><br><span class="line">            address owner = abi.decode(_payload[<span class="number">4</span>:], (address));</span><br><span class="line">            <span class="built_in">require</span>(owner != address(<span class="number">0</span>), <span class="string">"Address of owner cannot be zero."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        (bool status,) = client.delegatecall(_payload);</span><br><span class="line">        <span class="built_in">require</span>(status, <span class="string">"Forwarded call failed."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: GPL-3.0</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.4</span><span class="number">.0</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract MappingExample &#123;</span><br><span class="line">    mapping(<span class="function"><span class="params">address</span> =&gt;</span> uint) public balances;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params">uint newBalance</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        balances[msg.sender] = newBalance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract MappingLBC &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">        MappingExample m = <span class="keyword">new</span> MappingExample();</span><br><span class="line">        m.update(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">return</span> m.balances(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: GPL-3.0</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.4</span><span class="number">.22</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract MappingExample &#123;</span><br><span class="line"></span><br><span class="line">    mapping (<span class="function"><span class="params">address</span> =&gt;</span> uint256) private _balances;</span><br><span class="line">    mapping (<span class="function"><span class="params">address</span> =&gt;</span> mapping (<span class="function"><span class="params">address</span> =&gt;</span> uint256)) private _allowances;</span><br><span class="line"></span><br><span class="line">    event Transfer(address indexed <span class="keyword">from</span>, address indexed to, uint256 value);</span><br><span class="line">    event Approval(address indexed owner, address indexed spender, uint256 value);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">allowance</span>(<span class="params">address owner, address spender</span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">uint256</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _allowances[owner][spender];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">transferFrom</span>(<span class="params">address sender, address recipient, uint256 amount</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">bool</span>) </span>&#123;</span><br><span class="line">        _transfer(sender, recipient, amount);</span><br><span class="line">        approve(sender, msg.sender, amount);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">approve</span>(<span class="params">address owner, address spender, uint256 amount</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">bool</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(owner != address(<span class="number">0</span>), <span class="string">"ERC20: approve from the zero address"</span>);</span><br><span class="line">        <span class="built_in">require</span>(spender != address(<span class="number">0</span>), <span class="string">"ERC20: approve to the zero address"</span>);</span><br><span class="line"></span><br><span class="line">        _allowances[owner][spender] = amount;</span><br><span class="line">        emit Approval(owner, spender, amount);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">_transfer</span>(<span class="params">address sender, address recipient, uint256 amount</span>) <span class="title">internal</span> </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(sender != address(<span class="number">0</span>), <span class="string">"ERC20: transfer from the zero address"</span>);</span><br><span class="line">        <span class="built_in">require</span>(recipient != address(<span class="number">0</span>), <span class="string">"ERC20: transfer to the zero address"</span>);</span><br><span class="line"></span><br><span class="line">        _balances[sender] -= amount;</span><br><span class="line">        _balances[recipient] += amount;</span><br><span class="line">        emit Transfer(sender, recipient, amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: GPL-3.0</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.6</span><span class="number">.0</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">struct IndexValue &#123; uint keyIndex; uint value; &#125;</span><br><span class="line">struct KeyFlag &#123; uint key; bool deleted; &#125;</span><br><span class="line"></span><br><span class="line">struct itmap &#123;</span><br><span class="line">    mapping(<span class="function"><span class="params">uint</span> =&gt;</span> IndexValue) data;</span><br><span class="line">    KeyFlag[] keys;</span><br><span class="line">    uint size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">library IterableMapping &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params">itmap storage self, uint key, uint value</span>) <span class="title">internal</span> <span class="title">returns</span> (<span class="params">bool replaced</span>) </span>&#123;</span><br><span class="line">        uint keyIndex = self.data[key].keyIndex;</span><br><span class="line">        self.data[key].value = value;</span><br><span class="line">        <span class="keyword">if</span> (keyIndex &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            keyIndex = self.keys.length;</span><br><span class="line"></span><br><span class="line">            self.keys.push();</span><br><span class="line">            self.data[key].keyIndex = keyIndex + <span class="number">1</span>;</span><br><span class="line">            self.keys[keyIndex].key = key;</span><br><span class="line">            self.size++;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params">itmap storage self, uint key</span>) <span class="title">internal</span> <span class="title">returns</span> (<span class="params">bool success</span>) </span>&#123;</span><br><span class="line">        uint keyIndex = self.data[key].keyIndex;</span><br><span class="line">        <span class="keyword">if</span> (keyIndex == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">delete</span> self.data[key];</span><br><span class="line">        self.keys[keyIndex - <span class="number">1</span>].deleted = <span class="literal">true</span>;</span><br><span class="line">        self.size --;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">contains</span>(<span class="params">itmap storage self, uint key</span>) <span class="title">internal</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">bool</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> self.data[key].keyIndex &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">iterate_start</span>(<span class="params">itmap storage self</span>) <span class="title">internal</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">uint keyIndex</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> iterate_next(self, uint(<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">iterate_valid</span>(<span class="params">itmap storage self, uint keyIndex</span>) <span class="title">internal</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">bool</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> keyIndex &lt; self.keys.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">iterate_next</span>(<span class="params">itmap storage self, uint keyIndex</span>) <span class="title">internal</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">uint r_keyIndex</span>) </span>&#123;</span><br><span class="line">        keyIndex++;</span><br><span class="line">        <span class="keyword">while</span> (keyIndex &lt; self.keys.length &amp;&amp; self.keys[keyIndex].deleted)</span><br><span class="line">            keyIndex++;</span><br><span class="line">        <span class="keyword">return</span> keyIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">iterate_get</span>(<span class="params">itmap storage self, uint keyIndex</span>) <span class="title">internal</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">uint key, uint value</span>) </span>&#123;</span><br><span class="line">        key = self.keys[keyIndex].key;</span><br><span class="line">        value = self.data[key].value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如何使用</span></span><br><span class="line">contract User &#123;</span><br><span class="line">    <span class="comment">// Just a struct holding our data.</span></span><br><span class="line">    itmap data;</span><br><span class="line">    <span class="comment">// Apply library functions to the data type.</span></span><br><span class="line">    using IterableMapping <span class="keyword">for</span> itmap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Insert something</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params">uint k, uint v</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">uint size</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// This calls IterableMapping.insert(data, k, v)</span></span><br><span class="line">        data.insert(k, v);</span><br><span class="line">        <span class="comment">// We can still access members of the struct,</span></span><br><span class="line">        <span class="comment">// but we should take care not to mess with them.</span></span><br><span class="line">        <span class="keyword">return</span> data.size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Computes the sum of all stored data.</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">uint s</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (</span><br><span class="line">            uint i = data.iterate_start();</span><br><span class="line">            data.iterate_valid(i);</span><br><span class="line">            i = data.iterate_next(i)</span><br><span class="line">        ) &#123;</span><br><span class="line">            (, uint value) = data.iterate_get(i);</span><br><span class="line">            s += value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>映射本身是无法遍历的，即无法枚举所有的键。不过，可以在它们之上实现一个数据结构来进行迭代。 例如，以下代码实现了 <code>IterableMapping</code> 库，然后　<code>User</code> 合约可以添加数据，　<code>sum</code>　函数迭代求和所有值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: GPL-3.0</span></span><br><span class="line">pragma solidity &gt;=<span class="number">0.4</span><span class="number">.0</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract DeleteLBC &#123;</span><br><span class="line">    uint data;</span><br><span class="line">    uint[] dataArray;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        uint x = data;</span><br><span class="line">        <span class="keyword">delete</span> x; <span class="comment">// 将 x 设为 0，并不影响数据</span></span><br><span class="line">        <span class="keyword">delete</span> data; <span class="comment">// 将 data 设为 0，并不影响 x，因为它仍然有个副本</span></span><br><span class="line">        uint[] storage y = dataArray;</span><br><span class="line">        <span class="keyword">delete</span> dataArray;</span><br><span class="line">        <span class="comment">// 将 dataArray.length 设为 0，但由于 uint[] 是一个复杂的对象，y 也将受到影响，</span></span><br><span class="line">        <span class="comment">// 因为它是一个存储位置是 storage 的对象的别名。</span></span><br><span class="line">        <span class="comment">// 另一方面："delete y" 是非法的，引用了 storage 对象的局部变量只能由已有的 storage 对象赋值。</span></span><br><span class="line">        assert(y.length == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">uint8 y;</span><br><span class="line">uint16 z;</span><br><span class="line">uint32 x = y + z;</span><br><span class="line">int8 y = <span class="number">-3</span>;</span><br><span class="line">uint x = uint(y);</span><br><span class="line">uint32 a = <span class="number">0x12345678</span>;</span><br><span class="line">uint16 b = uint16(a); <span class="comment">// 此时 b 的值是 0x5678</span></span><br><span class="line">uint16 a = <span class="number">0x1234</span>;</span><br><span class="line">uint32 b = uint32(a); <span class="comment">// b 为 0x00001234 now</span></span><br><span class="line">assert(a == b);</span><br></pre></td></tr></table></figure><h4 id="单位和全局变量"><a href="#单位和全局变量" class="headerlink" title="单位和全局变量"></a>单位和全局变量</h4><p>以太币Ether 单位之间的换算就是在数字后边加上 <code>wei</code>、<code>gwei</code> 或 <code>ether</code> 来实现的，如果后面没有单位，缺省为 wei。例如 <code>2 ether == 2000 finney</code> 的逻辑判断值为 <code>true</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">assert(<span class="number">1</span> wei == <span class="number">1</span>);</span><br><span class="line">assert(<span class="number">1</span> gwei == <span class="number">1e9</span>);</span><br><span class="line">assert(<span class="number">1</span> ether == <span class="number">1e18</span>);</span><br></pre></td></tr></table></figure><p>这些后缀不能直接用在变量后边。如果想用时间单位（例如 days）来将输入变量换算为时间，你可以用如下方式来完成：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> == <span class="number">1</span> seconds</span><br><span class="line"><span class="number">1</span> minutes == <span class="number">60</span> seconds</span><br><span class="line"><span class="number">1</span> hours == <span class="number">60</span> minutes</span><br><span class="line"><span class="number">1</span> days == <span class="number">24</span> hours</span><br><span class="line"><span class="number">1</span> weeks == <span class="number">7</span> days</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">uint start, uint daysAfter</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (block.timestamp &gt;= start + daysAfter * <span class="number">1</span> days) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这些编码函数可以用来构造函数调用数据，而不用实际进行调用。此外，keccak256(abi.encodePacked(a, b)) 是一种计算结构化数据的哈希值（尽管我们也应该关注到：使用不同的函数参数类型也有可能会引起“哈希冲突” ）的方式，不推荐使用的 keccak256(a, b) 。</span><br></pre></td></tr></table></figure><h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>可以参阅专门的章节 <a href="https://learnblockchain.cn/docs/solidity/control-structures.html#assert-and-require" target="_blank" rel="noopener">assert and require</a> 参阅有关错误处理以及何时使用哪个函数的更多详细信息。</p><ul><li><p><code>assert(bool condition)</code></p><p>如果不满足条件，则会导致无效的操作码，则撤销状态更改 - 用于检查内部错误。</p></li><li><p><code>require(bool condition)</code></p><p>如果条件不满足则撤销状态更改 - 用于检查由输入或者外部组件引起的错误。</p></li><li><p><code>require(bool condition, string memory message)</code></p><p>如果条件不满足则撤销状态更改 - 用于检查由输入或者外部组件引起的错误，可以同时提供一个错误消息。</p></li><li><p><code>revert()</code></p><p>终止运行并撤销状态更改。</p></li><li><p><code>revert(string memory reason)</code></p><p>终止运行并撤销状态更改，可以同时提供一个解释性的字符串。</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=<span class="number">0.5</span><span class="number">.0</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    uint index;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">uint, bool, uint</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">7</span>, <span class="literal">true</span>, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="comment">//基于返回的元组来声明变量并赋值</span></span><br><span class="line">        (uint x, bool b, uint y) = f();</span><br><span class="line">        <span class="comment">//交换两个值的通用窍门——但不适用于非值类型的存储 (storage) 变量。</span></span><br><span class="line">        (x, y) = (y, x);</span><br><span class="line">        <span class="comment">//元组的末尾元素可以省略（这也适用于变量声明）。</span></span><br><span class="line">        (index,,) = f(); <span class="comment">// 设置 index 为 7</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=<span class="number">0.5</span><span class="number">.0</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract Sharer &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sendHalf</span>(<span class="params">address addr</span>) <span class="title">public</span> <span class="title">payable</span> <span class="title">returns</span> (<span class="params">uint balance</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(msg.value % <span class="number">2</span> == <span class="number">0</span>, <span class="string">"Even value required."</span>);</span><br><span class="line">        uint balanceBeforeTransfer = <span class="keyword">this</span>.balance;</span><br><span class="line">        addr.transfer(msg.value / <span class="number">2</span>);</span><br><span class="line">                    <span class="comment">//由于转移函数在失败时抛出异常并且不能在这里回调，因此我们应该没有办法仍然有一半的钱。</span></span><br><span class="line">        assert(<span class="keyword">this</span>.balance == balanceBeforeTransfer - msg.value / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在内部， Solidity 对一个 <code>require</code> 式的异常执行回退操作（指令 <code>0xfd</code> ）并执行一个无效操作（指令 <code>0xfe</code> ）来引发 <code>assert</code> 式异常。 在这两种情况下，都会导致 EVM 回退对状态所做的所有更改。回退的原因是不能继续安全地执行，因为没有实现预期的效果。</p><p>在这两种情况下，调用者都可以使用 <code>try</code>/<code>catch</code> 来应对此类失败（在<code>assert</code>类型的异常中,仅在剩余足够gas的情况下才行 ），但是调用者中的更改将始终被还原。</p><p>请注意， <code>assert</code> 式异常消耗了所有可用的调用 gas ，<strong>而从 Metropolis 版本起 <code>require</code> 式的异常不会消耗任何 gas。 </strong>这里还是尽量使用require.</p><h4 id="合约"><a href="#合约" class="headerlink" title="合约"></a>合约</h4><h4 id="Solidity-合约类似于面向对象语言中的类。合约中有用于数据持久化的状态变量，和可以修改状态变量的函数。-调用另一个合约实例的函数时，会执行一个-EVM-函数调用，这个操作会切换执行时的上下文，这样，前一个合约的状态变量就不能访问了。"><a href="#Solidity-合约类似于面向对象语言中的类。合约中有用于数据持久化的状态变量，和可以修改状态变量的函数。-调用另一个合约实例的函数时，会执行一个-EVM-函数调用，这个操作会切换执行时的上下文，这样，前一个合约的状态变量就不能访问了。" class="headerlink" title="Solidity 合约类似于面向对象语言中的类。合约中有用于数据持久化的状态变量，和可以修改状态变量的函数。 调用另一个合约实例的函数时，会执行一个 EVM 函数调用，这个操作会切换执行时的上下文，这样，前一个合约的状态变量就不能访问了。"></a>Solidity 合约类似于面向对象语言中的类。合约中有用于数据持久化的状态变量，和可以修改状态变量的函数。 调用另一个合约实例的函数时，会执行一个 EVM 函数调用，这个操作会切换执行时的上下文，这样，前一个合约的状态变量就不能访问了。</h4><p>可以通过以太坊交易“从外部”或从 Solidity 合约内部创建合约。</p><p>一些集成开发环境，例如 <a href="https://remix.ethereum.org/" target="_blank" rel="noopener">Remix</a>, 通过使用一些UI用户界面使创建合约的过程更加顺畅。 在以太坊上通过编程创建合约最好使用 JavaScript API <a href="https://github.com/ethereum/web3.js" target="_blank" rel="noopener">web3.js</a>。 现在，我们已经有了一个叫做 <a href="https://web3js.readthedocs.io/en/1.0/web3-eth-contract.html#new-contract" target="_blank" rel="noopener">web3.eth.Contract</a> 的方法能够更容易的创建合约。</p><p>创建合约时， 合约的 <a href="https://learnblockchain.cn/docs/solidity/contracts.html#constructor" target="_blank" rel="noopener">构造函数</a> (一个用关键字 <code>constructor</code> 声明的函数)会执行一次。 构造函数是可选的。只允许有一个构造函数，这意味着不支持重载。</p><p>构造函数执行完毕后，合约的最终代码将部署到区块链上。此代码包括所有公共和外部函数以及所有可以通过函数调用访问的函数。 部署的代码没有 包括构造函数代码或构造函数调用的内部函数。</p><p>在内部，构造函数参数在合约代码之后通过 <a href="https://learnblockchain.cn/docs/solidity/abi-spec.html#abi" target="_blank" rel="noopener">ABI 编码</a> 传递，但是如果你使用 <code>web3.js</code> 则不必关心这个问题。</p><p>如果一个合约想要创建另一个合约，那么创建者必须知晓被创建合约的源代码(和二进制代码)。 这意味着不可能循环创建依赖项。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=<span class="number">0.4</span><span class="number">.22</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract OwnedToken &#123;</span><br><span class="line">    <span class="comment">// TokenCreator 是如下定义的合约类型.</span></span><br><span class="line">    <span class="comment">// 不创建新合约的话，也可以引用它。</span></span><br><span class="line">    TokenCreator creator;</span><br><span class="line">    address owner;</span><br><span class="line">    bytes32 name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这是注册 creator 和设置名称的构造函数。</span></span><br><span class="line">    <span class="keyword">constructor</span>(bytes32 _name) &#123;</span><br><span class="line">        <span class="comment">// 状态变量通过其名称访问，而不是通过例如 this.owner 的方式访问。</span></span><br><span class="line">        <span class="comment">// 这也适用于函数，特别是在构造函数中，你只能像这样（“内部地”）调用它们，</span></span><br><span class="line">        <span class="comment">// 因为合约本身还不存在。</span></span><br><span class="line">        owner = msg.sender;</span><br><span class="line">        <span class="comment">// 从 `address` 到 `TokenCreator` ，是做显式的类型转换</span></span><br><span class="line">        <span class="comment">// 并且假定调用合约的类型是 TokenCreator，没有真正的方法来检查这一点。</span></span><br><span class="line">        creator = TokenCreator(msg.sender);</span><br><span class="line">        name = _name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">changeName</span>(<span class="params">bytes32 newName</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 只有 creator （即创建当前合约的合约）能够更改名称 —— 因为合约是隐式转换为地址的，</span></span><br><span class="line">        <span class="comment">// 所以这里的比较是可行的。</span></span><br><span class="line">        <span class="keyword">if</span> (msg.sender == address(creator))</span><br><span class="line">            name = newName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">transfer</span>(<span class="params">address newOwner</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 只有当前所有者才能发送 token。</span></span><br><span class="line">        <span class="keyword">if</span> (msg.sender != owner) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 我们也想询问 creator 是否可以发送。</span></span><br><span class="line">        <span class="comment">// 请注意，这里调用了一个下面定义的合约中的函数。</span></span><br><span class="line">        <span class="comment">// 如果调用失败（比如，由于 gas 不足），会立即停止执行。</span></span><br><span class="line">        <span class="keyword">if</span> (creator.isTokenTransferOK(owner, newOwner))</span><br><span class="line">            owner = newOwner;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract TokenCreator &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">createToken</span>(<span class="params">bytes32 name</span>)</span></span><br><span class="line"><span class="function">       <span class="title">public</span></span></span><br><span class="line"><span class="function">       <span class="title">returns</span> (<span class="params">OwnedToken tokenAddress</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个新的 Token 合约并且返回它的地址。</span></span><br><span class="line">        <span class="comment">// 从 JavaScript 方面来说，返回类型是简单的 `address` 类型，因为</span></span><br><span class="line">        <span class="comment">// 这是在 ABI 中可用的最接近的类型。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OwnedToken(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">changeName</span>(<span class="params">OwnedToken tokenAddress, bytes32 name</span>)  <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 同样，`tokenAddress` 的外部类型也是 `address` 。</span></span><br><span class="line">        tokenAddress.changeName(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">isTokenTransferOK</span>(<span class="params">address currentOwner, address newOwner</span>)</span></span><br><span class="line"><span class="function">        <span class="title">public</span></span></span><br><span class="line"><span class="function">        <span class="title">view</span></span></span><br><span class="line"><span class="function">        <span class="title">returns</span> (<span class="params">bool ok</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 检查一些任意的情况。</span></span><br><span class="line">        address tokenAddress = msg.sender;</span><br><span class="line">        <span class="keyword">return</span> (keccak256(newOwner) &amp; <span class="number">0xff</span>) == (bytes20(tokenAddress) &amp; <span class="number">0xff</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 Solidity 有两种函数调用（内部调用不会产生实际的 EVM 调用或称为“消息调用”，而外部调用则会产生一个 EVM 调用）， 函数和状态变量有四种可见性类型。 函数可以指定为 <code>external</code> ，<code>public</code> ，<code>internal</code> 或者 <code>private</code>。 对于状态变量，不能设置为 <code>external</code> ，默认是 <code>internal</code> 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">external</span><br></pre></td></tr></table></figure><p>外部函数作为合约接口的一部分，意味着我们可以从其他合约和交易中调用。 一个外部函数 <code>f</code> 不能从内部调用（即 <code>f</code> 不起作用，但 <code>this.f()</code> 可以）。 当收到大量数据的时候，外部函数有时候会更有效率，因为数据不会从calldata复制到内存.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public</span><br></pre></td></tr></table></figure><p>public 函数是合约接口的一部分，可以在内部或通过消息调用。对于 public 状态变量， 会自动生成一个 getter 函数（见下面）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">internal</span><br></pre></td></tr></table></figure><p>这些函数和状态变量只能是内部访问（即从当前合约内部或从它派生的合约访问），不使用 <code>this</code> 调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private</span><br></pre></td></tr></table></figure><p>private 函数和状态变量仅在当前定义它们的合约中使用，并且不能被派生合约使用。</p><p><strong>合约中的所有内容对外部观察者都是可见的。设置一些 <code>private</code> 类型只能阻止其他合约访问和修改这些信息， 但是对于区块链外的整个世界它仍然是可见的。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: GPL-3.0</span></span><br><span class="line">pragma solidity &gt;<span class="number">0.7</span><span class="number">.0</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract owned &#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123; owner = msg.sender; &#125;</span><br><span class="line"></span><br><span class="line">    address owner;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个合约只定义一个修改器，但并未使用： 它将会在派生合约中用到。</span></span><br><span class="line">    <span class="comment">// 修改器所修饰的函数体会被插入到特殊符号 _; 的位置。</span></span><br><span class="line">    <span class="comment">// 这意味着如果是 owner 调用这个函数，则函数会被执行，否则会抛出异常。</span></span><br><span class="line">    modifier onlyOwner &#123;</span><br><span class="line">        <span class="built_in">require</span>(</span><br><span class="line">            msg.sender == owner,</span><br><span class="line">            <span class="string">"Only owner can call this function."</span></span><br><span class="line">        );</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract destructible is owned &#123;</span><br><span class="line">    <span class="comment">// 这个合约从 `owned` 继承了 `onlyOwner` 修饰符，并将其应用于 `destroy` 函数，</span></span><br><span class="line">    <span class="comment">// 只有在合约里保存的 owner 调用 `destroy` 函数，才会生效。</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">destroy</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">onlyOwner</span> </span>&#123;</span><br><span class="line">        selfdestruct(owner);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract priced &#123;</span><br><span class="line">    <span class="comment">// 修改器可以接收参数：</span></span><br><span class="line">    modifier costs(uint price) &#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.value &gt;= price) &#123;</span><br><span class="line">            _;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Register is priced, destructible &#123;</span><br><span class="line">    mapping (<span class="function"><span class="params">address</span> =&gt;</span> bool) registeredAddresses;</span><br><span class="line">    uint price;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(uint initialPrice) &#123; price = initialPrice; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在这里也使用关键字 `payable` 非常重要，否则函数会自动拒绝所有发送给它的以太币。</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">register</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">payable</span> <span class="title">costs</span>(<span class="params">price</span>) </span>&#123;</span><br><span class="line">        registeredAddresses[msg.sender] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">changePrice</span>(<span class="params">uint _price</span>) <span class="title">public</span> <span class="title">onlyOwner</span> </span>&#123;</span><br><span class="line">        price = _price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Mutex &#123;</span><br><span class="line">    bool locked;</span><br><span class="line">    modifier noReentrancy() &#123;</span><br><span class="line">        <span class="built_in">require</span>(</span><br><span class="line">            !locked,</span><br><span class="line">            <span class="string">"Reentrant call."</span></span><br><span class="line">        );</span><br><span class="line">        locked = <span class="literal">true</span>;</span><br><span class="line">        _;</span><br><span class="line">        locked = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个函数受互斥量保护，这意味着 `msg.sender.call` 中的重入调用不能再次调用  `f`。</span></span><br><span class="line">    <span class="comment">// `return 7` 语句指定返回值为 7，但修改器中的语句 `locked = false` 仍会执行。</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">noReentrancy</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">        (bool success,) = msg.sender.call(<span class="string">""</span>);</span><br><span class="line">        <span class="built_in">require</span>(success);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">7</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: GPL-3.0</span></span><br><span class="line">pragma solidity &gt;<span class="number">0.6</span><span class="number">.99</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    uint constant X = <span class="number">32</span>**<span class="number">22</span> + <span class="number">8</span>;</span><br><span class="line">    string constant TEXT = <span class="string">"abc"</span>;</span><br><span class="line">    bytes32 constant MY_HASH = keccak256(<span class="string">"abc"</span>);</span><br><span class="line">    uint immutable decimals;</span><br><span class="line">    uint immutable maxBalance;</span><br><span class="line">    address immutable owner = msg.sender;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(uint _decimals, address _reference) &#123;</span><br><span class="line">        decimals = _decimals;</span><br><span class="line">        <span class="comment">// Assignments to immutables can even access the environment.</span></span><br><span class="line">        maxBalance = _reference.balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">isBalanceTooHigh</span>(<span class="params">address _other</span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">bool</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _other.balance &gt; maxBalance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果状态变量声明为 <code>constant</code> (常量)。在这种情况下，只能使用那些在编译时有确定值的表达式来给它们赋值。 任何通过访问 storage，区块链数据（例如 <code>block.timestamp</code>, <code>address(this).balance</code> 或者 <code>block.number</code>）或执行数据（ <code>msg.value</code> 或 <code>gasleft()</code> ） 或对外部合约的调用来给它们赋值都是不允许的。</p><p>允许可能对内存分配产生副作用（side-effect）的表达式，但那些可能对其他内存对象产生副作用的表达式则不允许。</p><p>内建（built-in）函数 <code>keccak256</code> ， <code>sha256</code> ， <code>ripemd160</code> ， <code>ecrecover</code> ， <code>addmod</code> 和 <code>mulmod</code> 是允许的（即使他们确实会调用外部合约， <code>keccak256</code> 除外）。</p><p>允许内存分配器的副作用的原因是它可以构造复杂的对象，例如： 查找表（lookup-table）。 此功能尚不完全可用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: GPL-3.0</span></span><br><span class="line">pragma solidity &gt;<span class="number">0.8</span><span class="number">.0</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">uint[] memory _arr</span>) <span class="title">pure</span> <span class="title">returns</span> (<span class="params">uint s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; _arr.length; i++)</span><br><span class="line">        s += _arr[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract ArrayExample &#123;</span><br><span class="line">    bool found;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">uint[] memory _arr</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="comment">// This calls the free function internally.</span></span><br><span class="line">        <span class="comment">// The compiler will add its code to the contract.</span></span><br><span class="line">        uint s = sum(_arr);</span><br><span class="line">        <span class="built_in">require</span>(s &gt;= <span class="number">10</span>);</span><br><span class="line">        found = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=<span class="number">0.4</span><span class="number">.16</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract Simple &#123;</span><br><span class="line">    uint sum;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">taker</span>(<span class="params">uint _a, uint _b</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        sum = _a + _b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pragma solidity &gt;=<span class="number">0.4</span><span class="number">.16</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract Simple &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">arithmetic</span>(<span class="params">uint _a, uint _b</span>)</span></span><br><span class="line"><span class="function">        <span class="title">public</span></span></span><br><span class="line"><span class="function">        <span class="title">pure</span></span></span><br><span class="line"><span class="function">        <span class="title">returns</span> (<span class="params">uint o_sum, uint o_product</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        o_sum = _a + _b;</span><br><span class="line">        o_product = _a * _b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity  &gt;=<span class="number">0.5</span><span class="number">.0</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">uint a, uint b</span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a * (b + <span class="number">42</span>) + block.timestamp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Getter 方法自动被标记为 <code>view</code>。<code>constant</code> 之前是 <code>view</code> 的别名，不过在0.5.0之后移除了。函数可以声明为 <code>pure</code> ，在这种情况下，承诺不读取也不修改状态。</p><p>一个合约最多有一个 <code>receive</code> 函数, 声明函数为： <code>receive() external payable { ... }</code></p><p>不需要 <code>function</code> 关键字，也没有参数和返回值并且必须是　<code>external</code>　可见性和　<code>payable</code> 修饰． 在对合约没有任何附加数据调用（通常是对合约转账）是会执行 <code>receive</code> 函数．　例如　通过 <code>.send()</code> or <code>.transfer()</code> 如果 <code>receive</code> 函数不存在，　但是有payable　的 <a href="https://learnblockchain.cn/docs/solidity/contracts.html#fallback-function" target="_blank" rel="noopener">fallback 回退函数</a> 那么在进行纯以太转账时，fallback 函数会调用．</p><p>如果两个函数都没有，这个合约就没法通过常规的转账交易接收以太（会抛出异常）．</p><p>更糟的是，fallback函数可能只有 2300 gas 可以使用（如，当使用 <code>send</code> 或 <code>transfer</code> 时）， 除了基础的日志输出之外，进行其他操作的余地很小。下面的操作消耗会操作 2300 gas :</p><ul><li><p>写入存储</p></li><li><p>创建合约</p></li><li><p>调用消耗大量 gas 的外部函数</p></li><li><p>发送以太币</p></li></ul><p>一个没有定义 fallback 函数或　 receive 函数的合约，直接接收以太币（没有函数调用，即使用 <code>send</code> 或 <code>transfer</code>）会抛出一个异常， 并返还以太币（在 Solidity v0.4.0 之前行为会有所不同）。 所以如果你想让你的合约接收以太币，必须实现receive函数（使用 payable　fallback 函数不再推荐，因为它会让借口混淆）。 这个之前调试老版本的合约中出现过异常的情况。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=<span class="number">0.6</span><span class="number">.2</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    <span class="comment">// 发送到这个合约的所有消息都会调用此函数（因为该合约没有其它函数）。</span></span><br><span class="line">    <span class="comment">// 向这个合约发送以太币会导致异常，因为 fallback 函数没有 `payable` 修饰符</span></span><br><span class="line">    fallback() external &#123; x = <span class="number">1</span>; &#125;</span><br><span class="line">    uint x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个合约会保留所有发送给它的以太币，没有办法返还。</span></span><br><span class="line">contract TestPayable &#123;</span><br><span class="line">    <span class="comment">// 除了纯转账外，所有的调用都会调用这个函数．</span></span><br><span class="line">    <span class="comment">// (因为除了 receive 函数外，没有其他的函数).</span></span><br><span class="line">    <span class="comment">// 任何对合约非空calldata 调用会执行回退函数(即使是调用函数附加以太).</span></span><br><span class="line">    fallback() external payable &#123; x = <span class="number">1</span>; y = msg.value; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 纯转账调用这个函数，例如对每个空empty calldata的调用</span></span><br><span class="line">    receive() external payable &#123; x = <span class="number">2</span>; y = msg.value; &#125;</span><br><span class="line">    uint x;</span><br><span class="line">    uint y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Caller &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">callTest</span>(<span class="params">Test test</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">bool</span>) </span>&#123;</span><br><span class="line">        (bool success,) = address(test).call(abi.encodeWithSignature(<span class="string">"nonExistingFunction()"</span>));</span><br><span class="line">        <span class="built_in">require</span>(success);</span><br><span class="line">        <span class="comment">//  test.x 结果变成 == 1。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// address(test) 不允许直接调用 ``send`` ,  因为 ``test`` 没有 payable 回退函数</span></span><br><span class="line">        <span class="comment">//  转化为 ``address payable`` 类型 , 然后才可以调用 ``send``</span></span><br><span class="line">        address payable testPayable = payable(address(test));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以下将不会编译，但如果有人向该合约发送以太币，交易将失败并拒绝以太币。</span></span><br><span class="line">        <span class="comment">// test.send(2 ether）;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">callTestPayable</span>(<span class="params">TestPayable test</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">bool</span>) </span>&#123;</span><br><span class="line">        (bool success,) = address(test).call(abi.encodeWithSignature(<span class="string">"nonExistingFunction()"</span>));</span><br><span class="line">        <span class="built_in">require</span>(success);</span><br><span class="line">        <span class="comment">// 结果 test.x 为 1  test.y 为 0.</span></span><br><span class="line">        (success,) = address(test).call&#123;<span class="attr">value</span>: <span class="number">1</span>&#125;(abi.encodeWithSignature(<span class="string">"nonExistingFunction()"</span>));</span><br><span class="line">        <span class="built_in">require</span>(success);</span><br><span class="line">        <span class="comment">// 结果test.x 为1 and test.y 为 1.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送以太币, TestPayable 的 receive　函数被调用．</span></span><br><span class="line">        <span class="built_in">require</span>(address(test).send(<span class="number">2</span> ether));</span><br><span class="line">        <span class="comment">// 结果 in test.x 为 2 and test.y 为 2 ether.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">    fromBlock: <span class="number">0</span>,</span><br><span class="line">    address: web3.eth.defaultAccount,</span><br><span class="line">    topics: [<span class="string">"0x0000000000000000000000000000000000000000000000000000000000000000"</span>, <span class="literal">null</span>, <span class="literal">null</span>]</span><br><span class="line">&#125;;</span><br><span class="line">web3.eth.subscribe(<span class="string">'logs'</span>, options, <span class="function"><span class="keyword">function</span> (<span class="params">error, result</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!error)</span><br><span class="line">        <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;)</span><br><span class="line">    .on(<span class="string">"data"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">log</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(log);</span><br><span class="line">    &#125;)</span><br><span class="line">    .on(<span class="string">"changed"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">log</span>) </span>&#123;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>关于web3 subscribe的描述</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=<span class="number">0.4</span><span class="number">.10</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">payable</span> </span>&#123;</span><br><span class="line">        bytes32 _id = <span class="number">0x420042</span>;</span><br><span class="line">        log3(</span><br><span class="line">            bytes32(msg.value),</span><br><span class="line">            bytes32(<span class="number">0x50cb9fe53daa9737b786ab3646f04d0150dc50ef4e75f59509d83667ad5adb20</span>),</span><br><span class="line">            bytes32(msg.sender),</span><br><span class="line">            _id</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>日志的底层接口</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// SPDX-License-Identifier: GPL-3.0</span></span><br><span class="line">   pragma solidity &gt;<span class="number">0.6</span><span class="number">.99</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">   contract Owned &#123;</span><br><span class="line">       <span class="keyword">constructor</span>() public &#123; owner = msg.sender; &#125;</span><br><span class="line">       address payable owner;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 使用 is 从另一个合约派生。派生合约可以访问所有非私有成员，包括内部（internal）函数和状态变量，</span></span><br><span class="line">   <span class="comment">// 但无法通过 this 来外部访问。</span></span><br><span class="line">   contract Destructible is Owned &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关键字`virtual`表示该函数可以在派生类中“overriding”。</span></span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">function</span> <span class="title">destroy</span>(<span class="params"></span>) <span class="title">virtual</span> <span class="title">public</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (msg.sender == owner) selfdestruct(owner);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 这些抽象合约仅用于给编译器提供接口。</span></span><br><span class="line">   <span class="comment">// 注意函数没有函数体。</span></span><br><span class="line">   <span class="comment">// 如果一个合约没有实现所有函数，则只能用作接口。</span></span><br><span class="line">   abstract contract Config &#123;</span><br><span class="line">       <span class="function"><span class="keyword">function</span> <span class="title">lookup</span>(<span class="params">uint id</span>) <span class="title">public</span> <span class="title">virtual</span> <span class="title">returns</span> (<span class="params">address adr</span>);</span></span><br><span class="line"><span class="function">   &#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">   <span class="title">abstract</span> <span class="title">contract</span> <span class="title">NameReg</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">function</span> <span class="title">register</span>(<span class="params">bytes32 name</span>) <span class="title">public</span> <span class="title">virtual</span>;</span></span><br><span class="line"><span class="function">       <span class="title">function</span> <span class="title">unregister</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">virtual</span>;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">   // 可以多重继承。请注意，<span class="title">owned</span> 也是 <span class="title">Destructible</span> 的基类，</span></span><br><span class="line"><span class="function">   // 但只有一个 <span class="title">owned</span> 实例（就像 <span class="title">C</span>++ 中的虚拟继承）。</span></span><br><span class="line"><span class="function">   <span class="title">contract</span> <span class="title">Named</span> <span class="title">is</span> <span class="title">Owned</span>, <span class="title">Destructible</span> </span>&#123;</span><br><span class="line">       <span class="keyword">constructor</span>(bytes32 name) &#123;</span><br><span class="line">           Config config = Config(<span class="number">0xD5f9D8D94886E70b06E474c3fB14Fd43E2f23970</span>);</span><br><span class="line">           NameReg(config.lookup(<span class="number">1</span>)).register(name);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 函数可以被另一个具有相同名称和相同数量/类型输入的函数重载。</span></span><br><span class="line">       <span class="comment">// 如果重载函数有不同类型的输出参数，会导致错误。</span></span><br><span class="line">       <span class="comment">// 本地和基于消息的函数调用都会考虑这些重载。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果要覆盖函数，则需要使用 `override` 关键字。 如果您想再次覆盖此函数，则需要再次指定`virtual`关键字。</span></span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">function</span> <span class="title">destroy</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">virtual</span> <span class="title">override</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (msg.sender == owner) &#123;</span><br><span class="line">               Config config = Config(<span class="number">0xD5f9D8D94886E70b06E474c3fB14Fd43E2f23970</span>);</span><br><span class="line">               NameReg(config.lookup(<span class="number">1</span>)).unregister();</span><br><span class="line">               <span class="comment">// 仍然可以调用特定的重载函数。</span></span><br><span class="line">               Destructible.destroy();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果构造函数接受参数，</span></span><br><span class="line">   <span class="comment">// 则需要在声明（合约的构造函数）时提供，</span></span><br><span class="line">   <span class="comment">// 或在派生合约的构造函数位置以修改器调用风格提供（见下文）。</span></span><br><span class="line">   contract PriceFeed is Owned, Destructible, Named(<span class="string">"GoldFeed"</span>) &#123;</span><br><span class="line">       <span class="function"><span class="keyword">function</span> <span class="title">updateInfo</span>(<span class="params">uint newInfo</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (msg.sender == owner) info = newInfo;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Here, we only specify `override` and not `virtual`.</span></span><br><span class="line">       <span class="comment">// This means that contracts deriving from `PriceFeed`</span></span><br><span class="line">       <span class="comment">// cannot change the behaviour of `destroy` anymore.</span></span><br><span class="line">       <span class="function"><span class="keyword">function</span> <span class="title">destroy</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">override</span>(<span class="params">Destructible, Named</span>) </span>&#123; Named.destroy(); &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span>(<span class="params">uint r</span>) </span>&#123; <span class="keyword">return</span> info; &#125;</span><br><span class="line"></span><br><span class="line">       uint info;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>父合约标记为 <code>virtual</code> 函数可以在继承合约里重写(overridden)以更改他们的行为。重写的函数需要使用关键字 <code>override</code> 修饰。</p><p>重写函数只能将覆盖函数的可见性从 <code>external</code> 更改为 <code>public</code> 。</p><p>可变性可以按照以下顺序更改为更严格的一种： <code>nonpayable</code> 可以被 <code>view</code> 和 <code>pure</code> 覆盖。 <code>view</code> 可以被 <code>pure</code> 覆盖。 <code>payable</code> 是一个例外，不能更改为任何其他可变性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: GPL-3.0</span></span><br><span class="line">pragma solidity &gt;<span class="number">0.6</span><span class="number">.99</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) <span class="title">virtual</span> <span class="title">external</span> <span class="title">view</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Middle is Base &#123;&#125;</span><br><span class="line"></span><br><span class="line">contract Inherited is Middle</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) <span class="title">override</span> <span class="title">public</span> <span class="title">pure</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pragma solidity &gt;=<span class="number">0.6</span><span class="number">.0</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract Base1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) <span class="title">virtual</span> <span class="title">public</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Base2</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) <span class="title">virtual</span> <span class="title">public</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Inherited is Base1, Base2</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 继承自两个基类合约定义的foo(), 必须显示的指定 override</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">override</span>(<span class="params">Base1, Base2</span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口类似于抽象合约，但是它们不能实现任何函数。还有进一步的限制：</p><ul><li>无法继承其他合约,不过可以继承其他接口。</li><li>所有的函数都需要是 external</li><li>无法定义构造函数。</li><li>无法定义状态变量。</li></ul><p>将来可能会解除这里的某些限制。</p><p>接口基本上基本上仅限于合约 ABI 可以表示的内容，并且 ABI 和接口之间的转换应该不会丢失任何信息。</p><p>接口由它们自己的关键字表示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=<span class="number">0.6</span><span class="number">.2</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">interface Token &#123;</span><br><span class="line">    enum TokenType &#123; Fungible, NonFungible &#125;</span><br><span class="line">    struct Coin &#123; string obverse; string reverse; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">transfer</span>(<span class="params">address recipient, uint amount</span>) <span class="title">external</span>;</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">//-------</span></span><br><span class="line"><span class="function"><span class="title">pragma</span> <span class="title">solidity</span> &gt;=0.6.2 &lt;0.8.0;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">interface</span> <span class="title">ParentA</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) <span class="title">external</span> <span class="title">returns</span> (<span class="params">uint256</span>);</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">interface</span> <span class="title">ParentB</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) <span class="title">external</span> <span class="title">returns</span> (<span class="params">uint256</span>);</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">interface</span> <span class="title">SubInterface</span> <span class="title">is</span> <span class="title">ParentA</span>, <span class="title">ParentB</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 必须重新定义 test 函数，以表示兼容父合约含义</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) <span class="title">external</span> <span class="title">override</span>(<span class="params">ParentA, ParentB</span>) <span class="title">returns</span> (<span class="params">uint256</span>);</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>就像继承其他合约一样，合约可以继承接口。接口中的函数都会隐式的标记为 <code>virtual</code> ，意味着他们会被重写。 但是不表示重写（overriding）函数可以再次重写，仅仅当重写的函数标记为 <code>virtual</code> 才可以再次重写。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=<span class="number">0.6</span><span class="number">.0</span> &lt;<span class="number">0.7</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 我们定义了一个新的结构体数据类型，用于在调用合约中保存数据。</span></span><br><span class="line">  struct Data &#123;</span><br><span class="line">    mapping(<span class="function"><span class="params">uint</span> =&gt;</span> bool) flags;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">library <span class="built_in">Set</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注意第一个参数是“storage reference”类型，因此在调用中参数传递的只是它的存储地址而不是内容。</span></span><br><span class="line">  <span class="comment">// 这是库函数的一个特性。如果该函数可以被视为对象的方法，则习惯称第一个参数为 `self` 。</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params">Data storage self, uint value</span>)</span></span><br><span class="line"><span class="function">      <span class="title">public</span></span></span><br><span class="line"><span class="function">      <span class="title">returns</span> (<span class="params">bool</span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (self.flags[value])</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 已经存在</span></span><br><span class="line">      self.flags[value] = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params">Data storage self, uint value</span>)</span></span><br><span class="line"><span class="function">      <span class="title">public</span></span></span><br><span class="line"><span class="function">      <span class="title">returns</span> (<span class="params">bool</span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!self.flags[value])</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 不存在</span></span><br><span class="line">      self.flags[value] = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">contains</span>(<span class="params">Data storage self, uint value</span>)</span></span><br><span class="line"><span class="function">      <span class="title">public</span></span></span><br><span class="line"><span class="function">      <span class="title">view</span></span></span><br><span class="line"><span class="function">      <span class="title">returns</span> (<span class="params">bool</span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> self.flags[value];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    Data knownValues;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">register</span>(<span class="params">uint value</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 不需要库的特定实例就可以调用库函数，</span></span><br><span class="line">        <span class="comment">// 因为当前合约就是“instance”。</span></span><br><span class="line">        <span class="built_in">require</span>(<span class="built_in">Set</span>.insert(knownValues, value));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果我们愿意，我们也可以在这个合约中直接访问 knownValues.flags。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个我们没咋个看到过</p><h4 id="合约元数据"><a href="#合约元数据" class="headerlink" title="合约元数据"></a>合约元数据</h4><p>Solidity编译器自动生成JSON文件，即合约的元数据，其中包含了当前合约的相关信息。 它可以用于查询编译器版本，所使用的源代码，<a href="https://learnblockchain.cn/docs/solidity/metadata.html#id5" target="_blank" rel="noopener">|ABI|</a> 和 <a href="https://learnblockchain.cn/docs/solidity/metadata.html#id7" target="_blank" rel="noopener">|natspec|</a> 文档，以便更安全地与合约进行交互并验证其源代码。</p><p>编译器会将元数据文件的 Swarm 哈希值附加到每个合约的字节码末尾（详情请参阅下文）， 以便你可以以认证的方式获取该文件，而不必求助于中心化的数据提供者。</p><p>当然，你必须将元数据文件发布到 Swarm （或其他服务），以便其他人可以访问它。 该文件可以通过使用 <code>solc --metadata</code> 来生成，并被命名为 <code>ContractName_meta.json</code> 。 它将包含源代码的在 Swarm 上的引用，因此你必须上传所有源文件和元数据文件。</p><p>元数据文件具有以下格式。 下面的例子将以人类可读的方式呈现。 正确格式化的元数据应正确使用引号，将空白减少到最小，并对所有对象的键值进行排序以得到唯一的格式。 代码注释当然也是不允许的，这里仅用于解释目的。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // 必选：元数据格式的版本</span><br><span class="line">  version: "1",</span><br><span class="line">  // 必选：源代码的编程语言，一般会选择规范的“子版本”</span><br><span class="line">  language: "Solidity",</span><br><span class="line">  // 必选：编译器的细节，内容视语言而定。</span><br><span class="line">  compiler: &#123;</span><br><span class="line">    // 对 Solidity 来说是必须的：编译器的版本</span><br><span class="line">    version: "0.4.6+commit.2dabbdf0.Emscripten.clang",</span><br><span class="line">    // 可选： 生成此输出的编译器二进制文件的哈希值</span><br><span class="line">    keccak256: "0x123..."</span><br><span class="line">  &#125;,</span><br><span class="line">  // 必选：编译的源文件／源单位，键值为文件名</span><br><span class="line">  sources:</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"myFile.sol"</span>: &#123;</span><br><span class="line">      // 必选：源文件的 keccak256 哈希值</span><br><span class="line">      "keccak256": "0x123...",</span><br><span class="line">      // 必选（除非定义了“content”，详见下文）：</span><br><span class="line">      // 已排序的源文件的URL，URL的协议可以是任意的，但建议使用 Swarm 的URL</span><br><span class="line">      "urls": [ "bzzr://56ab..." ]</span><br><span class="line">      // Optional: 在源文件中定义的 SPDX license 标识</span><br><span class="line">      "license": "MIT"</span><br><span class="line">    &#125;,</span><br><span class="line">    "mortal": &#123;</span><br><span class="line">      // 必选：源文件的 keccak256 哈希值</span><br><span class="line">      "keccak256": "0x234...",</span><br><span class="line">      // 必选（除非定义了“urls”）： 源文件的字面内容</span><br><span class="line">      "content": "contract mortal is owned &#123; function kill() &#123; if (msg.sender == owner) selfdestruct(owner); &#125; &#125;"</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  // 必选：编译器的设置</span><br><span class="line">  settings:</span><br><span class="line">  &#123;</span><br><span class="line">    // 对 Solidity 来说是必须的： 已排序的重定向列表</span><br><span class="line">    remappings: [ ":g/dir" ],</span><br><span class="line">    // 可选： 优化器的设置（ enabled 默认设为 false ）</span><br><span class="line">    optimizer: &#123;</span><br><span class="line">      enabled: true,</span><br><span class="line">      runs: 500,</span><br><span class="line">      details: &#123;</span><br><span class="line">        // peephole defaults to "true"</span><br><span class="line">        peephole: true,</span><br><span class="line">        // jumpdestRemover defaults to "true"</span><br><span class="line">        jumpdestRemover: true,</span><br><span class="line">        orderLiterals: false,</span><br><span class="line">        deduplicate: false,</span><br><span class="line">        cse: false,</span><br><span class="line">        constantOptimizer: false,</span><br><span class="line">        yul: true,</span><br><span class="line">        // Optional: Only present if "yul" is "true"</span><br><span class="line">        yulDetails: &#123;</span><br><span class="line">          stackAllocation: false,</span><br><span class="line">          optimizerSteps: "dhfoDgvulfnTUtnIf..."</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  metadata: &#123;</span><br><span class="line">      // Reflects the setting used in the input json, defaults to false</span><br><span class="line">      useLiteralContent: true,</span><br><span class="line">      // Reflects the setting used in the input json, defaults to "ipfs"</span><br><span class="line">      bytecodeHash: "ipfs"</span><br><span class="line">    &#125;</span><br><span class="line">    // Required for Solidity: File and name of the contract or library this</span><br><span class="line">    // metadata is created for.</span><br><span class="line">    compilationTarget: &#123;</span><br><span class="line">      "myFile.sol": "MyContract"</span><br><span class="line">    &#125;,</span><br><span class="line">    // Required for Solidity: Addresses for libraries used</span><br><span class="line">    libraries: &#123;</span><br><span class="line">      "MyLib": "0x123123..."</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  // 必选：合约的生成信息</span><br><span class="line">  output:</span><br><span class="line">  &#123;</span><br><span class="line">    // 必选：合约的 ABI 定义</span><br><span class="line">    abi: [ ... ],</span><br><span class="line">    // 必选：合约的 NatSpec 用户文档</span><br><span class="line">    userdoc: [ ... ],</span><br><span class="line">    // 必选：合约的 NatSpec 开发者文档</span><br><span class="line">    devdoc: [ ... ],</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于生成的合约的字节码包含元数据的哈希值，因此对元数据的任何更改都会导致字节码的更改。 此外，由于元数据包含所有使用的源代码的哈希值，所以任何源代码中的， 哪怕是一个空格的变化都将导致不同的元数据，并随后产生不同的字节代码。需注意，上面的 ABI 没有固定的顺序，随编译器的版本而不同。尽管从 Solidity 0.5.12 开始，数组保持了一定的顺序。</p><h4 id="源代码验证方法"><a href="#源代码验证方法" class="headerlink" title="源代码验证方法"></a>源代码验证方法</h4><p>为了验证编译，可以通过元数据文件中的链接从 Swarm 中获取源代码。 获取到的源码，会根据元数据中指定的设置，被正确版本的编译器（应该为“官方”编译器之一）所处理。 处理得到的字节码会与创建交易的数据或者 <code>CREATE</code> 操作码使用的数据进行比较。 这会自动验证元数据，因为它的哈希值是字节码的一部分。 而额外的数据，则是与基于接口进行编码并展示给用户的构造输入数据相符的。</p><h4 id="ABI"><a href="#ABI" class="headerlink" title="ABI"></a>ABI</h4><p>在 以太坊Ethereum 生态系统中， 应用二进制接口Application Binary Interface(ABI) 是从区块链外部与合约进行交互以及合约与合约间进行交互的一种标准方式。 数据会根据其类型按照这份手册中说明的方法进行编码。这种编码并不是可以自描述的，而是需要一种特定的概要（schema）来进行解码。</p><p>除了 元组tuple 以外，Solidity 支持以上所有类型的名称。ABI 元组tuple 是利用 Solidity 的 <code>structs</code> 编码得到的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.16</span>;</span><br><span class="line"></span><br><span class="line">contract Foo &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">bytes3[<span class="number">2</span>]</span>) <span class="title">public</span> <span class="title">pure</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params">uint32 x, bool y</span>) <span class="title">public</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">bool r</span>) </span>&#123; r = x &gt; <span class="number">32</span> || y; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">sam</span>(<span class="params">bytes, bool, uint[]</span>) <span class="title">public</span> <span class="title">pure</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，对于我们的例子 <code>Foo</code>，如果我们想用 <code>69</code> 和 <code>true</code> 做参数调用 <code>baz</code>，我们总共需要传送 68 字节，可以分解为：</p><ul><li><code>0xcdcd77c0</code>：方法ID。这源自ASCII格式的 <code>baz(uint32,bool)</code> 签名的 Keccak 哈希的前 4 字节。</li><li><code>0x0000000000000000000000000000000000000000000000000000000000000045</code>：第一个参数，一个被用 0 值字节补充到 32 字节的 uint32 值 <code>69</code>。</li><li><code>0x0000000000000000000000000000000000000000000000000000000000000001</code>：第二个参数，一个被用 0 值字节补充到 32 字节的 boolean 值 <code>true</code>。</li></ul><p>合起来就是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0xcdcd77c000000000000000000000000000000000000000000000000000000000000000450000000000000000000000000000000000000000000000000000000000000001</span><br></pre></td></tr></table></figure><p>它返回一个 <code>bool</code>。比如它返回 <code>false</code>，那么它的输出将是一个字节数组 <code>0x0000000000000000000000000000000000000000000000000000000000000000</code>，一个bool值。</p><p>事件，是 以太坊Ethereum 的日志/事件监视协议的一个抽象。日志项提供了合约的地址、一系列的主题（最高 4 项）和一些任意长度的二进制数据。为了使用合适的类型数据结构来演绎这些功能（与接口定义一起），事件沿用了既存的 ABI 函数。</p><p>给定了事件名称和事件参数之后，我们将其分解为两个子集：已索引的和未索引的。已索引的部分，最多有 3 个，被用来与事件签名的 Keccak 哈希一起组成日志项的主题。未索引的部分就组成了事件的字节数组。</p><p>一个事件描述是一个有极其相似字段的 JSON 对象：</p><ul><li><p><code>type</code>：总是 <code>&quot;event&quot;</code>；</p></li><li><p><code>name</code>：事件名称；</p></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inputs</span><br></pre></td></tr></table></figure><p>：对象数组，每个数组对象会包含：</p><ul><li><code>name</code>：参数名称；</li><li><code>type</code>：参数的权威类型（相见下文）；</li><li><code>components</code>：供 元组tuple 类型使用（详见下文）；</li><li><code>indexed</code>：如果此字段是日志的一个主题，则为 <code>true</code>；否则为 <code>false</code>。</li></ul></li><li><p><code>anonymous</code>：如果事件被声明为 <code>anonymous</code>，则为 <code>true</code>。</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: GPL-3.0</span></span><br><span class="line">pragma solidity &gt;<span class="number">0.6</span><span class="number">.99</span> &lt;<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123; b = <span class="number">0x12345678901234567890123456789012</span>; &#125;</span><br><span class="line">  event Event(uint indexed a, bytes32 b);</span><br><span class="line">  event Event2(uint indexed a, bytes32 b);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">uint a</span>) <span class="title">public</span> </span>&#123; Event(a, b); &#125;</span><br><span class="line">  bytes32 b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[&#123;</span><br><span class="line"><span class="attr">"type"</span>:<span class="string">"event"</span>,</span><br><span class="line"><span class="attr">"inputs"</span>: [&#123;<span class="attr">"name"</span>:<span class="string">"a"</span>,<span class="attr">"type"</span>:<span class="string">"uint256"</span>,<span class="attr">"indexed"</span>:<span class="literal">true</span>&#125;,&#123;<span class="attr">"name"</span>:<span class="string">"b"</span>,<span class="attr">"type"</span>:<span class="string">"bytes32"</span>,<span class="attr">"indexed"</span>:<span class="literal">false</span>&#125;],</span><br><span class="line"><span class="attr">"name"</span>:<span class="string">"Event"</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line"><span class="attr">"type"</span>:<span class="string">"event"</span>,</span><br><span class="line"><span class="attr">"inputs"</span>: [&#123;<span class="attr">"name"</span>:<span class="string">"a"</span>,<span class="attr">"type"</span>:<span class="string">"uint256"</span>,<span class="attr">"indexed"</span>:<span class="literal">true</span>&#125;,&#123;<span class="attr">"name"</span>:<span class="string">"b"</span>,<span class="attr">"type"</span>:<span class="string">"bytes32"</span>,<span class="attr">"indexed"</span>:<span class="literal">false</span>&#125;],</span><br><span class="line"><span class="attr">"name"</span>:<span class="string">"Event2"</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line"><span class="attr">"type"</span>:<span class="string">"function"</span>,</span><br><span class="line"><span class="attr">"inputs"</span>: [&#123;<span class="attr">"name"</span>:<span class="string">"a"</span>,<span class="attr">"type"</span>:<span class="string">"uint256"</span>&#125;],</span><br><span class="line"><span class="attr">"name"</span>:<span class="string">"foo"</span>,</span><br><span class="line"><span class="attr">"outputs"</span>: []</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>Solidity的合约开始真正的意义上的普及还需要一些时间，但是对于真正的使用，还是相当的有意思。</p><p>接下来的使用中，在一步一步更新这个文档，感觉solidity蛮有意思的。</p></div><div><div style="padding:10px 0;margin:20px auto;width:90%;text-align:center"><div>坚持原创技术分享，您的支持将鼓励xinqiyang继续创作！</div><button id="rewardButton" disable="enable" onclick='var e=document.getElementById("QR");"none"===e.style.display?e.style.display="block":e.style.display="none"'><span>打赏</span></button><div id="QR" style="display:none"><div id="wechat" style="display:inline-block"><img id="wechat_qr" src="/images/wechatpay.jpg" alt="xinqiyang 微信支付"><p>微信支付</p></div><div id="alipay" style="display:inline-block"><img id="alipay_qr" src="/images/alipay.jpg" alt="xinqiyang 支付宝"><p>支付宝</p></div></div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>xinqiyang</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="http://yangxinqi.com/2020/11/02/solidity学习笔记/" title="solidity学习笔记">http://yangxinqi.com/2020/11/02/solidity学习笔记/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/solidity/" rel="tag"># solidity</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2020/11/02/梯子教程简版/" rel="next" title="梯子教程简版"><i class="fa fa-chevron-left"></i> 梯子教程简版</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2020/11/13/懂得规划自己的生活/" rel="prev" title="懂得规划自己的生活">懂得规划自己的生活 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"><div class="bdsharebuttonbox"><a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a> <a href="#" class="bds_douban" data-cmd="douban" title="分享到豆瓣网"></a> <a href="#" class="bds_sqq" data-cmd="sqq" title="分享到QQ好友"></a> <a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a> <a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a> <a href="#" class="bds_tieba" data-cmd="tieba" title="分享到百度贴吧"></a> <a href="#" class="bds_twi" data-cmd="twi" title="分享到Twitter"></a> <a href="#" class="bds_fbook" data-cmd="fbook" title="分享到Facebook"></a> <a href="#" class="bds_more" data-cmd="more"></a> <a class="bds_count" data-cmd="count"></a></div><script>window._bd_share_config={common:{bdText:"",bdMini:"2",bdMiniList:!1,bdPic:""},share:{bdSize:"16",bdStyle:"0"},image:{viewList:["tsina","douban","sqq","qzone","weixin","twi","fbook"],viewText:"分享到：",viewSize:"16"}}</script><script>with(document)0[(getElementsByTagName("head")[0]||body).appendChild(createElement("script")).src="//bdimg.share.baidu.com/static/api/js/share.js?cdnversion="+~(-new Date/36e5)]</script></div></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/avatar.jpg" alt="xinqiyang"><p class="site-author-name" itemprop="name">xinqiyang</p><p class="site-description motion-element" itemprop="description">xinqiyang's notes</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">32</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><span class="site-state-item-count">7</span> <span class="site-state-item-name">分类</span></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">21</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/xinqiyang" target="_blank" title="GitHub"><i class="fa fa-fw fa-globe"></i>GitHub</a> </span><span class="links-of-author-item"><a href="https://twitter.com/xinqiyang" target="_blank" title="Twitter"><i class="fa fa-fw fa-globe"></i>Twitter</a> </span><span class="links-of-author-item"><a href="https://weibo.com/xinqiyang" target="_blank" title="Weibo"><i class="fa fa-fw fa-globe"></i>Weibo</a> </span><span class="links-of-author-item"><a href="https://www.douban.com/people/scotoma/" target="_blank" title="DouBan"><i class="fa fa-fw fa-globe"></i>DouBan</a> </span><span class="links-of-author-item"><a href="https://www.zhihu.com/people/xiaoxinsqqqq/activities" target="_blank" title="ZhiHu"><i class="fa fa-fw fa-globe"></i>ZhiHu</a></span></div><div class="cc-license motion-element" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#正文"><span class="nav-number">2.</span> <span class="nav-text">正文</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Solidity语法"><span class="nav-number">2.1.</span> <span class="nav-text">Solidity语法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#安装Solidity"><span class="nav-number">2.2.</span> <span class="nav-text">安装Solidity</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Solidity源文件结构"><span class="nav-number">2.3.</span> <span class="nav-text">Solidity源文件结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#值类型"><span class="nav-number">2.4.</span> <span class="nav-text">值类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#单位和全局变量"><span class="nav-number">2.5.</span> <span class="nav-text">单位和全局变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#错误处理"><span class="nav-number">2.6.</span> <span class="nav-text">错误处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#合约"><span class="nav-number">2.7.</span> <span class="nav-text">合约</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Solidity-合约类似于面向对象语言中的类。合约中有用于数据持久化的状态变量，和可以修改状态变量的函数。-调用另一个合约实例的函数时，会执行一个-EVM-函数调用，这个操作会切换执行时的上下文，这样，前一个合约的状态变量就不能访问了。"><span class="nav-number">2.8.</span> <span class="nav-text">Solidity 合约类似于面向对象语言中的类。合约中有用于数据持久化的状态变量，和可以修改状态变量的函数。 调用另一个合约实例的函数时，会执行一个 EVM 函数调用，这个操作会切换执行时的上下文，这样，前一个合约的状态变量就不能访问了。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#合约元数据"><span class="nav-number">2.9.</span> <span class="nav-text">合约元数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#源代码验证方法"><span class="nav-number">2.10.</span> <span class="nav-text">源代码验证方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ABI"><span class="nav-number">2.11.</span> <span class="nav-text">ABI</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#结语"><span class="nav-number">3.</span> <span class="nav-text">结语</span></a></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2021</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">xinqiyang</span></div><div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div><span class="post-meta-divider">|</span><div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Muse</a> v6.0.3</div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/js/src/utils.js?v=6.0.3"></script><script type="text/javascript" src="/js/src/motion.js?v=6.0.3"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=6.0.3"></script><script type="text/javascript" src="/js/src/post-details.js?v=6.0.3"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.3"></script></body></html><!-- rebuild by neat -->