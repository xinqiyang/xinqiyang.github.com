{"meta":{"title":"xinqiyang notes","subtitle":"Nothing behind me, everything ahead of me,as is ever so on the road.","description":"xinqiyang's notes","author":"xinqiyang","url":"http://yangxinqi.com"},"pages":[{"title":"categories","date":"2018-02-05T11:53:46.000Z","updated":"2018-02-05T12:54:08.000Z","comments":false,"path":"categories/index.html","permalink":"http://yangxinqi.com/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2018-02-03T15:11:02.000Z","updated":"2021-04-06T13:40:48.000Z","comments":true,"path":"about/index.html","permalink":"http://yangxinqi.com/about/index.html","excerpt":"","text":"关于xinqiyang一个Geek，喜爱编程联系： me@yangxinqi.com简历： xinqiyang’s resume"},{"title":"tags","date":"2018-02-05T11:54:42.000Z","updated":"2018-02-05T12:55:02.000Z","comments":false,"path":"tags/index.html","permalink":"http://yangxinqi.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"元宇宙值得5年持续投入吗","slug":"元宇宙值得5年持续投入吗","date":"2021-11-28T09:16:16.000Z","updated":"2021-11-29T06:45:21.308Z","comments":true,"path":"2021/11/28/元宇宙值得5年持续投入吗/","link":"","permalink":"http://yangxinqi.com/2021/11/28/元宇宙值得5年持续投入吗/","excerpt":"","text":"元宇宙值得5年持续投入么找对人做对事情，现在开始做项目算是晚了么，其实在什么时候都不晚，利用自身的资源，开始做项目上的开发，还是很有戏的。接下来持续投入的在TradingView上建立对A股，日股，美股，数字货币的仓位，并进行统一的管理，以实际收入作为一个重要的点来看。Stars项目持续投入来做，包装一个网站，然后把项目推行起来，这块还是很值得去做的。元宇宙这个概念是否吸引人，其实大家玩的都是传播，之后项目是否都能够获得实际的收益，其实项目整体来看也比较简单。把复杂的事情弄简单。每天开始找人，然后开始推自己的项目，每天都有人购买，接下来能够产生出经济价值，这个是最重要的。关于核心团队，很多事情可遇而不可求，其实整体来看，大家也都比较简单， 做简单的事情，把结果做好就够了。如何开始真正的操作：实际让项目跑起来，团队内部大家能够分工明确的方式，做起来。项目实际需要包装的，把小余拉进来，对于一些有想法的人，可以进行整体的合作。在做客户项目和自己项目之间徘徊，一直在做的都是客户的项目，客户一多，事情的执行就没有那么顺利了。","categories":[{"name":"blockchain","slug":"blockchain","permalink":"http://yangxinqi.com/categories/blockchain/"}],"tags":[{"name":"元宇宙, metaverse","slug":"元宇宙-metaverse","permalink":"http://yangxinqi.com/tags/元宇宙-metaverse/"}]},{"title":"混乱年代下的内心平静","slug":"混乱年代下的内心平静","date":"2021-08-21T01:31:02.000Z","updated":"2021-08-21T02:22:44.000Z","comments":true,"path":"2021/08/21/混乱年代下的内心平静/","link":"","permalink":"http://yangxinqi.com/2021/08/21/混乱年代下的内心平静/","excerpt":"","text":"前言新冠疫情以及持续快2年了，在这段时间里，从活跃状态到低谷，在从低谷到活过来，事业失败其实不可怕，可怕的是丧失信心，找到自己的生活节奏和工作方式，不要让工作太占用生活，其实很多时候，除了努力之外，运气和选择都很重要。 看好的项目不一定能够有好的结局，很多时候不可能的发生的事情，总会发生，明白什么是最重要的，这个最关键。写这篇算是最近3个月的吐槽，发现写博客很减压。看历史已知未来从最近我🐰政府的各种操作，到美帝的各种下坡溃败的感觉，其实发现，小到个人，大到政府，都在选择自己利益最大化的最优解而做抉择，不管是我兔的各种增加财政税收的手段，以及防止资产外流的措施，都是为了加强自身的统治力。美帝的各种扼杀也同样的，其实和最终的领导智慧和各种偶然事件密不可分。相信，世事无常，阴阳轮转，一切从历史中都可以知道未来，最近喜欢上一些历史的书籍，比如明朝，比如宋朝，乃至清朝，除了中国历史之外，在到欧洲，美洲，各种血泪史，不比我兔的历史光鲜多少。在看中亚的阿富汗的戏剧一幕，一切都是斗争的战场，各方势力都在这里为了自己的目标在努力着。 作为吃瓜群众的我，除了被刷三观之外，其实更多的需要扪心自问下，前10年，为什么不抽出一些时间来看书呢？ 在历史的潮流中，多少帝国都会会湮灭，多少家族从富而衰，多少的不公平。不管的疫情的源头结果如何，都应该平淡的看待，很多你认为的真相，不一定是真相，所以真相往往不重要了，看事件本身对你的伤害程度。观历史，每天抽出30分钟，看各个地球板块的历史，在和娃讨论下历史，睡前故事和他们讲讲历史，以及每个文明的各种优缺点，是不是也可以帮我自己来梳理，并提高呢？ 接下来不管多忙，践行每天的30分钟读书时间，尽量给娃讲睡前故事，简单的事情，想去做真的可以做到。 接下来的10年，从历史中看未来。内心强大而平静各种苦难，都在强大的内心前，显得那么的渺小。 今年一起，公司陷入巨大困境，项目和人都是，一度萌生了放弃的念头，一度去放弃过，但是随着一个巨大的阳光普照的机会，在疫情的补助之下活了过来。在最困难的时候，没有人情冷暖，更多的是各种的利益之间的清算结束。 确实体会到一把，越难的时候，越没有人帮，在最困难的时候帮你的人，要感激一辈子。活过来，其实也是一种状态，当疫情期间大家都躲在家里的时候，我们在办公室努力，在各种商业活动，为活下来而战。在区块链的世界里，一天就入外面的一年，各种机会和噱头层出不穷，看如何抓住，才是最大的重点，其实人的生活也是如此，做自己能够做好的事情，追随者自身的信仰，做自己应该做的事情。内心强大和信仰分不开的，之前的我没有信仰，不管是对技术，对未来，对人，对事。发现人生35年最大的失败，其实就在于没有信仰，因为没有信仰，就没有计划，人生随遇而安，其实是对自己的最大的不负责任。 在最好的点，选择最不好的那一项，老天给过的机会，没有抓住，其实分析整体发展优势，在最终的抉择上，能够突破而走出来，超越自己的内心能够成大事。平静与急躁是一堆孪生兄弟，在好机会面前，一定要抓住他，然而很多时候，你跑的快，别人不一定能够跟的上，这个就是一个平衡的问题。 针对问题，平静的去解决，把不应该占有休息时间的工作，挤出应该留下来的家庭时间和学习时间。 这个也是修炼，接下来能够把自己领悟的，在传达给其他的人，宣传自己，每天发一条微博和微信，或者写一篇博客，清晰自己的定位，每周写一篇总结类型的文章，也是很惬意的事情。内心强大而平静的对待人和事，减少焦虑，多留一些时间给自己和家人，其实就可以，好运气，急躁的人是抓不住的，机会到来的时候，我们就应该抓住。选择和运气选择和运气，在人生中至关重要，在自己这一辈，父母没有教我们如何在选择中获得好运气，从而有一个好的人生，而自己也没有意识到自己的人生，会是现在这样的。努力争取不一定有运气来的重要，跟对人，做对事，比自己努力的瞎忙活，好多了。在有限的精力下，如何处理好和其他人的联系，不管是商业上的，私交，还是生活上的，其实都应该更为积极，更加的能够聊的开，而不应该只限定在自己的业务领域，虽然现在在创业阶段，在表达能力上的欠缺会导致很多的选择偏差，从而失去好运气，在失去好机会。商业上最近抓住的机会有，错失的也不少，不可否认自己的失败，接下来在对待项目和其他的团队合作上，应该更开放，更积极的来进行。 其实团队之间牛逼的人有不少，但是不懂团队合作的，也就很难走的长远的，有些人就是在不断的尝试中错过，在聚首在错过，人生都是如此。 没有永恒的敌人，只有永恒的利益，但是朋友之间很多时候，也不需要都讲究利益，很多事情，不是用利益来衡量的。 回顾这一生，真正的好朋友有几个？到死还能在一起喝茶聊天，看淡人生的，又有几个？其实圈子就这么大，选择了就选择了， 运气就来了。不需要依赖于别人，一切的选择权还是在自己手中。作为创始人退无可退自己的运气和积累，能够把项目和团队带到什么样的境界，自己应该很心知肚明的，不修炼是很难走下去。不会看人，用人，到最后都走不远，心胸不够宽大，更走不远，在东京的这个小圈子里，也没有能够让你走出来的人，但是反观国内也是一样，还是看你的时间，用在了什么地方，尝试多和人沟通，是不是就可以？拿着项目多和朋友探讨，这个也是自己作为一个投资人的模式，在对外沟通，其实真心，感觉自己学习能力很可以，能够很快的领悟并学到，但是很多时候，心胸不够宽广，会带来更多的问题，创业这么多年，没有带出来好团队，和自己的修炼是有很大的关系的。其实有的时候放弃也是一种很对的选择，退一步在进一步。 今天看到supercell团队的例子，其实积累很关键，企业文化也会很关键，一直没有做起来的原因，最大的在于自己没有信仰，导致团队也没有信仰，从而导致企业文化无法推行，大家没有责任感，最终就是散场的解决。 所以努力带好小团队，做出好产品，接下里让大厂收购，在大厂混口饭吃，是接下来10年的主旋律。 现在上市无望，在区块链的世界上市也是一种很好的选择，之前不敢想的，现在去做，其实一切退无可退的压力，都在自己的内心，突破了会更上一层。最后做自己认为对的事情，修炼自己，带好团队，在GameFi的领域深耕3年，做出好产品，做好运营，在学好语言，处理好家庭关系，其实还有很多事情要做。接下来搬砖去了，其实人生之中，运气很关键，做个开朗大方的人，好运气不会缺的。","categories":[{"name":"others","slug":"others","permalink":"http://yangxinqi.com/categories/others/"}],"tags":[{"name":"混乱,平静","slug":"混乱-平静","permalink":"http://yangxinqi.com/tags/混乱-平静/"}]},{"title":"BSC基础服务GAS Price Service实现","slug":"BSC-GAS-Service实现","date":"2021-04-20T16:01:34.000Z","updated":"2021-04-20T16:36:38.000Z","comments":true,"path":"2021/04/21/BSC-GAS-Service实现/","link":"","permalink":"http://yangxinqi.com/2021/04/21/BSC-GAS-Service实现/","excerpt":"","text":"前言“老板说，小杨，现在的ETH的Gas太贵了，把现在的合约业务都切换到BSC上吧。”， 小杨 – “ 收到，老板” 。。。。。。开始了连续几周的加班中， 最近在用Metamask钱包上，对应BSC，然后开始修改合约，修改钱包，修改DAPP，俨然重来一遍啊。本次记录下一些过程，修正BSC下的wallet的币种的价格，修复BSC下的GasPrice 获取服务，本次主要讲解Gas Price的获取, ETH的Gas价格是 BSC 的180x ，大家都切换到BSC吧，一样玩的很hi啊。正文先讲结果， 通过将钱包的默认Gas价格服务修改到自己搭建的节点上，省下了180x的Gas，虽然没几个币，但是总量算起来还是蛮多的，所以有必要花时间来处理下.Metamask ETH Gas Price: (单位Gwei)1234567curl https://api.metaswap.codefi.network/gasPrices&#123; \"SafeGasPrice\": \"227\", \"ProposeGasPrice\": \"257\", \"FastGasPrice\": \"282\"&#125;CoinPhD BSC Gas Price: (单位Gwei)1234567891011curl https://coinphd.com/api/bscgasprice&#123; \"health\": true, \"block_number\": 6735170, \"SafeGasPrice\": 5.0, \"ProposeGasPrice\": 5.0, \"FastGasPrice\": 6.241, \"InstantGasPrice\": 150.0, \"block_time\": 3.857&#125;从返回的结果来看，ETH 的Gas价格是BSC的 227/5 x 4 = 190 X , 在ETH上做操作的人，都是贼有钱。。。。。。强烈推荐大家都来BSC上来玩在Metamask上，使用修改过的Gas Price服务，看到Gas费用基本可以忽略了。在对BSC的tx进行分析后发现， 土豪很多，7000+ Gwei的gas也大有人在，看到最大的 42538.538， 所以在BSC上争抢交易的事情也在发生，接下来会在写一篇关于BSC上使用gas的土豪分析的文章。想想还是把Gas Price服务开源吧，都是学习的过程，进来留在Github上，希望对大家有帮助。访问： https://github.com/xinqiyang/bscgasprice 下载最新的源码实现用Python + Web3 实现的，实现了重连和同时获取多个备用节点的国内，BSC提供了3个主节点，但是第三个连不上，目前2个可用。123git clone https://github.com/xinqiyang/bscgasprice# docker 对外提供服务 0.0.0.0:6669 提供gas price servicedocker-compose up -d --build核心代码：拿到web3的实例，然后需要设定 poa middleware 之后即可去连BSC了， 在轮询获取 last block 并统计 tx.gasPrice 进行计算，得出gas price的值。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 localw3 = web3_instance() localw3.middleware_onion.inject(geth_poa_middleware, layer=0) # print(localw3.clientVersion) latest = localw3.eth.filter('latest') # print('worker:', latest) if not skip_warmup and not block_times: warmup() while True: try: for n in latest.get_new_entries(): process_block(localw3, n) log.info(str(stats)) if not localw3.eth.syncing: stats['health'] = True except: sleep(5) localw3 = web3_instance() latest = localw3.eth.filter('latest') log.warning(\"do reconnect ------- &#123;&#125; &#123;&#125; &#123;&#125;\".format(int(time.time()), str(localw3), str(latest))) continue sleep(2) def process_block(w3i, n): block = w3i.eth.getBlock(n, True) stats['block_number'] = block.number block_times.append(block.timestamp) if len(block_times) &gt; 1: t = sorted(block_times) stats['block_time'] = round(mean(b - a for a, b in zip(t, t[1:])), 3) if block.transactions: prices = [] for tx in block.transactions: if int(tx.gasPrice) &gt; 0: prices.append(tx.gasPrice) blocks_gwei.append(min(prices)) data = pd.Series(blocks_gwei) for name, q in QUANTILES.items(): if name in ['FastGasPrice']: stats[name] = round(float(w3i.fromWei(average(prices), 'gwei')), 3) elif name in ['InstantGasPrice']: stats[name] = round(float(w3i.fromWei(max(prices), 'gwei')), 3) else: price = data.quantile(q / 100) stats[name] = round(float(w3i.fromWei(price, 'gwei')), 3) print(stats) return block其实比较简单，就是网络有时候有问题， 需要重连，这个地方搞了2个小时，后面只能exception的时候，重新去创建web3连接。这个是跑起来的服务器的日志，发现连接次数太多，会被block一段时间，所以需要增加timeout。返回的json，针对Metamask的格式进行优化过了，欢迎大家使用。如果不想大家自己的GasPrice服务节点，可以使用CoinPhD BSC Gas Price Service :https://coinphd.com/api/bscgasprice这个api我会一直维护下去。结语提供免费的服务给大家，是CoinPhD接下来的方向，DEFI很有意思，BSC比起ETH来，确实更适合国人来用。Gas Price只是简单的服务，但是之前不注意，还是相当贵的，所以BSC在基础服务上还是需要继续完善啊。CoinPhD要复活了，接下来多开源一些有用的服务，为DEFI继续搬砖。。","categories":[{"name":"blockchain","slug":"blockchain","permalink":"http://yangxinqi.com/categories/blockchain/"}],"tags":[{"name":"BSC","slug":"BSC","permalink":"http://yangxinqi.com/tags/BSC/"}]},{"title":"迁移服务到飞书","slug":"迁移服务到飞书","date":"2021-04-06T13:41:32.000Z","updated":"2021-04-06T13:51:08.000Z","comments":true,"path":"2021/04/06/迁移服务到飞书/","link":"","permalink":"http://yangxinqi.com/2021/04/06/迁移服务到飞书/","excerpt":"","text":"前言“当你想放弃的时候，想想你为什么开始” – 埃隆·马斯克 。名人总是可以用自己的身体力行，来表示优越感。可是有的时候，我就想做我自己。 弄个自己的域名，写自己的想写的东西，算是记录自己活着的过程，当感到孤独的时候，写写博客，自己和自己对话，就有一个人陪你说话了，这个人可能是过去的自己，也可能是未来的自己， 总之，有个人无条件的陪你，这样就足够了。飞书体验最近把项目管理工具都迁移到飞书了， 从最早的JINA，到后面的github，到现在的飞书，确实感觉飞书还是很好用的。但是他们的运营人员，老是会打电话，在日本，我们也不接电话了。最赞的是，他们的插件式的服务，这块有很多好的app可以集成进来，还有就是很好的邮件服务。对于腾讯邮箱，网易邮箱，还有mailgun邮箱，还有gmo邮箱，还有godday的服务，最后还是回到了飞书，虽然他们不能及时的获取邮件推送，但是能够收发，就已经很赞了。还有板栗看板，还有视频会议和云文档，这些都相当的好用，好用的东西用过之后，才知道。 。。。。总计飞书真的好， 可以推荐给大家。 。。。字节的产品做的还是很不错的，赞下。弄个自己域名的邮箱，以后可以直接联系我： me@yangxinqi.com 感觉比较有逼格，😄","categories":[{"name":"others","slug":"others","permalink":"http://yangxinqi.com/categories/others/"}],"tags":[{"name":"others","slug":"others","permalink":"http://yangxinqi.com/tags/others/"}]},{"title":"AU 10G宽带初步体验","slug":"AU-10G宽带初步体验","date":"2021-03-16T13:13:03.000Z","updated":"2021-04-06T14:08:16.000Z","comments":true,"path":"2021/03/16/AU-10G宽带初步体验/","link":"","permalink":"http://yangxinqi.com/2021/03/16/AU-10G宽带初步体验/","excerpt":"","text":"前言AU 10G宽带拉上之后的初步体验尝试新东西，是一贯的追求，但是从今年起，要践行够用就好的原则，把时间花在必须的地方，其实除了赚钱之外，还有很多有意义的事情，你可以去做，而且方法有很多，每个人都有自己的点，自己需要get到自己的点，其实最惨的就是盲目的努力，到最后都是徒劳。本次签约的是AU的10G光， 名字 auひかり ホーム10ギガ ，第一年每个月费用 5,610円 （1年目），看过去还是可以的。实际使用速度测试：基本上传 100M/s 以上，最高的时候 120M/s ，这个速度相当不错了。基本下载 50M/s 左右，下载比上传还慢，这个是日本网络的一大特色。带宽限制：每天最多30G的流量，超过了之后会被降速，这个也是可以理解的，但是做为常用的功能来看，还是足够的了。SpeedTest的测试：通过服务器和Wifi 5G测试，看过去也都还行，对得起这个价格。结语最后感觉10G，虽然速度很赞，但是流量限制比较鸡肋，家庭来用还是很足够的。默认的AU的路由器，不开启无线模块，可以使用自己的路由器来开启，不需要他们自己带的路由器功能，这块对于小白，他们还是能够每个月多收几百块的费用的。 这个收费模式比较恶心倒是。随着日本5G还有流量竞争的激烈，其实真心感觉，AU还是走在前面的，这个应该赞下。最后","categories":[{"name":"others","slug":"others","permalink":"http://yangxinqi.com/categories/others/"}],"tags":[{"name":"10G","slug":"10G","permalink":"http://yangxinqi.com/tags/10G/"}]},{"title":"Line Blockchain解决方案介绍","slug":"Line-Blockchain解决方案介绍","date":"2021-01-04T02:27:27.000Z","updated":"2021-01-04T03:38:24.000Z","comments":true,"path":"2021/01/04/Line-Blockchain解决方案介绍/","link":"","permalink":"http://yangxinqi.com/2021/01/04/Line-Blockchain解决方案介绍/","excerpt":"前言新年在家休整了2天后，开始继续奋战，在考虑phase 2的和区块链技术整合的阶段，看到日本的IM巨头，Line在Blockchain上做的solution。具体链接在这里 https://jp.techcrunch.com/2020/12/31/line-blockchain-developers-meetup-001-part01/ ， 就翻译了下，和大家一起分享，也许未来区块链在日本真正的落地，还得依赖这些巨头，看最近中国的蚂蚁链，推广的也不错。主要面向用户：对区块链感兴趣的开发人员考虑引入 LINE Blockchain 的公司来介绍LINE区块链未来的发展。本次文章由Line区块链开发工程团队经理 那須 利将 来发表。LINE区块链概述LINE区块链的口号是“为每个人设计的LINE区块链”。目的是将区块链技术纳入我们的日常生活。","text":"前言新年在家休整了2天后，开始继续奋战，在考虑phase 2的和区块链技术整合的阶段，看到日本的IM巨头，Line在Blockchain上做的solution。具体链接在这里 https://jp.techcrunch.com/2020/12/31/line-blockchain-developers-meetup-001-part01/ ， 就翻译了下，和大家一起分享，也许未来区块链在日本真正的落地，还得依赖这些巨头，看最近中国的蚂蚁链，推广的也不错。主要面向用户：对区块链感兴趣的开发人员考虑引入 LINE Blockchain 的公司来介绍LINE区块链未来的发展。本次文章由Line区块链开发工程团队经理 那須 利将 来发表。LINE区块链概述LINE区块链的口号是“为每个人设计的LINE区块链”。目的是将区块链技术纳入我们的日常生活。LINE于2018年4月成立了“ LINE Blockchain Lab”，并于7月在全球市场上开设了当前加密资产交易所“ BITFRONT”的前身“ BITBOX”。10月，加密资产“ LINK”被列出。2019年9月，加密资产交易所“ BITMAX”在日本开业，LINK于2020年8月在日本上市。同时，我们开始提供“ BITMAX钱包”和LINE区块链开发人员，并且在过去三年中，我们逐一发布了区块链服务和产品，以实现通证经济的概念。LINK（LN）是LINE最初发行的加密资产。在LINE服务中，预计用户会收到它作为贡献活动的奖励，并且由于服务的增长，通证经济将扩大，对LINK的需求也会增加。用户已经获得激励的LINK，目前正在与LINE家庭服务和合作伙伴公司进行准备，以便可以在各种dApp和服务中使用。LINK已经可以通过BITMAX转换为合法货币，并且正在为通证经济做好准备。为了扩大对加密资产LINK的使用，LINE还推出“ LINK Rewards Program ”。LINK奖励计划是LINE代币经济的每个服务轻松参与的机制，简单来说，它是一种将加密资产LINK返还给服务用户的机制，就像各种常规点服务一样。BITMAX钱包也可以作为用户接收LINK的入口。BITMAX钱包是一项钱包服务，可以管理在LINK和区块链上发行的数字资产。它具有一个LINE ID，旨在供任何LINE用户使用，以使私钥不会被遗忘和丢失。BITMAX钱包将是一项重要服务，它将成为8600万LINE用户访问区块链服务的网关。顺便说一下，它不同于BITMAX，后者是一种加密资产交易服务，因此您需要小心。LINE Blockchain Developers将是一个开发工具，可为开发人员提供与区块链链接的服务的轻松访问，类似于为用户开发BITMAX Wallet。借助LINE区块链开发人员，可以使用API和Web UI在区块链上轻松发行Token和NFT（非可替代通证Token），并可以将其链接到服务。区块链的另一个功能是交易的透明性，该服务称为“ LINE Blockchain Explorer”。您可以查看在用户或服务中正在发出和处理哪些事务。所有这些都是LINE Blockchain提供的服务的整体情况。以上是那须先生的开幕式。使用LINE区块链DEVELOPERS项目进行DApp开发下一个会议是LINE Puls Blockchain Dev 1 Blockchain Developer的 坂井隆一 撰写的“使用LINE Blockchain Developers轻松快速进行Blockchain dApp开发”。在此主题中，通证设置和发行都是实时完成的。在本文中这句话用了很长的篇幅，但是即使示例dApp（代码）已经准备好了，但都在40分钟的会话中完成了，并且很容易开始开发区块链服务。我想指出。至少事实证明，即使非工程人员也可以轻松设置和发行通证。LINE区块链开发人员还提供REST API，控制台（Web UI）和文档。LINE区块链旨在允许您通过REST API使用区块链功能，而不是直接访问区块链。工程师可以使用REST API开发dApp，而无需了解很多有关区块链的知识。控制台可以通过Web UI进行操作，它是一种工具，可让您设置使用LINE Blockchain Developers开发dApp时所需的区块链。此外，文档为使用LINE区块链组织并准备了文档，例如服务教程，API参考和示例代码。顺便说一句，LINE Blockchain允许您使用这些工具发行通证。该通证可以大致分为两种类型：服务令牌和项目令牌。服务令牌以每种服务中的货币形式准备（类似于ERC-20）。物品代币用于将非金钱物品和物品视为代币，并进一步分为可替代的精美代币和不可替代的非精美代币（NFT）（类似 以太坊 ERC-1155标准）。演示dApp“ LINE Blockchain Coffee”中的开发流程开发演示中介绍的dApp“ LINE Blockchain Coffee”是一个虚拟的在线咖啡店。它旨在在LINE区块链测试网络“ Cashew（カシュー） chain”上运行。LINE Blockchain Coffee使用两种类型的令牌。一种是服务令牌LBCC（LINE区块链咖啡币）。LBCC在服务中用作货币。第二个令牌LBCR（LINE区块链咖啡奖励）将作为NFT发行，并在购买咖啡时用作奖励。LINE Blockchain Coffee由LINE Puls工程师Alan Goo开发，而dApp代码已经发布在Alan Goo的GitHub上(https://github.com/behumble/line-blockchain-coffee)。本节中的解释将是使用基于LINE Blockchain Coffee的LINE Blockchain Developers进行dApp开发的过程。顺便说一下，LINE区块链有一个主网“Daphne（ダフネ）chainhttps://docs-blockchain.line.biz/ja/overview/?id=structure)”和一个测试网“[Cashew（カシュー） chain](https://docs-blockchain.line.biz/ja/overview/?id=structure)”，其运行方式与主网相同。首先，我们将在测试阶段使用适合于服务开发的免费Cashew chain进行开发，而在开发全面的业务和服务时，我们将使用有偿的主网。根据主网的大小，可以使用月费500美元（约50,000日元），2,500美元（约260,000日元）和4,300美元（约450,000日元）。测试网的腰果链是免费的，但是您需要首先申请使用它（它将在1天左右获得批准），因此请提前申请。使用Cashew chain，您最多可以注册100个测试帐户。LINE登录频道在开发时，我们将从为区块链服务创建LINE登录通道开始。LINE区块链dApp用户将是LINE用户，但dApp需要与BITMAX Wallet（LINE用户的钱包服务）一起使用。为此需要一个登录通道。要创建一个登录通道，您需要访问LINE开发人员门户网站“ LINE Developers ”，因此您需要一个LINE Developers帐户。拥有LINE帐户的任何人都可以注册LINE Developers帐户。访问LINE Developers后，在控制台中创建“ Providers”。提供者就像GitHub上的组织。将其视为产品名称。在LINE Developers中，我们将在Providers下为区块链服务创建一个Login通道，因此在此处创建一个任意的Providers Name。在演示中，提供者名称为“ LBD聚会”。创建提供者后，创建频道。使用LINE Developers，您还可以创建其他LINE应用程序，但是在这里，选择“创建区块链服务通道”以创建区块链通道。渠道类型为区块链服务，提供商为LBD Meetup。通道图标可以在此处注册，但在此演示中省略。接下来，将注册频道名称，但是在演示中，将其设置为“ LBD Meetup”，与提供者相同。最初，可以设置频道描述。接下来，将注册服务类别和子类别，这一次将类别设置为“餐厅/餐馆”，并将子类别设置为“咖啡馆/咖啡厅”。从下拉菜单中选择一个类别。然后指定应用程序类型。在此，根据要开发的应用程序选择“ Web应用程序”或“移动应用程序”。顺便说一句，日语版的控制台是“ Web应用程序”和“本地应用程序”，因此您可以将“移动应用程序”视为智能手机应用程序。顺便说一下，在演示中，我选择了两者都支持。电子邮件地址是开发人员的电子邮件地址。您还可以将隐私权政策和使用条款设置为选项，但在此处输入准备好的页面的URL。完成上述设置后，检查并同意三种使用条款，例如LINE官方帐户使用条款，然后按频道创建按钮以完成第一步。另外，该通道将在几秒钟内创建。之后，它将自动移至LINE Blockchain Developers的控制台，这将是下一步。通过LINE区块链开发人员控制台设置dApp接下来，通过LINE Blockchain Developers的控制台通过Web UI设置dApp。此处，在区块链上创建了服务，并创建了该服务的钱包。当dApp在区块链上进行某些操作（例如发行令牌）时，将使用此钱包。首先，选择要在“创建服务”中使用的链。指定测试网的Cashew（カシュー） chain。接下来，从下拉菜单中选择服务类别，但是在演示中将其设置为Commerce。可以从日本，日本以外的国家或两者中选择目标国家，这一次我选择了两者。此外，LINE Blockchain禁止将其用于赌博，并在此处进行确认。同意不将其用于赌博，然后按创建按钮。通过以上步骤，完成了创建服务的设置，并创建了与该服务相关的两个API密钥和API Secret参数。当dApp调用LINE Blockchain Developers API时，这些参数是必需的。重要的一点是，此后根本不会显示API Secret，因此您需要复制它并在某处做笔记。确认（批准）创建时有必要将API机密保存在安全的地方。按下确认按钮并输入API Secret以完成设置。接下来是创建钱包的工作。首先设置钱包的名称。尽管在演示中将其设置为“ Admin”，但名称可以是任何易于理解的名称。设置一个名称，然后按创建按钮以创建一个钱包地址。此电子钱包秘密也将仅显示一次，因此请记下并保留。按确认按钮，然后输入Wallet Secret以完成设置。至此，准备工作完成。服务通证的创建（发行）接下来，使用创建服务通证创建（发布）服务令牌。可以先设置通证图像，但在本演示中将其省略。我决定下一个通证名称。服务通证的名称已经在LBCC上确定，因此请在此处输入它。然后，您可以设置通证符号，但使其与令牌名称相同。随后的初始供应是指已发行的张数。在演示中，我将其设置为1000。LINE区块链中的代币在小数点后有固定位数（可以认为是小数点后的位数），因此您需要输入1000，然后再加上6位数字。 .. 换句话说，如果仅输入“ 1”，则表示“ 0.000001张”。同样在演示中，在实际输入“ 1000”之后，另外输入了“ 000000”（6位数字的“ 0”）。它似乎是持久的，但请注意，仅输入“ 1000”将得到“ 0.001000”。接下来，指定所有者钱包和收件人钱包。所有者钱包是管理此服务令牌的钱包。接收者钱包将指定将作为初始供应生成的令牌发送到哪个钱包。这次，我指定了在两种情况下先前创建的钱包管理钱包的地址。您早先写下的电子钱包机密是该规范所必需的。通过按下创建按钮并输入钱包密码，将在几秒钟内发出服务通证，并完成设置工作。在屏幕上，您可以看到已发行了名为LBCC的服务通证。然后，发布物品通证LBCR。在此处，按屏幕上相应令牌的“新建”以发出新令牌。首先，为项目令牌选择“新建”。在“创建项目通证”中，在开头选择幻想或非寓言。由于LBCR是由NFT发行的，因此请选择不匹配按钮。输入LBCR作为商品通证名称。您也可以在此处设置通证图像，但是这次将其省略。与服务令牌一样，既需要指定所有者钱包，也必须指定管理员钱包。通过按下创建按钮并输入钱包密码来发行物品令牌。这样就完成了通证设置。在屏幕上，您可以看到已发行两种类型的通证。dApp本身的开发和dApp的启动在使用控制台设置dApp之后，我们最终将开发dApp本身。但是，这次介绍了如何像开发dApp一样操作dApp。此dApp演示LINE Blockchain Coffee的设计目的是，您可以在虚拟的在线咖啡店购买一杯美洲咖啡获得200 LBCC，如果购买一杯美洲咖啡作为奖励，则可以获得1 LBCR的奖励。实际运行dApp需要进行准备。要启动dApp，请首先指定参数。在这里，传递到目前为止获得的信息，例如LINE登录通道ID，机密，API密钥，API机密和所有者钱包地址（请参阅屏幕以获取必要的参数）。其次，dApp向LINE区块链开发人员注册了回调URL，以通过LINE登录通道接收回调登录。第三，在dApp上创建一个用户，第四，在LINE Blockchain Developers中注册创建的用户。注册用户的工作仅对于测试网络是必需的。由于LINE区块链测试网中的用户数限制为100，因此环境是只有注册用户才能使用dApp。第五，提前将LBCC发送到用户的钱包，以便用户购物。这是准备工作。现在，您终于可以启动dApp。在演示中，我能够看到安全购买咖啡并获得额外奖励的操作。到目前为止，它已经在40分钟内完成。旨在引入自定义智能合约并于2021年在全球发布BITMAX钱包LINE的 那須 利将 先生再次上台谈论了LINE Blockchain所设想的未来。关于未来LINE Blockchain Developers的主要新增功能，据透露它将在2021年首先引入自定义智能合约，而BITMAX Wallet的目标也是在2021年全球发布。核心LINE区块链的主网上正在进行进一步的技术开发。我们正在对用于智能合约的虚拟机进行技术研究，改善共识算法，以及HD钱包和混合以提高隐私性。这些不会直接影响用户，但是它们使LINE Blockchain Developers和BITMAX Wallet更加易于使用。据说，自定义智能合约可以满足希望执行与功能相关联的业务逻辑的开发人员的需求，这些功能包括服务通证，NFT通证和LINE Blockchain Developers已经提供的不可匹配通证。我们计划开发新的业务逻辑，将其部署到LINE准备的虚拟机上，并准备一个使其可执行的环境。至于执行环境，我们计划使用WASM运行时并将其完全提供为沙箱。而且，与其他WASM执行环境不同，该公司提供的环境不会照原样执行WASM二进制文件，而是将其编译为要执行的机器代码并提供更好的性能。自定义智能合约目前支持Rust作为一种开发语言，但将来也将支持常用的编程语言。顺便说一下，这些在将来会被进一步研究，并会进行调整以使其更易于使用。与隐私相关的研究也在进行中该公司还透露，与隐私相关的研究正在进行中，这是整个区块链行业面临的挑战之一。他说，在PoC的研究阶段，他正在研究一种称为HD Wallet的技术，该技术使自己的地址模糊不清；而一种称为Mix的技术，使交易和地址之间的关系模糊化。HD电子钱包创建自己的子地址，并将其用作交易的发行方或目的地。由于子地址始终是从父地址创建的，因此自己可能会知道子地址，而周围的人可能不会从子地址知道谁是父地址。结果，可以确保发行交易本身的透明性，并且通过使用子地址来确保用户自己的交易历史的私密性。然后，通过进一步结合混合技术，将变得更加模糊。混合是一种技术，它收集一定数量的交易，使每个交易变成较小的交易，并使用算法将交易的发行方和目标混合在一起。例如，通过混合，混淆了A向B发送10个硬币的简单交易，包括发行者，目的地和10个硬币。顺便说一句，还有一种通过使用中央混合和KYC认证来实现可追溯性的方法。似乎也在进行这项研究。由于这些是PoC，因此无法确定它们将用于哪种服务。关于LINE区块链，正在研究一种称为VRF（可验证随机函数）的伪算法。在这些研究中，LINE区块链目前由私有区块链运营，但在将来，它不会仅由我们自己的网络完成，而是将考虑应用于财团型区块链和公链型区块链。我们正在进行研究和开发，说在这种情况下将需要这项技术。此外，他还在进行互操作性和层技术的研究。研究它是否可以应用于CBDC他还谈到了CBDC（中央银行数字货币）。那須桑 指出，每个国家的中央银行都发表了有关CBDC的声明，并且该领域正在进行两项重大研究。一个就是“批发CBDC”，这是一个CBDC，用于金融机构之间的大量结算。在日本，这是一个全銀系统，但是这些系统已经数字化，并且由于交易量大，费用通常很高。据说正在进行研究，看是否有可能通过将其转换为区块链来显着降低成本。另一个是“明细CBDC”，正在研究它作为用于日常付款的普通付款CBDC。那须桑还介绍了当前的CBDC，例如每个国家的努力。关于LINE区块链的主要网络，据说正在研究是否可以将其应用于这些CBDC。旨在为开发人员形成社区那須桑 说，这次LINE区块链开发者Meet UP是为了成为开发者社区来支持开发和交换信息的地方而举行的。将来，他希望继续开办这样的Meet UP，并成为一个可以分享各种服务介绍和成果的地方。关于为什么它是LINE区块链，他列举了能够基于LINE用户群将其提供给最终用户的优势。易用性对于用户和开发人员都是必要的因素，他强调LINE正是为此而努力的，这是重要的一点。那須桑还说，如果将LINE编写的LINK奖励计划用作激活服务的一种方式，将不胜感激。他说，将来，如果不透露区块链技术以及暴露服务和产品，那就太好了。而到了2020年，LINE区块链开发者大会的帷幕拉开了帷幕，说区块链服务的传播已经奠定了基础。大杨评论今天上班的第一天，老杨就给分享了这篇文章，看了之后相当兴奋，Line作为日本互联网的巨头，在软银入股之后，拥有更多的资料，在各个领域都有所延伸，对于区块链技术和在线支付的推动也相当的给力。 这次看LINE Blockchain的解决方案，首先解决了企业发币难的问题，其次把LINE的用户直接生成钱包地址，并通过开放平台，让企业接入，支付月费的方式来使用这样的区块链积分服务，这样直接打击了乐天，T-Point等其他的巨头，在技术上拥有了绝对的领先位置。 再则从他们自己开发的公有链平台使用RUST并参考了ETH的理念，这块和前阵子jarvis老板推荐的bitflyer的blockchain平台很类似，日本人还是希望用自己的一套技术来解决商业问题，这块LINE的解决方案还是可行的。 通过LINE的8600万会员的导入和使用，大大推进了区块链的真实落地使用场景，很让人兴奋，虽然说是挂着区块链狗肉的中心化的解决方案（龙哥评价），但是我认为这个不很DEFI的解决方案，还是很适合日本的国情的，毕竟海外用户的付费意识很强烈，而且有付费用户了，这个chain才能持续的开发下去。其他的对于国家使用的区块链技术，还有清算等，这个在自由国家都是一锅粥，就可以略过了。刚刚和任兄分享这个文章的过程，也同时获得了GMO日文稳定币在纽约获得通过的消息 https://techcrunch.com/2020/12/29/new-york-licenses-gmo-internet-to-issue-the-first-jpy-pegged-stablecoin/ ，日本和美帝走的相当近，在区块链上还是有领先优势的，中国的DCEP还有待加油，真正的落实到真实的用户场景，而不应该成为当权者的一种手段。总之，如果真正的LINE开始推广，那么真正的区块链积分在现实生活中将看到，而且能够得到普及，这个也是利好区块链的真实使用场景，为LINE点赞，为区块链技术开发者点赞。","categories":[{"name":"blockchain","slug":"blockchain","permalink":"http://yangxinqi.com/categories/blockchain/"}],"tags":[{"name":"line, blockchain","slug":"line-blockchain","permalink":"http://yangxinqi.com/tags/line-blockchain/"}]},{"title":"AWS S3配置信息","slug":"AWS-S3配置信息","date":"2020-12-14T03:12:22.000Z","updated":"2020-12-14T03:18:16.000Z","comments":true,"path":"2020/12/14/AWS-S3配置信息/","link":"","permalink":"http://yangxinqi.com/2020/12/14/AWS-S3配置信息/","excerpt":"","text":"好久没弄AWS S3了，这块的坑还是蛮多，防止忘记了，还是记下来比较好。需要关闭S3的公开访问权限，然后使用 cloudfront 来做CDN服务。记录下流程：开启IAM用户，拿到appkey, secret ，设定本账户需要S3的FullAccess访问权限，然后获取进行配置权限，关闭公开访问，cloudfront开一个服务，挂接到上面创建的s3 中即可。权限配置的部分，拿到账户的 iam进行设置，配置resource即可。以下是配置，先保存下123456789101112131415161718192021222324252627282930313233&#123; \"Version\": \"2012-10-17\", \"Statement\": [ &#123; \"Sid\": \"AddCannedAcl\", \"Effect\": \"Allow\", \"Principal\": &#123; \"AWS\": \"arn:aws:iam::3631695485**:user/******_s3\" &#125;, \"Action\": [ \"s3:PutObject\", \"s3:PutObjectAcl\" ], \"Resource\": \"arn:aws:s3:::******/*\", \"Condition\": &#123; \"StringEquals\": &#123; \"s3:x-amz-acl\": \"public-read\" &#125; &#125; &#125;, &#123; \"Sid\": \"PublicRead\", \"Effect\": \"Allow\", \"Principal\": \"*\", \"Action\": [ \"s3:GetObject\", \"s3:GetObjectVersion\" ], \"Resource\": \"arn:aws:s3:::******/*\" &#125; ]&#125;","categories":[{"name":"devops","slug":"devops","permalink":"http://yangxinqi.com/categories/devops/"}],"tags":[{"name":"awss3","slug":"awss3","permalink":"http://yangxinqi.com/tags/awss3/"}]},{"title":"每日晨读思考20201127","slug":"每日晨读思考20201127","date":"2020-11-27T01:30:24.000Z","updated":"2020-11-27T02:43:02.000Z","comments":true,"path":"2020/11/27/每日晨读思考20201127/","link":"","permalink":"http://yangxinqi.com/2020/11/27/每日晨读思考20201127/","excerpt":"晨读晨读，要养成一个习惯，每天对市场动态进行一个简要的分析，大量的媒体放出来的信息进行过滤，知道市场热点在哪里，扩展知识面，之后在养成做笔记的习惯，把这些记录到文章里面，这样是不是可以养成每天写日记的习惯，同时对当前社会，科技发生的问题，有自己独特的思考和见解，能够记录下来，也算是自己留下来的东西。晨读，用到的工具是 今日热榜 网页版，需要把自己想看的各个媒体的主要热文和最新热文，展示出来，一个主流媒体10篇文章，总共订阅大概29个媒体聚合热榜，花上30分钟，扫描下290篇文章的主要内容。 看详细内容和思考，需要在花30分钟，每天1小时在阅读上，是很关键的。","text":"晨读晨读，要养成一个习惯，每天对市场动态进行一个简要的分析，大量的媒体放出来的信息进行过滤，知道市场热点在哪里，扩展知识面，之后在养成做笔记的习惯，把这些记录到文章里面，这样是不是可以养成每天写日记的习惯，同时对当前社会，科技发生的问题，有自己独特的思考和见解，能够记录下来，也算是自己留下来的东西。晨读，用到的工具是 今日热榜 网页版，需要把自己想看的各个媒体的主要热文和最新热文，展示出来，一个主流媒体10篇文章，总共订阅大概29个媒体聚合热榜，花上30分钟，扫描下290篇文章的主要内容。 看详细内容和思考，需要在花30分钟，每天1小时在阅读上，是很关键的。我基本关注的如下：财经媒体： 格隆汇，新浪财经，富途牛牛，雪球，英为财经，第一财经商业中心，雪球今日话题政府政策： 财新网, 见闻VIP，微信24小时热文科技媒体： 36KR，虎嗅网数字货币： 链闻，星球日报，金色财经，巴比特，火星财经社交媒体： 微博热榜，新浪热点帮，微信热词，百度实时热点，知乎热榜短视频媒体： 抖音视频榜，快手实时热榜， 微信视频榜， 哔哩哔哩 全站日榜笔记M1 芯片PR， 不要依赖第三方成为自己关键创新和能力的推动者。 现在计算正在变革，软件是数据的端点，工作靠API实现。 未来，视觉和听觉界面才是关键。 机器学习将会定义未来软件功能。 全部迁移到M家族需要长达2年的时间。 现在生活在一个连线的世界，以网络的规模在移动。 业界通常采用的参数以及不再是任务级别性能表现的很好的特征了，跑分没有意义。 现在大量处理都是在CPU，图形和神经引擎以及图像信号处理器上面进行的。财商教育： 微淼商学院，长投学堂，快财学堂等，这块我在 抖音上都加上过， 轻教育模式，采用手机APP+微信课堂（小鹅通）等直播授课模式，以定制化的最终解决方案，满足学员差异化和个性化理财学习需求。 小白韭菜更好收割。 步骤是 9.9 引流课，反复卖焦虑，在兜售数千元的高价课程。 自我介绍，构建用户画像和需求痛点，在优化课程提高完课率。ETH 2.0 评论： 昨天ETH直接大跌20%，接下来来看2.0解决网络拥堵和扩容，去中心化是唯一优势。 Phase 1提供数据分片，供rollup使用。 Phase 0, 轻客户端支持，数据分片，合并，并行推进，任一模块好了，就可以推出。 二次方分片，技术不一定能够做的出来，不能实现真正分片的话，性能和1.0美元本质区别。 Layer2从ZK Rollup到Optimistc Rollup 都在部署Uniswap,Synthetix, 比现在的ETH扩容10x。 ETH是金融系统而不是软件，这块影响了ETH的价格，导致影响了ETH的整个社区。DODO PR： AMM缺点，低资金利用率，额外的风险敞口，无常损失问题。 DeFi的核心是对效益和收益简单直白的追求。资本永不闲置。 未来的一些点，DEX的专业做市商增多， 允许用户更创新，更有效简单的管理风险，定义链上做市策略，激励他们将流动性转移过来。 散户LP也遵循同样的策略。 交易员在DEFI上销售到和CEX相同的流动性深度。 Defi是个全新的游乐园，DODO和LONGHASH共同发文。中国智能电动车暴涨： 经纬将估值和对电动车行业的看法。 低利率时代逼迫投资者追逐有限的优质标的，拥挤的交易更加拥挤。 传统估值方式失效，投资判断越来越前置。 判断企业估值： 现金流，增长，风险。 都是从未来着手，所以估值思路从静态走向动态，从回顾走向前瞻。 公司可能在临界点，都在亏损，一旦突破，就会指数型增长，给资本市场带来革命性变化。 拼多多，特斯拉，SnowFlake（120倍P/S) 痘痕夸张。 对公司估值的定价权，不在公司手里，也不在VC手里，而是在市场手里，估值完全由供需决定。“好价格”以及不复存在，我们需要重新思考安全边际。 对VC来说，核心永远都在“能否投对”。 利率是一切金融资产的基准，利率一边，价格判断和估值的基础也的跟着变。 此时估值理念也要做出相应改变。 各类资产，风险排序，最底层的基石是 国库券（Treasurys). 股票不必便宜就能吸引买家，具备高增长潜力的股票，买家还会蜂拥而入。 要“增长”不要“价值”。 从市场情绪和未来走向，经纬给创业公司一些建议:1.不管大环境会不会出现动荡，现在成为头部的回报无疑比以前更高了，一个行业里的前三， 6-3-1格局。 数据笔记，市场占有率，营业收入，净利润规模，团队迭代，自己成长，打法策略思考。后疫情时代，很多行业都出现了质变的机会，而不仅仅是量变。 创业者寻找一个量变多增长，软件植入，SaaS，给企业规模带来了质变，需要快速调整。快速思考布局和行业切换，才能最终的胜利。早点拿钱，狠狠地拿钱，现在资金已经变成了一个核心竞争力。 不要过分考虑稀释，而是把融资确定性放在第一位，拿到充足的子弹，不要因为大意和错判而断粮。 资本要素排序，一，确定性，二，金额，之后才是估值和条款。要更加有立场，中美关系交恶，对中国未来的发展心里打鼓。创始人需要在更多的关键点上有更清晰的立场，不能脚踏2条船，2变市场都有好处，聚焦中国，成为市场头部，在去展望海外。现在，创始人个人全方位学习的速度，变得空前重要。 创始人有没有被身边的人脉，资金，自身的学习，格式个样的课程，输入滋养，以三个月为单元，用科学方法加外部反馈，衡量提升质量，持续成长是所有最终做大公司唯一恒大的关键点。市场瞬息万变，而人要有包容度。 我们处于一个史无前例的低利率时代，要用新的思想去面对。思考看了最后的经纬的文章，他们的公众号也是我很喜欢读的，讲的真心很实在，而且作为创业者很有收获。低利率时代，之前陈桑推荐我用公司去贷款，我给拒绝了，思想需要转变，作为公司，没有不负债的，需要加速，扩大规模和增长，就需要预支未来。对于融资拿钱，关注确定性并积极推进，之前的项目，我也很消极，这块需要提高自己的积极性，做一定的学习和心态锻炼，置之死地而后生，在多难的情况下都挺过来了，疫情期间，真心体会到难，也都挺过来了，阳光的积极心态，来面对疫情之后的世界，也是挺好的。对于更有立场，中国市场打2年，又回日本了，这块是需要坚定立场，因为时间和资源有限，市场的确定性，必须选择好，这个也是值得深入思考的问题。最后还是强调个人学习，其实每天一个小时的学习，更能够带来效果，接下来减少笔记量，多从自己的思考出发，控制好起床时间和晚上睡觉时间，最近加班状态身体又扛不住了，把握节奏，自我学习，相当关键，懂得拒绝很多事情，才是关键，钱是赚不完的，做的越多也有可能赔的越多。","categories":[{"name":"other","slug":"other","permalink":"http://yangxinqi.com/categories/other/"}],"tags":[{"name":"晨读","slug":"晨读","permalink":"http://yangxinqi.com/tags/晨读/"}]},{"title":"TDEngine学习笔记","slug":"TDEngine学习笔记","date":"2020-11-16T07:00:33.000Z","updated":"2020-11-17T03:25:14.000Z","comments":true,"path":"2020/11/16/TDEngine学习笔记/","link":"","permalink":"http://yangxinqi.com/2020/11/16/TDEngine学习笔记/","excerpt":"前言对于TDEngine从2019年4月，团队就在开始研究，场景是需要获取大量的交易所数据，但是之前使用的influxdb和elasticsearch在同时并发写入大量的ohlcv数据的时候，卡死了，我们一直在寻找好的存储引擎来替代这个大量并发写入和能够进行实时计算的解决方案。 正好这时候TDEngine开源并且发布了1.6x版本，看解决场景中，也有部分金融场景，所以本次我特别针对金融场景下TDEngine的使用，进行了记录，虽然TDengine主要是用在IoT方向上，但是我感觉金融方向更需要一个强大的时序数据库来解决存储和计算的问题。作为深入学习TDEngine的过程，本次，从白皮书，到代码，到编译安装以及到实战场景下，来对TDEngine进行深入的了解和试用。","text":"前言对于TDEngine从2019年4月，团队就在开始研究，场景是需要获取大量的交易所数据，但是之前使用的influxdb和elasticsearch在同时并发写入大量的ohlcv数据的时候，卡死了，我们一直在寻找好的存储引擎来替代这个大量并发写入和能够进行实时计算的解决方案。 正好这时候TDEngine开源并且发布了1.6x版本，看解决场景中，也有部分金融场景，所以本次我特别针对金融场景下TDEngine的使用，进行了记录，虽然TDengine主要是用在IoT方向上，但是我感觉金融方向更需要一个强大的时序数据库来解决存储和计算的问题。作为深入学习TDEngine的过程，本次，从白皮书，到代码，到编译安装以及到实战场景下，来对TDEngine进行深入的了解和试用。读文档大数据场景主要问题及解决方案大数据时代的挑战，源源不断的产生海量的实时数据发往云端。 这些数据是企业的宝贵财富，帮助企业实时监控业务或设备运行情况，生成各种报表，通过大数据分析和机器学习，对业务进行预测和预警，帮助企业进行科学决策，节约成本并创造新的价值。不管是IoT还是金融交易系统，所产生的数据都是时序的，很多带有位置信息。 有明显的特征如下：数据是时序的，一定带有时间戳数据是结构化的数据极少的更新或删除无需传统的数据库的事务处理互联网应用写多读少用户公主一段时间的趋势，而不是某一特定时间点的值数据是有保存期限的数据查询分析一定是基于时间段和位置区域的。存储查询外，还需要各种统计和实时计算数据量大，每天采集超过100亿条。TDEngine解决的问题：10X以上的性能提升： 定义创新数据存储，单核每秒就处理2万次请求，插入数百万个数据点，读一千万以上数据点，是现有通用数据库的10倍以上。硬件或云服务成本降低1/5: 不到通用大数据存储方案的1/5，通过列式存储和先进的压缩算法，存储空间不到通用数据库的1/10.全栈时序数据处理引擎： 将数据库，消息队列，缓存和流式计算等功能融合，降低开发和维护成本。强大的分析功能： 时间范围查询，数据在时间轴和多个维度进行聚合，通过多客户端查询。 并于第三方工具无缝集成。零运维成本，零学习成本： 安装集群，快速搞定，无需分库分表，实时备份。 标准SQL，支持多客户端，类似MYSQL，零学习成本。对于传统的网络爬虫，微博，微信，电商，DRP，CRM等通用类型数据，不适合用TDEngine来存储。数据模型采用关系数据库模型，通过创建多个库表。 但是有显著不同点。一个数据采集点一张表： 这里对应到金融上，比如一个SYMBOL，1M 的K线数据，一， 能够保证存储介质上是一块一块连续的。 读取的时候大幅减少随机操作，提高查询速度。二，不同的维度数据产生过程完全独立，数据源唯一， 一张表只有一个写入者，采用无锁方式，大幅提升写入速度。 三，对于时序数据，写的操作可用追加的方式实现，提高写入速度和查询速度。超级表：（STable）业务需要不同的维度之间聚合操作，聚合的操作也变得复杂，使用超级表，将特定类型的数据集合，同一个维度，结构是一样的，但是每个维度名字和静态属性（标签）是不一样的。 超级表用来代表一组相同类型的数据采集点， 表带有静态标签。存储结构在内存，使用SkipList建立索引，按照First In First Out的方式进行管理，在存储时，使用列式存储，提高压缩率和数据读取速度，并且每个数据块都有预计算，提高数据分析速度。数据写入WAL日志，同时回维护表索引，保证数据块在文件中的偏移量，起始时间，数据点数，压缩算法等。通过数据分区，将新旧数据分开存放，减少一盘随机读取，也能够在廉价的存储设备上有超强性能。一个表数据会按照时间段分区，不会跨节点存储，以便于单张表快速高效的插入，查询和计算。 一个节点，一秒产生100字节数据，一年才3G，压缩之后是300M，处理问题不大。分布式存储按照分布式高可靠架构进行设计的，是完全去中心化的。&lt;插入图集群&gt;数据节点 dnode: 是运行实例，一个工作系统必须至少有一个数据节点，dnode包含0 to N个 vnode 虚拟节点， 0 to n个 mnode 管理节点。虚拟节点的数据以异步复制的方式进行实时同步，并实现数据最终一致性，保证在堕胎物理机上有copy，保证系统高可靠性。mnnode 存储节点运行状态及节点负载均衡以及所有的Meta data等信息， 容许多到5个多mnode来管理，无需人工干预。TAOSC负责处理应用与集群的接口交互，内嵌于JDBC，C，PYTHON，GO等连接库中，模块负责缓存元数据，插入和查询正确节点，把结果返回时，需要负责最后一级的聚合，排序，过滤等操作。数据分片，水平扩展整个系统水平扩展，手动添加和移除节点，需要人工干预，其他的系统自动完成，使用vnode设计，可以更好的支持硬件异构环境，恢复节点，裁撤节点和新增节点都可以快速迁移。高可靠性多个虚拟数据节点组成，Replication Factor &gt; 2， vnode之间通过心跳包来通知对方状态，通过连接器去获取 fqdn，保证连接的可靠。 采用Master-Slave异步复制的方式实现多个副本之间的实时数据同步，采取的是最终一致性，而不是强一致性。 当一台主机重启时，版本低的节点停止对外服务，同时进行同步流程。 同步复制的模式实现虚拟管理节点的数据同步，写的操作，只有Slave节点写入成功后，master节点才会返回成功。 Meta数据基本完全保存在哪吃，提高查询效率。 同时也会缓存在本地，高效的多表聚合先创建超级表，在以超级表为模版，创建具体表，1create table m1 (ts timestamp, pressure int, rpm int) tags (model binary(8), color binary(8))创建了STable M1 带有标签model和标签color， 在创建具体表t1.1create table t1 using m1 tags('apple', 'red')插入数据时支持多插入，查询时候，可以基于标签对STable进行聚合查询或者统计1select avg(pressure) from m1 where model='apple' interval(5m) group by color实现流程：App –&gt; taosc –&gt; mnode –&gt; dnode0, dnode1, dnoden —&gt; app先在内存中扫描数据，之后在存储中聚合数据。 最后返回给应用。实时流式计算a v g, dev, count, first, last, least squares , max, min, percentile, sum, diff, div, scale , +-*/1create table d1 as select avg(presure) from t1 interval(60s) sliding(10s)更多亮点数据订阅，本身是一个消息队列中间件。 异步插入API，大幅度提高性能。参数指标数据类型： tinyint, smallint, int ,bigint, float, double,binary, nchar, bool单记录最大长度，16K字节， 最大记录条数，仅受存储空间限制，最大表个数，仅受节点个数限制， 最大数据备份数5，单点插入速度 2万/s（单核），节点查询速度： 2000万/s （全内存情况）应用场景作为一个基础性软件，典型场景如下：设备监控， 电力行业，出行行业，通讯行业，金融行业（交易记录，存取记录，ATM，POS机监测），交通行业，石油石化，互联网， 物流行业，环境监测，军工行业，制造页， 公共安全等。安装使用了解了原理和应用，接下来到安装和具体使用的环节。","categories":[{"name":"ai","slug":"ai","permalink":"http://yangxinqi.com/categories/ai/"}],"tags":[{"name":"big data","slug":"big-data","permalink":"http://yangxinqi.com/tags/big-data/"}]},{"title":"懂得规划自己的生活","slug":"懂得规划自己的生活","date":"2020-11-13T05:36:05.000Z","updated":"2020-11-13T07:42:26.000Z","comments":true,"path":"2020/11/13/懂得规划自己的生活/","link":"","permalink":"http://yangxinqi.com/2020/11/13/懂得规划自己的生活/","excerpt":"人生需要改变，经历疫情，人的生活方式都变了。需要一些理财建议，人生需要有一些自己的理想和自己的原则，但是生活的条件不应该有太大的变化，选择是最重要的。思考快与慢，一直都想提高自己的效率做更多的事情， 但是其实很多时候，慢慢的处理，更贴近真实的生活。","text":"人生需要改变，经历疫情，人的生活方式都变了。需要一些理财建议，人生需要有一些自己的理想和自己的原则，但是生活的条件不应该有太大的变化，选择是最重要的。思考快与慢，一直都想提高自己的效率做更多的事情， 但是其实很多时候，慢慢的处理，更贴近真实的生活。一些建议自己也应该遵守一，预留12个月应急资金。 为了避免所有的债务，之后才能进行投资。 疫情改变了世界，我们不能回到过去的生活方式，特别是使用钱上面。 这次真心体会到，当缺少最基本的保障的时候，很多事情都变得没有意义了。二，尽量不用信用卡没有信用卡的日子，其实也没有什么太难的东西，尽量少用，只有少用才能避免信贷的恶性循环。三，存款会让你感觉良好生活成本越低，越容易积攒够一年开支的钱，过度透支会阻碍你实现这个目标。心态稳，才能更好的投资生活的心态更稳，不用一直担心钱的问题。这样你才能成为更好的投资者。结语不要过度使用信用卡，减少债务，直到降为零，然后在消除所有其他的债务，开源节流，之后建立起12个月的应急现金基金，作为现金缓冲，之后在把多余的钱拿来做投资，这块可以进可攻退可守。其实道理很简单，但是很多去赌一赌的亏钱的人，都是很难从这里认识这个道理的。","categories":[{"name":"other","slug":"other","permalink":"http://yangxinqi.com/categories/other/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://yangxinqi.com/tags/生活/"}]},{"title":"solidity学习笔记","slug":"solidity学习笔记","date":"2020-11-02T05:06:16.000Z","updated":"2020-11-02T06:58:48.000Z","comments":true,"path":"2020/11/02/solidity学习笔记/","link":"","permalink":"http://yangxinqi.com/2020/11/02/solidity学习笔记/","excerpt":"前言做区块链相关的创业已经有4年了，都是做ETL方面的，对于真正的合约以及Trading，其实没有真正的使用，技术就是这样，用了就会发现有意思，从最早的没有信仰，到现在的信心满满，虽然BTC的价格还是3年前BTC的价格，但是市场已经今非昔比了，从DEFI的火热，到各种POOL的出现，区块链的运营方式和目标人群都巨大的变化了。在大经济形势周期的转变下，我也从数据，转战到了DEFI，因为DEFI才是代表了未来真正的放下，大环境下，随着疫情，越来越多的政府和国家地区更深入的隔绝，对于崇尚自由的人来说，我们更应该获得真正意义上的金融自由。虽然现在Blockchain还是被美帝把持着。闲话不多说，我们开始真正的来玩转合约，合约从Ether起，也和Ether的创始团队息息相关，从V神，还有WOOD博士开始，Ether的出现也带来了Solidity和Vyper,智能合约语言，目前来看Vyper更安全，而Solidity使用更广泛，本文主要讲Solidity的开发和使用。Solidity文档： https://learnblockchain.cn/docs/solidity/introduction-to-smart-contracts.html","text":"前言做区块链相关的创业已经有4年了，都是做ETL方面的，对于真正的合约以及Trading，其实没有真正的使用，技术就是这样，用了就会发现有意思，从最早的没有信仰，到现在的信心满满，虽然BTC的价格还是3年前BTC的价格，但是市场已经今非昔比了，从DEFI的火热，到各种POOL的出现，区块链的运营方式和目标人群都巨大的变化了。在大经济形势周期的转变下，我也从数据，转战到了DEFI，因为DEFI才是代表了未来真正的放下，大环境下，随着疫情，越来越多的政府和国家地区更深入的隔绝，对于崇尚自由的人来说，我们更应该获得真正意义上的金融自由。虽然现在Blockchain还是被美帝把持着。闲话不多说，我们开始真正的来玩转合约，合约从Ether起，也和Ether的创始团队息息相关，从V神，还有WOOD博士开始，Ether的出现也带来了Solidity和Vyper,智能合约语言，目前来看Vyper更安全，而Solidity使用更广泛，本文主要讲Solidity的开发和使用。Solidity文档： https://learnblockchain.cn/docs/solidity/introduction-to-smart-contracts.html正文Solidity语法Solidity 是一门面向合约的、为实现智能合约而创建的高级编程语言。这门语言受到了 C++，Python 和 Javascript 语言的影响，设计的目的是能在 以太坊虚拟机（EVM） 上运行。Solidity 是静态类型语言，支持继承、库和复杂的用户定义类型等特性。在部署合约时，应该尽量使用最新版本，因为新版本会有一些重大的新特性以及bug修复。1234567891011121314// SPDX-License-Identifier: GPL-3.0 pragma solidity &gt;=0.4.16 &lt;0.8.0; contract SimpleStorage &#123; uint storedData; function set(uint x) public &#123; storedData = x; &#125; function get() public view returns (uint) &#123; return storedData; &#125;&#125;pragmas（编译指令）是告知编译器如何处理源代码的指令, Solidity中合约的含义就是一组代码（它的 函数 )和数据（它的 状态 ），它们位于以太坊区块链的一个特定地址上。该合约能完成的事情并不多（由于以太坊构建的基础架构的原因）：它能允许任何人在合约中存储一个单独的数字，并且这个数字可以被世界上任何人访问，且没有可行的办法阻止你发布这个数字。当然，任何人都可以再次调用 set ，传入不同的值，覆盖你的数字，但是这个数字仍会被存储在区块链的历史记录中。随后，我们会看到怎样施加访问限制，以确保只有你才能改变这个数字。 所有的标识符（合约名称，函数名称和变量名称）都只能使用ASCII字符集。UTF-8编码的数据可以用字符串变量的形式存储。1234567891011121314151617181920212223242526272829// SPDX-License-Identifier: GPL-3.0pragma solidity &gt;0.5.99 &lt;0.8.0;contract Coin &#123; // 关键字“public”让这些变量可以从外部读取 address public minter; mapping (address =&gt; uint) public balances; // 轻客户端可以通过事件针对变化作出高效的反应 event Sent(address from, address to, uint amount); // 这是构造函数，只有当合约创建时运行 constructor() &#123; minter = msg.sender; &#125; // 铸币操作 function mint(address receiver, uint amount) public &#123; require(msg.sender == minter); require(amount &lt; 1e60); balances[receiver] += amount; &#125; // 转币操作 function send(address receiver, uint amount) public &#123; require(amount &lt;= balances[msg.sender], \"Insufficient balance.\"); balances[msg.sender] -= amount; balances[receiver] += amount; emit Sent(msg.sender, receiver, amount); &#125;&#125;address public minter; 这一行声明了一个可以被公开访问的 address 类型的状态变量。 address 类型是一个160位的值，且不允许任何算数操作。mapping (address =&gt; uint) public balances;` 也创建一个公共状态变量，但它是一个更复杂的数据类型。 该类型将address映射为无符号整数。 Mappings 可以看作是一个 哈希表 它会执行虚拟初始化，以使所有可能存在的键都映射到一个字节表示为全零的值。 但是，这种类比并不太恰当，因为它既不能获得映射的所有键的列表，也不能获得所有值的列表。event Sent(address from, address to, uint amount); 这行声明了一个所谓的“事件（event）”，它会在 send 函数的最后一行被发出。对于程序员来说，区块链这个概念并不难理解，这是因为大多数难懂的东西 (挖矿, 哈希 ，椭圆曲线密码学 ，点对点网络（P2P） 等) 都只是用于提供特定的功能和承诺。区块，交易，事务区块链是全球共享的事务性数据库，这意味着每个人都可加入网络来阅读数据库中的记录。如果你想改变数据库中的某些东西，你必须创建一个被所有其他人所接受的事务。此外，交易总是由发送人（创建者）签名。在比特币中，要解决的一个主要难题，被称为“双花攻击 (double-spend attack)”：如果网络存在两笔交易，都想花光同一个账户的钱时（即所谓的冲突）会发生什么情况？交易互相冲突？以太仿虚拟机EVM以太坊虚拟机 EVM 是智能合约的运行环境。它不仅是沙盒封装的，而且是完全隔离的，也就是说在 EVM 中运行代码是无法访问网络、文件系统和其他进程的。甚至智能合约之间的访问也是受限的。以太坊中有两类账户（它们共用同一个地址空间）： 外部账户 由公钥-私钥对（也就是人）控制； 合约账户 由和账户一起存储的代码控制.每个账户都有一个键值对形式的持久化存储。其中 key 和 value 的长度都是256位，我们称之为 存储 。此外，每个账户有一个以太币余额（ balance ）（单位是“Wei”, 1 ether 是 10**18 wei），余额会因为发送包含以太币的交易而改变。交易可以看作是从一个帐户发送到另一个帐户的消息（这里的账户，可能是相同的或特殊的零帐户，请参阅下文）。它能包含一个二进制数据（合约负载）和以太币。如果目标账户含有代码，此代码会被执行，并以 payload 作为入参。如果目标账户是零账户（账户地址为 0 )，此交易将创建一个 新合约 。 如前文所述，合约的地址不是零地址，而是通过合约创建者的地址和从该地址发出过的交易数量计算得到的（所谓的“nonce”）。 这个用来创建合约的交易的 payload 会被转换为 EVM 字节码并执行。执行的输出将作为合约代码被永久存储。这意味着，为创建一个合约，你不需要发送实际的合约代码，而是发送能够产生合约代码的代码。一经创建，每笔交易都收取一定数量的 gas ，目的是限制执行交易所需要的工作量和为交易支付手续费。EVM 执行交易时，gas 将按特定规则逐渐耗尽。gas price 是交易发送者设置的一个值，发送者账户需要预付的手续费= gas_price * gas 。如果交易执行后还有剩余， gas 会原路返还。无论执行到什么位置，一旦 gas 被耗尽（比如降为负值），将会触发一个 out-of-gas 异常。当前调用帧（call frame）所做的所有状态修改都将被回滚。译者注：调用帧（call frame），指的是下文讲到的EVM的运行栈（stack）中当前操作所需要的若干元素。每个账户有一块持久化内存区称为 存储 。 存储是将256位字映射到256位字的键值存储区。 在合约中枚举存储是不可能的，且读存储的相对开销很高，修改存储的开销甚至更高。合约只能读写存储区内属于自己的部分。第二个内存区称为 内存 ，合约会试图为每一次消息调用获取一块被重新擦拭干净的内存实例。 内存是线性的，可按字节级寻址，但读的长度被限制为256位，而写的长度可以是8位或256位。当访问（无论是读还是写）之前从未访问过的内存字（word）时（无论是偏移到该字内的任何位置），内存将按字进行扩展（每个字是256位）。扩容也将消耗一定的gas。 随着内存使用量的增长，其费用也会增高（以平方级别）。EVM 不是基于寄存器的，而是基于栈的，因此所有的计算都在一个被称为 栈（stack） 的区域执行。 栈最大有1024个元素，每个元素长度是一个字（256位）。对栈的访问只限于其顶端，限制方式为：允许拷贝最顶端的16个元素中的一个到栈顶，或者是交换栈顶元素和下面16个元素中的一个。所有其他操作都只能取最顶的两个（或一个，或更多，取决于具体的操作）元素，运算后，把结果压入栈顶。当然可以把栈上的元素放到存储或内存中。但是无法只访问栈上指定深度的那个元素，除非先从栈顶移除其他元素。EVM的指令集量应尽量少，以最大限度地避免可能导致共识问题的错误实现。所有的指令都是针对”256位的字（word）”这个基本的数据类型来进行操作。具备常用的算术、位、逻辑和比较操作。也可以做到有条件和无条件跳转。此外，合约可以访问当前区块的相关属性，比如它的编号和时间戳。有一种特殊类型的消息调用，被称为 委托调用(delegatecall) 。它和一般的消息调用的区别在于，目标地址的代码将在发起调用的合约的上下文中执行，并且 msg.sender 和 msg.value 不变。 这意味着一个合约可以在运行时从另外一个地址动态加载代码。存储、当前地址和余额都指向发起调用的合约，只有代码是从被调用地址获取的。 这使得 Solidity 可以实现”库“能力：可复用的代码库可以放在一个合约的存储上，如用来实现复杂的数据结构的库。有一种特殊的可索引的数据结构，其存储的数据可以一路映射直到区块层级。这个特性被称为 日志(logs) ，Solidity用它来实现 事件(events) 。合约创建之后就无法访问日志数据，但是这些数据可以从区块链外高效的访问。因为部分日志数据被存储在 布隆过滤器（Bloom filter) 中，我们可以高效并且加密安全地搜索日志，所以那些没有下载整个区块链的网络节点（轻客户端）也可以找到这些日志。合约代码从区块链上移除的唯一方式是合约在合约地址上的执行自毁操作 selfdestruct 。合约账户上剩余的以太币会发送给指定的目标，然后其存储和代码从状态中被移除。移除一个合约听上去不错，但其实有潜在的危险，如果有人发送以太币到移除的合约，这些以太币将永远提丢失。安装Solidity1234567891011### 最常用的还是通过nodejs来安装npm install -g solcdocker run ethereum/solc:stable solc --versionsudo add-apt-repository ppa:ethereum/ethereumsudo apt-get updatesudo apt-get install solc## 从源码安装sudo xcodebuild -license acceptSolidity源文件结构源文件中可以包含任意多个 合约定义 、导入源文件指令 、 版本标识 指令、 结构体 , 枚举 和 函数 定义.1pragma solidity ^0.5.2;这样，源文件将既不允许低于 0.5.2 版本的编译器编译， 也不允许高于（包含） 0.6.0 版本的编译器编译（第二个条件因使用 ^ 被添加）。 这种做法的考虑是，编译器在 0.6.0 版本之前不会有重大变更，所以可确保源代码始终按预期被编译。 上面例子中不固定编译器的具体版本号，因此编译器的补丁版也可以使用。Pragma 是 pragmatic information 的简称，微软 Visual C++ 文档 中译为标识。 Solidity 中沿用 C ，C++ 等中的编译指令概念，用于告知编译器 如何 编译。 ——译者注第2个标注是用来标注实验性阶段的功能，它可以用来启用一些新的编译器功能或语法特性。 当前支持下面的一些实验性标注: ABIEncoderV2新的 ABI 编码器可以用来编码和解码嵌套的数组和结构体，当然这部分代码还在优化之中，他没有像之前 ABI 编码器 那样经过严格的测试，我们可以使用下面的语法来启用它1pragma experimental ABIEncoderV2;1import \"filename\";ES6 即 ECMAScript 6.0，ES6是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布。 ——译者注通常使用相对引用 import &quot;./filename.sol&quot;; 并且避免使用 .. ，后面这种方式可以使用全局路径并设置映射，下面会有解释。可以使用单行注释（//）和多行注释（/*...*/）在 Solidity 语言中，合约类似于其他面向对象编程语言中的类。每个合约中可以包含 状态变量、 函数、事件 Event、 结构体、 和 枚举类型 的声明，且合约可以从其他合约继承。还有一些特殊的合约，如： 库 和 接口.123456pragma solidity &gt;=0.4.0 &lt;0.8.0;contract TinyStorage &#123; uint storedXlbData; // 状态变量 // ...&#125;12345678910111213// SPDX-License-Identifier: GPL-3.0pragma solidity &gt;0.7.0 &lt;0.8.0;contract TinyAuction &#123; function Mybid() public payable &#123; // 定义函数 // ... &#125;&#125;// Helper function defined outside of a contractfunction helper(uint x) pure returns (uint) &#123; return x * 2;&#125;1234567891011121314151617pragma solidity &gt;=0.4.22 &lt;0.8.0;contract MyPurchase &#123; address public seller; modifier onlySeller() &#123; // 修改器 require( msg.sender == seller, \"Only seller can call this.\" ); _; &#125; function abort() public onlySeller &#123; // 修改器用法 // ... &#125;&#125;函数 修改器modifier 可以用来以声明的方式修改函数语义（参阅合约章节中 函数修改器）。123456789pragma solidity &gt;=0.4.21 &lt;0.8.0;contract TinyAuction &#123; event HighestBidIncreased(address bidder, uint amount); // 事件 function bid() public payable &#123; // ... emit HighestBidIncreased(msg.sender, msg.value); // 触发事件 &#125;&#125;事件是能方便地调用以太坊虚拟机日志功能的接口。12345678910pragma solidity &gt;=0.4.0 &lt;0.8.0;contract TinyBallot &#123; struct Voter &#123; // 结构体 结构体是可以将几个变量分组的自定义类型 uint weight; bool voted; address delegate; uint vote; &#125;&#125;12345pragma solidity &gt;=0.4.0 &lt;0.8.0;contract Upchain &#123; enum State &#123; Created, Locked, InValid &#125; // 枚举 枚举可用来创建由一定数量的“常量值”构成的自定义类型&#125;值类型bool ：可能的取值为字面常量值 true 和 false 。运算符：! （逻辑非）&amp;&amp; （逻辑与， “and” ）|| （逻辑或， “or” ）== （等于）!= （不等于）运算符 || 和 &amp;&amp; 都遵循同样的短路（ short-circuiting ）规则。就是说在表达式 f(x) || g(y) 中， 如果 f(x) 的值为 true ，那么 g(y) 就不会被执行，即使会出现一些副作用。int / uint ：分别表示有符号和无符号的不同位数的整型变量。 支持关键字 uint8 到 uint256 （无符号，从 8 位到 256 位）以及 int8 到 int256，以 8 位为步长递增。 uint 和 int 分别是 uint256 和 int256 的别名。运算符：比较运算符： &lt;= ， &lt; ， == ， != ， &gt;= ， &gt; （返回布尔值）位运算符： &amp; ， | ， ^ （异或）， ~ （位取反）移位运算符： &lt;&lt; （左移位） ， &gt;&gt; （右移位）算数运算符： + ， - ， 一元运算 - ， 一元运算 + ， * ， / ， % （取余或叫模运算） ， ** （幂）对于整形 X，可以使用 type(X).min 和 type(X).max 去获取这个类型的最小值与最大值。加法，减法和乘法具有通常的语义，值用两进制补码表示，意思是比如：uint256（0） - uint256（1）== 2 ** 256 - 1 。 我们在设计和编写智能合约时必须考虑到溢出问题。表达式 -x 相当于 (T(0) - x) 这里 T 是指 x 的类型。 这意味着如果 x 的类型的类型是无符号整数类型 -x 不会是负数。 另外，如果 x 为负数， -x 也可以为正数。 由于两进制补码表示还需要小心:除法运算结果的类型始终是其中一个操作数的类型，整数除法总是产生整数。 在Solidity中，分数会取零。 这意味着 int256(-5) / int256(2) == int256(-2)注意在智能合约中，在 字面常量 上进行除法会保留精度（保留小数位）。除以0 会发生错误（assert 类型错误）。模运算 a％n 是在操作数 a 的除以 n 之后产生余数 r ，其中 q = int(a / n) 和 r = a - (n * q) 。 这意味着模运算结果与左操作数相同的符号相同（或零）。 对于 负数的a : a % n == -(a % n)， 几个例子：int256(5) % int256(2) == int256(1)int256(5) % int256(-2) == int256(1)int256(-5) % int256(2) == int256(-1)int256(-5) % int256(-2) == int256(-1)注解, 对0取模会发生错误（assert 类型错误）。注意 `00在EVM中定义为1` 。**fixed / ufixed：表示各种大小的有符号和无符号的定长浮点型。 在关键字 ufixedMxN 和 fixedMxN 中，M 表示该类型占用的位数，N 表示可用的小数位数。 M 必须能整除 8，即 8 到 256 位。 N 则可以是从 0 到 80 之间的任意数。 ufixed 和 fixed 分别是 ufixed128x19 和 fixed128x19 的别名。地址类型有两种形式，他们大致相同：address：保存一个20字节的值（以太坊地址的大小）。ddress payable ：可支付地址，与 address 相同，不过有成员函数 transfer 和 send 。这种区别背后的思想是 address payable 可以接受以太币的地址，而一个普通的 address 则不能。可以使用 balance 属性来查询一个地址的余额， 也可以使用 transfer 函数向一个可支付地址（payable address）发送 以太币Ether （以 wei 为单位）：123address x = 0x123;address myAddress = this;if (x.balance &lt; 10 &amp;&amp; myAddress.balance &gt;= 10) x.transfer(10);如果当前合约的余额不够多，则 transfer 函数会执行失败，或者如果以太转移被接收帐户拒绝， transfer 函数同样会失败而进行回退。如果 x 是一个合约地址，它的代码（更具体来说是, 如果有receive函数, 执行 receive 接收以太函数, 或者存在fallback函数,执行 Fallback 回退函数 函数）会跟 transfer 函数调用一起执行（这是 EVM 的一个特性，无法阻止）。 如果在执行过程中用光了 gas 或者因为任何原因执行失败，以太币Ether 交易会被打回，当前的合约也会在终止的同时抛出异常。12警告⚠️：在使用 send 的时候会有些风险：如果调用栈深度是 1024 会导致发送失败（这总是可以被调用者强制），如果接收者用光了 gas 也会导致发送失败。 所以为了保证 以太币Ether 发送的安全，一定要检查 send 的返回值，使用 transfer 或者更好的办法： 使用接收者自己取回资金的模式。1234567bytes memory payload = abi.encodeWithSignature(\"register(string)\", \"MyName\");(bool success, bytes memory returnData) = address(nameReg).call(payload);require(success);address nameReg = 0x72ba7d8e73fe8eb666ea66babc8116a41bfb10e2;nameReg.call(\"register\", \"MyName\");nameReg.call(bytes4(keccak256(\"fun(uint256)\")), a);所有这些函数都是低级函数，应谨慎使用。 具体来说，任何未知的合约都可能是恶意的，我们在调用一个合约的同时就将控制权交给了它，而合约又可以回调合约，所以要准备好在调用返回时改变相应的状态变量（可参考 可重入 )， 与其他合约交互的常规方法是在合约对象上调用函数（x.f()）。所有三个函数 call ，delegatecall 和 staticcall 都是非常低级的函数，应该只把它们当作 最后一招 来使用，因为它们破坏了 Solidity 的类型安全性。123456uint128 a = 1;uint128 b = 2.5 + a + 0.5;bytes32 samevar = \"stringliteral\";string memory a = unicode\"Hello 😃\";hex\"0011223344556677\"123456789101112131415161718192021222324// SPDX-License-Identifier: GPL-3.0pragma solidity &gt;=0.4.16 &lt;0.8.0;contract test &#123; enum ActionChoices &#123; GoLeft, GoRight, GoStraight, SitStill &#125; ActionChoices choice; ActionChoices constant defaultChoice = ActionChoices.GoStraight; function setGoStraight() public &#123; choice = ActionChoices.GoStraight; &#125; // 由于枚举类型不属于 |ABI| 的一部分，因此对于所有来自 Solidity 外部的调用， // \"getChoice\" 的签名会自动被改成 \"getChoice() returns (uint8)\"。 // 整数类型的大小已经足够存储所有枚举类型的值，随着值的个数增加， // 可以逐渐使用 `uint16` 或更大的整数类型。 function getChoice() public view returns (ActionChoices) &#123; return choice; &#125; function getDefaultChoice() public pure returns (uint) &#123; return uint(defaultChoice); &#125;&#125;1function (&lt;parameter types&gt;) &#123;internal|external&#125; [pure|constant|view|payable] [returns (&lt;return types&gt;)]内存memory 即数据在内存中，因此数据仅在其生命周期内（函数调用期间）有效。不能用于外部调用。存储storage 状态变量保存的位置，只要合约存在就一直存储．调用数据calldata 用来保存函数参数的特殊数据位置，是一个只读位置。12345678910111213141516171819202122232425262728// SPDX-License-Identifier: GPL-3.0pragma solidity &gt;=0.5.0 &lt;0.8.0;contract Tiny &#123; uint[] x; // x 的数据存储位置是 storage， 位置可以忽略 // memoryArray 的数据存储位置是 memory function f(uint[] memory memoryArray) public &#123; x = memoryArray; // 将整个数组拷贝到 storage 中，可行 uint[] storage y = x; // 分配一个指针（其中 y 的数据存储位置是 storage），可行 y[7]; // 返回第 8 个元素，可行 y.pop(); // 通过 y 修改 x，可行 delete x; // 清除数组，同时修改 y，可行 // 下面的就不可行了；需要在 storage 中创建新的未命名的临时数组， // 但 storage 是“静态”分配的： // y = memoryArray; // 下面这一行也不可行，因为这会“重置”指针， // 但并没有可以让它指向的合适的存储位置。 // delete y; g(x); // 调用 g 函数，同时移交对 x 的引用 h(x); // 调用 h 函数，同时在 memory 中创建一个独立的临时拷贝 &#125; function g(uint[] storage ) internal pure &#123;&#125; function h(uint[] memory) public pure &#123;&#125;&#125;12345678910111213141516171819202122232425262728pragma solidity &gt;=0.6.99 &lt;0.8.0;contract Proxy &#123; /// 被当前合约管理的 客户端合约地址 address client; constructor(address _client) &#123; client = _client; &#125; /// 在进行参数验证之后，转发到由client实现的 \"setOwner(address)\" function forward(bytes calldata _payload) external &#123; // 由于 ABI 解码要求填充的数据（padded data）不能使用 // abi.decode(_payload[:4], (bytes4)). bytes4 sig = _payload[0] | (bytes4(_payload[1]) &gt;&gt; 8) | (bytes4(_payload[2]) &gt;&gt; 16) | (bytes4(_payload[3]) &gt;&gt; 24); if (sig == bytes4(keccak256(\"setOwner(address)\"))) &#123; address owner = abi.decode(_payload[4:], (address)); require(owner != address(0), \"Address of owner cannot be zero.\"); &#125; (bool status,) = client.delegatecall(_payload); require(status, \"Forwarded call failed.\"); &#125;&#125;123456789101112131415161718// SPDX-License-Identifier: GPL-3.0pragma solidity &gt;=0.4.0 &lt;0.8.0;contract MappingExample &#123; mapping(address =&gt; uint) public balances; function update(uint newBalance) public &#123; balances[msg.sender] = newBalance; &#125;&#125;contract MappingLBC &#123; function f() public returns (uint) &#123; MappingExample m = new MappingExample(); m.update(100); return m.balances(this); &#125;&#125;123456789101112131415161718192021222324252627282930313233343536373839// SPDX-License-Identifier: GPL-3.0pragma solidity &gt;=0.4.22 &lt;0.8.0;contract MappingExample &#123; mapping (address =&gt; uint256) private _balances; mapping (address =&gt; mapping (address =&gt; uint256)) private _allowances; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function allowance(address owner, address spender) public view returns (uint256) &#123; return _allowances[owner][spender]; &#125; function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) &#123; _transfer(sender, recipient, amount); approve(sender, msg.sender, amount); return true; &#125; function approve(address owner, address spender, uint256 amount) public returns (bool) &#123; require(owner != address(0), \"ERC20: approve from the zero address\"); require(spender != address(0), \"ERC20: approve to the zero address\"); _allowances[owner][spender] = amount; emit Approval(owner, spender, amount); return true; &#125; function _transfer(address sender, address recipient, uint256 amount) internal &#123; require(sender != address(0), \"ERC20: transfer from the zero address\"); require(recipient != address(0), \"ERC20: transfer to the zero address\"); _balances[sender] -= amount; _balances[recipient] += amount; emit Transfer(sender, recipient, amount); &#125;&#125;12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091// SPDX-License-Identifier: GPL-3.0pragma solidity &gt;=0.6.0 &lt;0.8.0;struct IndexValue &#123; uint keyIndex; uint value; &#125;struct KeyFlag &#123; uint key; bool deleted; &#125;struct itmap &#123; mapping(uint =&gt; IndexValue) data; KeyFlag[] keys; uint size;&#125;library IterableMapping &#123; function insert(itmap storage self, uint key, uint value) internal returns (bool replaced) &#123; uint keyIndex = self.data[key].keyIndex; self.data[key].value = value; if (keyIndex &gt; 0) return true; else &#123; keyIndex = self.keys.length; self.keys.push(); self.data[key].keyIndex = keyIndex + 1; self.keys[keyIndex].key = key; self.size++; return false; &#125; &#125; function remove(itmap storage self, uint key) internal returns (bool success) &#123; uint keyIndex = self.data[key].keyIndex; if (keyIndex == 0) return false; delete self.data[key]; self.keys[keyIndex - 1].deleted = true; self.size --; &#125; function contains(itmap storage self, uint key) internal view returns (bool) &#123; return self.data[key].keyIndex &gt; 0; &#125; function iterate_start(itmap storage self) internal view returns (uint keyIndex) &#123; return iterate_next(self, uint(-1)); &#125; function iterate_valid(itmap storage self, uint keyIndex) internal view returns (bool) &#123; return keyIndex &lt; self.keys.length; &#125; function iterate_next(itmap storage self, uint keyIndex) internal view returns (uint r_keyIndex) &#123; keyIndex++; while (keyIndex &lt; self.keys.length &amp;&amp; self.keys[keyIndex].deleted) keyIndex++; return keyIndex; &#125; function iterate_get(itmap storage self, uint keyIndex) internal view returns (uint key, uint value) &#123; key = self.keys[keyIndex].key; value = self.data[key].value; &#125;&#125;// 如何使用contract User &#123; // Just a struct holding our data. itmap data; // Apply library functions to the data type. using IterableMapping for itmap; // Insert something function insert(uint k, uint v) public returns (uint size) &#123; // This calls IterableMapping.insert(data, k, v) data.insert(k, v); // We can still access members of the struct, // but we should take care not to mess with them. return data.size; &#125; // Computes the sum of all stored data. function sum() public view returns (uint s) &#123; for ( uint i = data.iterate_start(); data.iterate_valid(i); i = data.iterate_next(i) ) &#123; (, uint value) = data.iterate_get(i); s += value; &#125; &#125;&#125;映射本身是无法遍历的，即无法枚举所有的键。不过，可以在它们之上实现一个数据结构来进行迭代。 例如，以下代码实现了 IterableMapping 库，然后 User 合约可以添加数据， sum 函数迭代求和所有值。12345678910111213141516171819// SPDX-License-Identifier: GPL-3.0pragma solidity &gt;=0.4.0 &lt;0.8.0;contract DeleteLBC &#123; uint data; uint[] dataArray; function f() public &#123; uint x = data; delete x; // 将 x 设为 0，并不影响数据 delete data; // 将 data 设为 0，并不影响 x，因为它仍然有个副本 uint[] storage y = dataArray; delete dataArray; // 将 dataArray.length 设为 0，但由于 uint[] 是一个复杂的对象，y 也将受到影响， // 因为它是一个存储位置是 storage 的对象的别名。 // 另一方面：\"delete y\" 是非法的，引用了 storage 对象的局部变量只能由已有的 storage 对象赋值。 assert(y.length == 0); &#125;&#125;12345678910uint8 y;uint16 z;uint32 x = y + z;int8 y = -3;uint x = uint(y);uint32 a = 0x12345678;uint16 b = uint16(a); // 此时 b 的值是 0x5678uint16 a = 0x1234;uint32 b = uint32(a); // b 为 0x00001234 nowassert(a == b);单位和全局变量以太币Ether 单位之间的换算就是在数字后边加上 wei、gwei 或 ether 来实现的，如果后面没有单位，缺省为 wei。例如 2 ether == 2000 finney 的逻辑判断值为 true。123assert(1 wei == 1);assert(1 gwei == 1e9);assert(1 ether == 1e18);这些后缀不能直接用在变量后边。如果想用时间单位（例如 days）来将输入变量换算为时间，你可以用如下方式来完成：12345678910111 == 1 seconds1 minutes == 60 seconds1 hours == 60 minutes1 days == 24 hours1 weeks == 7 daysfunction f(uint start, uint daysAfter) public &#123; if (block.timestamp &gt;= start + daysAfter * 1 days) &#123; // ... &#125;&#125;1这些编码函数可以用来构造函数调用数据，而不用实际进行调用。此外，keccak256(abi.encodePacked(a, b)) 是一种计算结构化数据的哈希值（尽管我们也应该关注到：使用不同的函数参数类型也有可能会引起“哈希冲突” ）的方式，不推荐使用的 keccak256(a, b) 。错误处理可以参阅专门的章节 assert and require 参阅有关错误处理以及何时使用哪个函数的更多详细信息。assert(bool condition)如果不满足条件，则会导致无效的操作码，则撤销状态更改 - 用于检查内部错误。require(bool condition)如果条件不满足则撤销状态更改 - 用于检查由输入或者外部组件引起的错误。require(bool condition, string memory message)如果条件不满足则撤销状态更改 - 用于检查由输入或者外部组件引起的错误，可以同时提供一个错误消息。revert()终止运行并撤销状态更改。revert(string memory reason)终止运行并撤销状态更改，可以同时提供一个解释性的字符串。123456789101112131415161718pragma solidity &gt;=0.5.0 &lt;0.8.0;contract C &#123; uint index; function f() public pure returns (uint, bool, uint) &#123; return (7, true, 2); &#125; function g() public &#123; //基于返回的元组来声明变量并赋值 (uint x, bool b, uint y) = f(); //交换两个值的通用窍门——但不适用于非值类型的存储 (storage) 变量。 (x, y) = (y, x); //元组的末尾元素可以省略（这也适用于变量声明）。 (index,,) = f(); // 设置 index 为 7 &#125;&#125;123456789101112pragma solidity &gt;=0.5.0 &lt;0.8.0;contract Sharer &#123; function sendHalf(address addr) public payable returns (uint balance) &#123; require(msg.value % 2 == 0, \"Even value required.\"); uint balanceBeforeTransfer = this.balance; addr.transfer(msg.value / 2); //由于转移函数在失败时抛出异常并且不能在这里回调，因此我们应该没有办法仍然有一半的钱。 assert(this.balance == balanceBeforeTransfer - msg.value / 2); return this.balance; &#125;&#125;在内部， Solidity 对一个 require 式的异常执行回退操作（指令 0xfd ）并执行一个无效操作（指令 0xfe ）来引发 assert 式异常。 在这两种情况下，都会导致 EVM 回退对状态所做的所有更改。回退的原因是不能继续安全地执行，因为没有实现预期的效果。在这两种情况下，调用者都可以使用 try/catch 来应对此类失败（在assert类型的异常中,仅在剩余足够gas的情况下才行 ），但是调用者中的更改将始终被还原。请注意， assert 式异常消耗了所有可用的调用 gas ，而从 Metropolis 版本起 require 式的异常不会消耗任何 gas。 这里还是尽量使用require.合约Solidity 合约类似于面向对象语言中的类。合约中有用于数据持久化的状态变量，和可以修改状态变量的函数。 调用另一个合约实例的函数时，会执行一个 EVM 函数调用，这个操作会切换执行时的上下文，这样，前一个合约的状态变量就不能访问了。可以通过以太坊交易“从外部”或从 Solidity 合约内部创建合约。一些集成开发环境，例如 Remix, 通过使用一些UI用户界面使创建合约的过程更加顺畅。 在以太坊上通过编程创建合约最好使用 JavaScript API web3.js。 现在，我们已经有了一个叫做 web3.eth.Contract 的方法能够更容易的创建合约。创建合约时， 合约的 构造函数 (一个用关键字 constructor 声明的函数)会执行一次。 构造函数是可选的。只允许有一个构造函数，这意味着不支持重载。构造函数执行完毕后，合约的最终代码将部署到区块链上。此代码包括所有公共和外部函数以及所有可以通过函数调用访问的函数。 部署的代码没有 包括构造函数代码或构造函数调用的内部函数。在内部，构造函数参数在合约代码之后通过 ABI 编码 传递，但是如果你使用 web3.js 则不必关心这个问题。如果一个合约想要创建另一个合约，那么创建者必须知晓被创建合约的源代码(和二进制代码)。 这意味着不可能循环创建依赖项。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465pragma solidity &gt;=0.4.22 &lt;0.8.0;contract OwnedToken &#123; // TokenCreator 是如下定义的合约类型. // 不创建新合约的话，也可以引用它。 TokenCreator creator; address owner; bytes32 name; // 这是注册 creator 和设置名称的构造函数。 constructor(bytes32 _name) &#123; // 状态变量通过其名称访问，而不是通过例如 this.owner 的方式访问。 // 这也适用于函数，特别是在构造函数中，你只能像这样（“内部地”）调用它们， // 因为合约本身还不存在。 owner = msg.sender; // 从 `address` 到 `TokenCreator` ，是做显式的类型转换 // 并且假定调用合约的类型是 TokenCreator，没有真正的方法来检查这一点。 creator = TokenCreator(msg.sender); name = _name; &#125; function changeName(bytes32 newName) public &#123; // 只有 creator （即创建当前合约的合约）能够更改名称 —— 因为合约是隐式转换为地址的， // 所以这里的比较是可行的。 if (msg.sender == address(creator)) name = newName; &#125; function transfer(address newOwner) public &#123; // 只有当前所有者才能发送 token。 if (msg.sender != owner) return; // 我们也想询问 creator 是否可以发送。 // 请注意，这里调用了一个下面定义的合约中的函数。 // 如果调用失败（比如，由于 gas 不足），会立即停止执行。 if (creator.isTokenTransferOK(owner, newOwner)) owner = newOwner; &#125;&#125;contract TokenCreator &#123; function createToken(bytes32 name) public returns (OwnedToken tokenAddress) &#123; // 创建一个新的 Token 合约并且返回它的地址。 // 从 JavaScript 方面来说，返回类型是简单的 `address` 类型，因为 // 这是在 ABI 中可用的最接近的类型。 return new OwnedToken(name); &#125; function changeName(OwnedToken tokenAddress, bytes32 name) public &#123; // 同样，`tokenAddress` 的外部类型也是 `address` 。 tokenAddress.changeName(name); &#125; function isTokenTransferOK(address currentOwner, address newOwner) public view returns (bool ok) &#123; // 检查一些任意的情况。 address tokenAddress = msg.sender; return (keccak256(newOwner) &amp; 0xff) == (bytes20(tokenAddress) &amp; 0xff); &#125;&#125;由于 Solidity 有两种函数调用（内部调用不会产生实际的 EVM 调用或称为“消息调用”，而外部调用则会产生一个 EVM 调用）， 函数和状态变量有四种可见性类型。 函数可以指定为 external ，public ，internal 或者 private。 对于状态变量，不能设置为 external ，默认是 internal 。1external外部函数作为合约接口的一部分，意味着我们可以从其他合约和交易中调用。 一个外部函数 f 不能从内部调用（即 f 不起作用，但 this.f() 可以）。 当收到大量数据的时候，外部函数有时候会更有效率，因为数据不会从calldata复制到内存.1publicpublic 函数是合约接口的一部分，可以在内部或通过消息调用。对于 public 状态变量， 会自动生成一个 getter 函数（见下面）。1internal这些函数和状态变量只能是内部访问（即从当前合约内部或从它派生的合约访问），不使用 this 调用。1privateprivate 函数和状态变量仅在当前定义它们的合约中使用，并且不能被派生合约使用。合约中的所有内容对外部观察者都是可见的。设置一些 private 类型只能阻止其他合约访问和修改这些信息， 但是对于区块链外的整个世界它仍然是可见的。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// SPDX-License-Identifier: GPL-3.0pragma solidity &gt;0.7.0 &lt;0.8.0;contract owned &#123; constructor() &#123; owner = msg.sender; &#125; address owner; // 这个合约只定义一个修改器，但并未使用： 它将会在派生合约中用到。 // 修改器所修饰的函数体会被插入到特殊符号 _; 的位置。 // 这意味着如果是 owner 调用这个函数，则函数会被执行，否则会抛出异常。 modifier onlyOwner &#123; require( msg.sender == owner, \"Only owner can call this function.\" ); _; &#125;&#125;contract destructible is owned &#123; // 这个合约从 `owned` 继承了 `onlyOwner` 修饰符，并将其应用于 `destroy` 函数， // 只有在合约里保存的 owner 调用 `destroy` 函数，才会生效。 function destroy() public onlyOwner &#123; selfdestruct(owner); &#125;&#125;contract priced &#123; // 修改器可以接收参数： modifier costs(uint price) &#123; if (msg.value &gt;= price) &#123; _; &#125; &#125;&#125;contract Register is priced, destructible &#123; mapping (address =&gt; bool) registeredAddresses; uint price; constructor(uint initialPrice) &#123; price = initialPrice; &#125; // 在这里也使用关键字 `payable` 非常重要，否则函数会自动拒绝所有发送给它的以太币。 function register() public payable costs(price) &#123; registeredAddresses[msg.sender] = true; &#125; function changePrice(uint _price) public onlyOwner &#123; price = _price; &#125;&#125;contract Mutex &#123; bool locked; modifier noReentrancy() &#123; require( !locked, \"Reentrant call.\" ); locked = true; _; locked = false; &#125; // 这个函数受互斥量保护，这意味着 `msg.sender.call` 中的重入调用不能再次调用 `f`。 // `return 7` 语句指定返回值为 7，但修改器中的语句 `locked = false` 仍会执行。 function f() public noReentrancy returns (uint) &#123; (bool success,) = msg.sender.call(\"\"); require(success); return 7; &#125;&#125;123456789101112131415161718192021// SPDX-License-Identifier: GPL-3.0pragma solidity &gt;0.6.99 &lt;0.8.0;contract C &#123; uint constant X = 32**22 + 8; string constant TEXT = \"abc\"; bytes32 constant MY_HASH = keccak256(\"abc\"); uint immutable decimals; uint immutable maxBalance; address immutable owner = msg.sender; constructor(uint _decimals, address _reference) &#123; decimals = _decimals; // Assignments to immutables can even access the environment. maxBalance = _reference.balance; &#125; function isBalanceTooHigh(address _other) public view returns (bool) &#123; return _other.balance &gt; maxBalance; &#125;&#125;如果状态变量声明为 constant (常量)。在这种情况下，只能使用那些在编译时有确定值的表达式来给它们赋值。 任何通过访问 storage，区块链数据（例如 block.timestamp, address(this).balance 或者 block.number）或执行数据（ msg.value 或 gasleft() ） 或对外部合约的调用来给它们赋值都是不允许的。允许可能对内存分配产生副作用（side-effect）的表达式，但那些可能对其他内存对象产生副作用的表达式则不允许。内建（built-in）函数 keccak256 ， sha256 ， ripemd160 ， ecrecover ， addmod 和 mulmod 是允许的（即使他们确实会调用外部合约， keccak256 除外）。允许内存分配器的副作用的原因是它可以构造复杂的对象，例如： 查找表（lookup-table）。 此功能尚不完全可用。123456789101112131415161718// SPDX-License-Identifier: GPL-3.0pragma solidity &gt;0.8.0 &lt;0.8.0;function sum(uint[] memory _arr) pure returns (uint s) &#123; for (uint i = 0; i &lt; _arr.length; i++) s += _arr[i];&#125;contract ArrayExample &#123; bool found; function f(uint[] memory _arr) public &#123; // This calls the free function internally. // The compiler will add its code to the contract. uint s = sum(_arr); require(s &gt;= 10); found = true; &#125;&#125;123456789101112131415161718192021pragma solidity &gt;=0.4.16 &lt;0.8.0;contract Simple &#123; uint sum; function taker(uint _a, uint _b) public &#123; sum = _a + _b; &#125;&#125;pragma solidity &gt;=0.4.16 &lt;0.8.0;contract Simple &#123; function arithmetic(uint _a, uint _b) public pure returns (uint o_sum, uint o_product) &#123; o_sum = _a + _b; o_product = _a * _b; &#125;&#125;1234567pragma solidity &gt;=0.5.0 &lt;0.8.0;contract C &#123; function f(uint a, uint b) public view returns (uint) &#123; return a * (b + 42) + block.timestamp; &#125;&#125;Getter 方法自动被标记为 view。constant 之前是 view 的别名，不过在0.5.0之后移除了。函数可以声明为 pure ，在这种情况下，承诺不读取也不修改状态。一个合约最多有一个 receive 函数, 声明函数为： receive() external payable { ... }不需要 function 关键字，也没有参数和返回值并且必须是 external 可见性和 payable 修饰． 在对合约没有任何附加数据调用（通常是对合约转账）是会执行 receive 函数． 例如 通过 .send() or .transfer() 如果 receive 函数不存在， 但是有payable 的 fallback 回退函数 那么在进行纯以太转账时，fallback 函数会调用．如果两个函数都没有，这个合约就没法通过常规的转账交易接收以太（会抛出异常）．更糟的是，fallback函数可能只有 2300 gas 可以使用（如，当使用 send 或 transfer 时）， 除了基础的日志输出之外，进行其他操作的余地很小。下面的操作消耗会操作 2300 gas :写入存储创建合约调用消耗大量 gas 的外部函数发送以太币一个没有定义 fallback 函数或 receive 函数的合约，直接接收以太币（没有函数调用，即使用 send 或 transfer）会抛出一个异常， 并返还以太币（在 Solidity v0.4.0 之前行为会有所不同）。 所以如果你想让你的合约接收以太币，必须实现receive函数（使用 payable fallback 函数不再推荐，因为它会让借口混淆）。 这个之前调试老版本的合约中出现过异常的情况。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152pragma solidity &gt;=0.6.2 &lt;0.8.0;contract Test &#123; // 发送到这个合约的所有消息都会调用此函数（因为该合约没有其它函数）。 // 向这个合约发送以太币会导致异常，因为 fallback 函数没有 `payable` 修饰符 fallback() external &#123; x = 1; &#125; uint x;&#125;// 这个合约会保留所有发送给它的以太币，没有办法返还。contract TestPayable &#123; // 除了纯转账外，所有的调用都会调用这个函数． // (因为除了 receive 函数外，没有其他的函数). // 任何对合约非空calldata 调用会执行回退函数(即使是调用函数附加以太). fallback() external payable &#123; x = 1; y = msg.value; &#125; // 纯转账调用这个函数，例如对每个空empty calldata的调用 receive() external payable &#123; x = 2; y = msg.value; &#125; uint x; uint y;&#125;contract Caller &#123; function callTest(Test test) public returns (bool) &#123; (bool success,) = address(test).call(abi.encodeWithSignature(\"nonExistingFunction()\")); require(success); // test.x 结果变成 == 1。 // address(test) 不允许直接调用 ``send`` , 因为 ``test`` 没有 payable 回退函数 // 转化为 ``address payable`` 类型 , 然后才可以调用 ``send`` address payable testPayable = payable(address(test)); // 以下将不会编译，但如果有人向该合约发送以太币，交易将失败并拒绝以太币。 // test.send(2 ether）; &#125; function callTestPayable(TestPayable test) public returns (bool) &#123; (bool success,) = address(test).call(abi.encodeWithSignature(\"nonExistingFunction()\")); require(success); // 结果 test.x 为 1 test.y 为 0. (success,) = address(test).call&#123;value: 1&#125;(abi.encodeWithSignature(\"nonExistingFunction()\")); require(success); // 结果test.x 为1 and test.y 为 1. // 发送以太币, TestPayable 的 receive 函数被调用． require(address(test).send(2 ether)); // 结果 in test.x 为 2 and test.y 为 2 ether. &#125;&#125;1234567891011121314var options = &#123; fromBlock: 0, address: web3.eth.defaultAccount, topics: [\"0x0000000000000000000000000000000000000000000000000000000000000000\", null, null]&#125;;web3.eth.subscribe('logs', options, function (error, result) &#123; if (!error) console.log(result);&#125;) .on(\"data\", function (log) &#123; console.log(log); &#125;) .on(\"changed\", function (log) &#123;&#125;);关于web3 subscribe的描述12345678910111213pragma solidity &gt;=0.4.10 &lt;0.8.0;contract C &#123; function f() public payable &#123; bytes32 _id = 0x420042; log3( bytes32(msg.value), bytes32(0x50cb9fe53daa9737b786ab3646f04d0150dc50ef4e75f59509d83667ad5adb20), bytes32(msg.sender), _id ); &#125;&#125;日志的底层接口123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172 // SPDX-License-Identifier: GPL-3.0 pragma solidity &gt;0.6.99 &lt;0.8.0; contract Owned &#123; constructor() public &#123; owner = msg.sender; &#125; address payable owner; &#125; // 使用 is 从另一个合约派生。派生合约可以访问所有非私有成员，包括内部（internal）函数和状态变量， // 但无法通过 this 来外部访问。 contract Destructible is Owned &#123; // 关键字`virtual`表示该函数可以在派生类中“overriding”。 function destroy() virtual public &#123; if (msg.sender == owner) selfdestruct(owner); &#125; &#125; // 这些抽象合约仅用于给编译器提供接口。 // 注意函数没有函数体。 // 如果一个合约没有实现所有函数，则只能用作接口。 abstract contract Config &#123; function lookup(uint id) public virtual returns (address adr); &#125; abstract contract NameReg &#123; function register(bytes32 name) public virtual; function unregister() public virtual; &#125; // 可以多重继承。请注意，owned 也是 Destructible 的基类， // 但只有一个 owned 实例（就像 C++ 中的虚拟继承）。 contract Named is Owned, Destructible &#123; constructor(bytes32 name) &#123; Config config = Config(0xD5f9D8D94886E70b06E474c3fB14Fd43E2f23970); NameReg(config.lookup(1)).register(name); &#125; // 函数可以被另一个具有相同名称和相同数量/类型输入的函数重载。 // 如果重载函数有不同类型的输出参数，会导致错误。 // 本地和基于消息的函数调用都会考虑这些重载。//如果要覆盖函数，则需要使用 `override` 关键字。 如果您想再次覆盖此函数，则需要再次指定`virtual`关键字。 function destroy() public virtual override &#123; if (msg.sender == owner) &#123; Config config = Config(0xD5f9D8D94886E70b06E474c3fB14Fd43E2f23970); NameReg(config.lookup(1)).unregister(); // 仍然可以调用特定的重载函数。 Destructible.destroy(); &#125; &#125; &#125; // 如果构造函数接受参数， // 则需要在声明（合约的构造函数）时提供， // 或在派生合约的构造函数位置以修改器调用风格提供（见下文）。 contract PriceFeed is Owned, Destructible, Named(\"GoldFeed\") &#123; function updateInfo(uint newInfo) public &#123; if (msg.sender == owner) info = newInfo; &#125; // Here, we only specify `override` and not `virtual`. // This means that contracts deriving from `PriceFeed` // cannot change the behaviour of `destroy` anymore. function destroy() public override(Destructible, Named) &#123; Named.destroy(); &#125; function get() public view returns(uint r) &#123; return info; &#125; uint info; &#125;父合约标记为 virtual 函数可以在继承合约里重写(overridden)以更改他们的行为。重写的函数需要使用关键字 override 修饰。重写函数只能将覆盖函数的可见性从 external 更改为 public 。可变性可以按照以下顺序更改为更严格的一种： nonpayable 可以被 view 和 pure 覆盖。 view 可以被 pure 覆盖。 payable 是一个例外，不能更改为任何其他可变性。123456789101112131415161718192021222324252627282930313233343536// SPDX-License-Identifier: GPL-3.0pragma solidity &gt;0.6.99 &lt;0.8.0;contract Base&#123; function foo() virtual external view &#123;&#125;&#125;contract Middle is Base &#123;&#125;contract Inherited is Middle&#123; function foo() override public pure &#123;&#125;&#125;pragma solidity &gt;=0.6.0 &lt;0.8.0;contract Base1&#123; function foo() virtual public &#123;&#125;&#125;contract Base2&#123; function foo() virtual public &#123;&#125;&#125;contract Inherited is Base1, Base2&#123; // 继承自两个基类合约定义的foo(), 必须显示的指定 override function foo() public override(Base1, Base2) &#123;&#125;&#125;接口类似于抽象合约，但是它们不能实现任何函数。还有进一步的限制：无法继承其他合约,不过可以继承其他接口。所有的函数都需要是 external无法定义构造函数。无法定义状态变量。将来可能会解除这里的某些限制。接口基本上基本上仅限于合约 ABI 可以表示的内容，并且 ABI 和接口之间的转换应该不会丢失任何信息。接口由它们自己的关键字表示：1234567891011121314151617181920212223pragma solidity &gt;=0.6.2 &lt;0.8.0;interface Token &#123; enum TokenType &#123; Fungible, NonFungible &#125; struct Coin &#123; string obverse; string reverse; &#125; function transfer(address recipient, uint amount) external;&#125;//-------pragma solidity &gt;=0.6.2 &lt;0.8.0;interface ParentA &#123; function test() external returns (uint256);&#125;interface ParentB &#123; function test() external returns (uint256);&#125;interface SubInterface is ParentA, ParentB &#123; // 必须重新定义 test 函数，以表示兼容父合约含义 function test() external override(ParentA, ParentB) returns (uint256);&#125;就像继承其他合约一样，合约可以继承接口。接口中的函数都会隐式的标记为 virtual ，意味着他们会被重写。 但是不表示重写（overriding）函数可以再次重写，仅仅当重写的函数标记为 virtual 才可以再次重写。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950pragma solidity &gt;=0.6.0 &lt;0.7.0; // 我们定义了一个新的结构体数据类型，用于在调用合约中保存数据。 struct Data &#123; mapping(uint =&gt; bool) flags; &#125;library Set &#123; // 注意第一个参数是“storage reference”类型，因此在调用中参数传递的只是它的存储地址而不是内容。 // 这是库函数的一个特性。如果该函数可以被视为对象的方法，则习惯称第一个参数为 `self` 。 function insert(Data storage self, uint value) public returns (bool) &#123; if (self.flags[value]) return false; // 已经存在 self.flags[value] = true; return true; &#125; function remove(Data storage self, uint value) public returns (bool) &#123; if (!self.flags[value]) return false; // 不存在 self.flags[value] = false; return true; &#125; function contains(Data storage self, uint value) public view returns (bool) &#123; return self.flags[value]; &#125;&#125;contract C &#123; Data knownValues; function register(uint value) public &#123; // 不需要库的特定实例就可以调用库函数， // 因为当前合约就是“instance”。 require(Set.insert(knownValues, value)); &#125; // 如果我们愿意，我们也可以在这个合约中直接访问 knownValues.flags。&#125;这个我们没咋个看到过合约元数据Solidity编译器自动生成JSON文件，即合约的元数据，其中包含了当前合约的相关信息。 它可以用于查询编译器版本，所使用的源代码，|ABI| 和 |natspec| 文档，以便更安全地与合约进行交互并验证其源代码。编译器会将元数据文件的 Swarm 哈希值附加到每个合约的字节码末尾（详情请参阅下文）， 以便你可以以认证的方式获取该文件，而不必求助于中心化的数据提供者。当然，你必须将元数据文件发布到 Swarm （或其他服务），以便其他人可以访问它。 该文件可以通过使用 solc --metadata 来生成，并被命名为 ContractName_meta.json 。 它将包含源代码的在 Swarm 上的引用，因此你必须上传所有源文件和元数据文件。元数据文件具有以下格式。 下面的例子将以人类可读的方式呈现。 正确格式化的元数据应正确使用引号，将空白减少到最小，并对所有对象的键值进行排序以得到唯一的格式。 代码注释当然也是不允许的，这里仅用于解释目的。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&#123; // 必选：元数据格式的版本 version: \"1\", // 必选：源代码的编程语言，一般会选择规范的“子版本” language: \"Solidity\", // 必选：编译器的细节，内容视语言而定。 compiler: &#123; // 对 Solidity 来说是必须的：编译器的版本 version: \"0.4.6+commit.2dabbdf0.Emscripten.clang\", // 可选： 生成此输出的编译器二进制文件的哈希值 keccak256: \"0x123...\" &#125;, // 必选：编译的源文件／源单位，键值为文件名 sources: &#123; \"myFile.sol\": &#123; // 必选：源文件的 keccak256 哈希值 \"keccak256\": \"0x123...\", // 必选（除非定义了“content”，详见下文）： // 已排序的源文件的URL，URL的协议可以是任意的，但建议使用 Swarm 的URL \"urls\": [ \"bzzr://56ab...\" ] // Optional: 在源文件中定义的 SPDX license 标识 \"license\": \"MIT\" &#125;, \"mortal\": &#123; // 必选：源文件的 keccak256 哈希值 \"keccak256\": \"0x234...\", // 必选（除非定义了“urls”）： 源文件的字面内容 \"content\": \"contract mortal is owned &#123; function kill() &#123; if (msg.sender == owner) selfdestruct(owner); &#125; &#125;\" &#125; &#125;, // 必选：编译器的设置 settings: &#123; // 对 Solidity 来说是必须的： 已排序的重定向列表 remappings: [ \":g/dir\" ], // 可选： 优化器的设置（ enabled 默认设为 false ） optimizer: &#123; enabled: true, runs: 500, details: &#123; // peephole defaults to \"true\" peephole: true, // jumpdestRemover defaults to \"true\" jumpdestRemover: true, orderLiterals: false, deduplicate: false, cse: false, constantOptimizer: false, yul: true, // Optional: Only present if \"yul\" is \"true\" yulDetails: &#123; stackAllocation: false, optimizerSteps: \"dhfoDgvulfnTUtnIf...\" &#125; &#125; &#125; &#125;, metadata: &#123; // Reflects the setting used in the input json, defaults to false useLiteralContent: true, // Reflects the setting used in the input json, defaults to \"ipfs\" bytecodeHash: \"ipfs\" &#125; // Required for Solidity: File and name of the contract or library this // metadata is created for. compilationTarget: &#123; \"myFile.sol\": \"MyContract\" &#125;, // Required for Solidity: Addresses for libraries used libraries: &#123; \"MyLib\": \"0x123123...\" &#125; &#125;, // 必选：合约的生成信息 output: &#123; // 必选：合约的 ABI 定义 abi: [ ... ], // 必选：合约的 NatSpec 用户文档 userdoc: [ ... ], // 必选：合约的 NatSpec 开发者文档 devdoc: [ ... ], &#125;&#125;由于生成的合约的字节码包含元数据的哈希值，因此对元数据的任何更改都会导致字节码的更改。 此外，由于元数据包含所有使用的源代码的哈希值，所以任何源代码中的， 哪怕是一个空格的变化都将导致不同的元数据，并随后产生不同的字节代码。需注意，上面的 ABI 没有固定的顺序，随编译器的版本而不同。尽管从 Solidity 0.5.12 开始，数组保持了一定的顺序。源代码验证方法为了验证编译，可以通过元数据文件中的链接从 Swarm 中获取源代码。 获取到的源码，会根据元数据中指定的设置，被正确版本的编译器（应该为“官方”编译器之一）所处理。 处理得到的字节码会与创建交易的数据或者 CREATE 操作码使用的数据进行比较。 这会自动验证元数据，因为它的哈希值是字节码的一部分。 而额外的数据，则是与基于接口进行编码并展示给用户的构造输入数据相符的。ABI在 以太坊Ethereum 生态系统中， 应用二进制接口Application Binary Interface(ABI) 是从区块链外部与合约进行交互以及合约与合约间进行交互的一种标准方式。 数据会根据其类型按照这份手册中说明的方法进行编码。这种编码并不是可以自描述的，而是需要一种特定的概要（schema）来进行解码。除了 元组tuple 以外，Solidity 支持以上所有类型的名称。ABI 元组tuple 是利用 Solidity 的 structs 编码得到的。1234567pragma solidity ^0.4.16;contract Foo &#123; function bar(bytes3[2]) public pure &#123;&#125; function baz(uint32 x, bool y) public pure returns (bool r) &#123; r = x &gt; 32 || y; &#125; function sam(bytes, bool, uint[]) public pure &#123;&#125;&#125;这样，对于我们的例子 Foo，如果我们想用 69 和 true 做参数调用 baz，我们总共需要传送 68 字节，可以分解为：0xcdcd77c0：方法ID。这源自ASCII格式的 baz(uint32,bool) 签名的 Keccak 哈希的前 4 字节。0x0000000000000000000000000000000000000000000000000000000000000045：第一个参数，一个被用 0 值字节补充到 32 字节的 uint32 值 69。0x0000000000000000000000000000000000000000000000000000000000000001：第二个参数，一个被用 0 值字节补充到 32 字节的 boolean 值 true。合起来就是:10xcdcd77c000000000000000000000000000000000000000000000000000000000000000450000000000000000000000000000000000000000000000000000000000000001它返回一个 bool。比如它返回 false，那么它的输出将是一个字节数组 0x0000000000000000000000000000000000000000000000000000000000000000，一个bool值。事件，是 以太坊Ethereum 的日志/事件监视协议的一个抽象。日志项提供了合约的地址、一系列的主题（最高 4 项）和一些任意长度的二进制数据。为了使用合适的类型数据结构来演绎这些功能（与接口定义一起），事件沿用了既存的 ABI 函数。给定了事件名称和事件参数之后，我们将其分解为两个子集：已索引的和未索引的。已索引的部分，最多有 3 个，被用来与事件签名的 Keccak 哈希一起组成日志项的主题。未索引的部分就组成了事件的字节数组。一个事件描述是一个有极其相似字段的 JSON 对象：type：总是 &quot;event&quot;；name：事件名称；1inputs：对象数组，每个数组对象会包含：name：参数名称；type：参数的权威类型（相见下文）；components：供 元组tuple 类型使用（详见下文）；indexed：如果此字段是日志的一个主题，则为 true；否则为 false。anonymous：如果事件被声明为 anonymous，则为 true。12345678910// SPDX-License-Identifier: GPL-3.0pragma solidity &gt;0.6.99 &lt;0.8.0;contract Test &#123; constructor () &#123; b = 0x12345678901234567890123456789012; &#125; event Event(uint indexed a, bytes32 b); event Event2(uint indexed a, bytes32 b); function foo(uint a) public &#123; Event(a, b); &#125; bytes32 b;&#125;1234567891011121314[&#123;\"type\":\"event\",\"inputs\": [&#123;\"name\":\"a\",\"type\":\"uint256\",\"indexed\":true&#125;,&#123;\"name\":\"b\",\"type\":\"bytes32\",\"indexed\":false&#125;],\"name\":\"Event\"&#125;, &#123;\"type\":\"event\",\"inputs\": [&#123;\"name\":\"a\",\"type\":\"uint256\",\"indexed\":true&#125;,&#123;\"name\":\"b\",\"type\":\"bytes32\",\"indexed\":false&#125;],\"name\":\"Event2\"&#125;, &#123;\"type\":\"function\",\"inputs\": [&#123;\"name\":\"a\",\"type\":\"uint256\"&#125;],\"name\":\"foo\",\"outputs\": []&#125;]结语Solidity的合约开始真正的意义上的普及还需要一些时间，但是对于真正的使用，还是相当的有意思。接下来的使用中，在一步一步更新这个文档，感觉solidity蛮有意思的。","categories":[{"name":"blockchain","slug":"blockchain","permalink":"http://yangxinqi.com/categories/blockchain/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"http://yangxinqi.com/tags/solidity/"}]},{"title":"梯子教程简版","slug":"梯子教程简版","date":"2020-11-02T02:51:44.000Z","updated":"2020-11-02T03:00:22.000Z","comments":true,"path":"2020/11/02/梯子教程简版/","link":"","permalink":"http://yangxinqi.com/2020/11/02/梯子教程简版/","excerpt":"本篇文章，详细写了关于在海外如何翻回看片，以及如何在国内翻出去自由上网的过程。 希望大家一个便宜且安全的私有梯子。 这篇是欠商神的文章，还上。又到1年一度的双11，其他的没有买，买和续费VPS是当务之急，在买中，如何搭建自己私有的梯子，也是蛮好玩的。 对于娃翻墙回国学习，还是大人看国内的节目，或者是翻出来找资料，看youtube等等，都需要，所以本次做了分享，其实就是很简单的docker启动，以及配置防火墙的过程，其实对于IT认识而言，非常的简单。 可以尝试下，推荐使用。","text":"本篇文章，详细写了关于在海外如何翻回看片，以及如何在国内翻出去自由上网的过程。 希望大家一个便宜且安全的私有梯子。 这篇是欠商神的文章，还上。又到1年一度的双11，其他的没有买，买和续费VPS是当务之急，在买中，如何搭建自己私有的梯子，也是蛮好玩的。 对于娃翻墙回国学习，还是大人看国内的节目，或者是翻出来找资料，看youtube等等，都需要，所以本次做了分享，其实就是很简单的docker启动，以及配置防火墙的过程，其实对于IT认识而言，非常的简单。 可以尝试下，推荐使用。GFW的认识首先，需要对GFW要有强大的认识，因为有了GFW，才能保证稳定，还有就是基于版权的保护，会有地域性质的版权限制，但是对于大部分的海外国人来说，希望身在海外也能够看到国内的内容， 那么我们应该如何解决呢？梯子服务商对于服务商，一定要选择网络快而价格低的，本次给大家推荐：C2O： 中国翻海外，第一推荐： Google Cloud , Region选择 taiwan ， 台湾节点是目前在国内最稳定和最快速的海外访问节点。O2C: 海外翻中国， 第一推荐： ALi Cloud, region选择 qingdao， 青岛是国内3大光仟出口之一，其他的2个上海和广州那边早已人满为患了，青岛作为还未开发的一个口，目前来看速度最快，而且稳定。 强烈推荐。购买时机一，Google Cloud: 对于Google Cloud 本身有免费的300美元的额度，可以先使用信用卡开试用账户，然后免费用3个月，之后自动会被转成收费的账户。 系统配置的话，使用2core 2G 的足够了，每个月费用在$10以内，速度和性能都还不错，可惜只能免费3个月，之后就是收费的了。二，Ali Cloud: 阿里云，正直双11又要到了，可以一次性买3年的， 2Core 4G 的共享5M，3年的价格在1200 左右，不知道今年的价格是多少？ 平均每年在400左右，而且速度很稳定，需要使用阿里云的新账户去抢购。 一个机器解决3年的使用也蛮好。经过速度测试，5M的基本看国内的爱奇艺，腾讯视频，4K基本也不卡, 强烈推荐。部署梯子买好了之后，需要开始部署，这里推荐使用 V2Ray来搭建。Mac 下客户端，使用 V2RayU ， Windows上，还是推荐使用官方的V2Ray相关客户端，手机上 SuperWingy （iOS），v2RayNG (Android).搭建步骤：1.登录机器安装docker和docker-compose,123456ssh ubuntu@xxxx.xxxx.xxx.xxx sudo apt-get install -y docker.iosudo curl -L &quot;https://github.com/docker/compose/releases/download/1.26.2/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-composesudo chmod +x /usr/local/bin/docker-composesudo usermod -aG docker $USER2.克隆项目到机器上，并修改自己的端口和 uuid 码12345678910111213141516171819202122232425262728293031323334353637383940cd ~/ pwd ### 这里显示 /home/ubuntu/freeman/ 这里路径不对的话，需要修改docker-compose.yml中的配置文件的位置。 git clone https://github.com/xinqiyang/freemancd freemain/dockervi v2ray/config.json ### 这里修改你自己的端口和密码 ### 修改的配置的内容&#123; \"inbounds\": [&#123; \"port\": 32026, ### 这里是你的端口号，推荐修改到10000 以上的，降低被ban的概率 \"protocol\": \"vmess\", \"settings\": &#123; \"clients\": [ &#123; \"id\": \"4dde0eaf-9e30-442a-b29e-7eb29837b802\", #### 自己的唯一的UUID \"level\": 1, \"alterId\": 64 &#125; ] &#125; &#125;], \"outbounds\": [&#123; \"protocol\": \"freedom\", \"settings\": &#123;&#125; &#125;,&#123; \"protocol\": \"blackhole\", \"settings\": &#123;&#125;, \"tag\": \"blocked\" &#125;], \"routing\": &#123; \"rules\": [ &#123; \"type\": \"field\", \"ip\": [\"geoip:private\"], \"outboundTag\": \"blocked\" &#125; ] &#125;&#125;### 修改配置结束 :q 退出3.启动docker，开始服务12345docker-compose up -d docker ps ### 看到以下的在跑着，说明启动成功， 这里使用32026 端口，需要去开启防火墙配置CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES8a541b029756 jrohy/v2ray \"./run.sh\" 2 months ago Up 7 days 0.0.0.0:32026-&gt;32026/tcp v2ray_mritdv2ray_14.打开VPS的安全设置的防火墙端口，即可配置客户端开始使用。这里根据自己的账户，在网络设置里面 启动 32026 端口的防火墙，修改状态为 开启状态 即可。测试配置客户端的链接,我这里选用v2rayU的配置文件，大家在其他客户端中，只要提供 ip, uuid , level , alterId即可。连上之后，打开 ipip.net 查看自己的ip是否为当前的代理ip，看看能否成功。结语其实国内的在线教育资源，学习资源都超级好，我个人感觉有娃的更应该搭建一个，方便孩子学习中文及英语相关内容。对于互联网上的各位，要翻墙出来的，也推荐下。","categories":[{"name":"other","slug":"other","permalink":"http://yangxinqi.com/categories/other/"}],"tags":[{"name":"other, v2ray","slug":"other-v2ray","permalink":"http://yangxinqi.com/tags/other-v2ray/"}]},{"title":"Oracle协议比较分析-Band vs Chainlink","slug":"Oracle协议比较分析-Band-vs-Chainlink","date":"2020-10-20T02:26:02.000Z","updated":"2020-10-20T04:52:56.000Z","comments":true,"path":"2020/10/20/Oracle协议比较分析-Band-vs-Chainlink/","link":"","permalink":"http://yangxinqi.com/2020/10/20/Oracle协议比较分析-Band-vs-Chainlink/","excerpt":"前言最近项目中需要使用到Oracle,对价格进行更新，找了一圈市面上的，发现Band和Chainlink，对Chainlink的比价深有体会，遂开始深入研究下Oracle的实现机制，以及如何讲现实世界中的数据和API链接到智能合约中。 以下主要是翻译了SmartContent写的Band协议和Chainlink的对比分析的文章， 原文地址： https://medium.com/@smartcontentpublication/a-comparative-analysis-of-band-protocol-and-chainlink-54b7d14823b5 ，对文章进行了翻译和补充，基本使用Google翻译进行简要的翻译，可以当成一篇PR稿文章，主要从几个维度，比如 数据质量，随机性以来，采纳指标，资源效率和网络设计，团队，去中心化和多链支持等各个方面，对Band和Chainlink进行了比较，结果都是Chainlink胜出了。大杨个人意见，看过Band的创始团队和背后的投资机构，都是相当有前景，而且Oracle语言机的盈利模式上都是平台方来撮合数据需求方和提供方调用，然后支付方式都是用平台的虚拟币支付，这样的方式其实也带来了很大不确定性，随着平台方币价的上涨，也带来了需求方很大的调用成本，本身现在公开的调用方式，实时性也不好，如果采用较为实时的解决方案，那么使用LINK代币来支付的费用，换算成法币的话，也是非常高的。从文章从可以看到的是Band协议V2，依赖于与Cosmos, 而且很区块链化，对于用户的直接引入也很不友好，此外Chainlink VRF作为一个显著的重大热点，为NFT提供服务，Band目前还没有什么亮点仅仅挂个Oracle的竞争者。整体来看，Band还是比较困难的，推荐大家使用Chainlink.","text":"前言最近项目中需要使用到Oracle,对价格进行更新，找了一圈市面上的，发现Band和Chainlink，对Chainlink的比价深有体会，遂开始深入研究下Oracle的实现机制，以及如何讲现实世界中的数据和API链接到智能合约中。 以下主要是翻译了SmartContent写的Band协议和Chainlink的对比分析的文章， 原文地址： https://medium.com/@smartcontentpublication/a-comparative-analysis-of-band-protocol-and-chainlink-54b7d14823b5 ，对文章进行了翻译和补充，基本使用Google翻译进行简要的翻译，可以当成一篇PR稿文章，主要从几个维度，比如 数据质量，随机性以来，采纳指标，资源效率和网络设计，团队，去中心化和多链支持等各个方面，对Band和Chainlink进行了比较，结果都是Chainlink胜出了。大杨个人意见，看过Band的创始团队和背后的投资机构，都是相当有前景，而且Oracle语言机的盈利模式上都是平台方来撮合数据需求方和提供方调用，然后支付方式都是用平台的虚拟币支付，这样的方式其实也带来了很大不确定性，随着平台方币价的上涨，也带来了需求方很大的调用成本，本身现在公开的调用方式，实时性也不好，如果采用较为实时的解决方案，那么使用LINK代币来支付的费用，换算成法币的话，也是非常高的。从文章从可以看到的是Band协议V2，依赖于与Cosmos, 而且很区块链化，对于用户的直接引入也很不友好，此外Chainlink VRF作为一个显著的重大热点，为NFT提供服务，Band目前还没有什么亮点仅仅挂个Oracle的竞争者。整体来看，Band还是比较困难的，推荐大家使用Chainlink.正文Band Protocol是一个Oracle平台，旨在将现实世界的数据和API聚合并连接到智能合约。 Band v1最初于2019年9月在Ethereum上使用了Bonding Curve设计，但开发人员的兴趣不大，最终没有在主网上获得采用。 核心开发团队在不到一年的时间内就放弃了它, 开始开发V2版本。Band v2，被称为BandChain，是一个在自己的基于Tendermint的区块链上运行的Oracle网络（使用Cosmos SDK）。 BandChain已经启动了两个网络，第一个是Wenchang网络-一个原型主网络，它不具有任何Oracle功能，只生成基本上是空的块。第二个网络是Guan Ya测试网，但是，在底层Cosmos SDK中出现严重的内存泄漏和状态修剪错误之后，该网络最近不得不重新启动。在正式主网之前，其目的是启动一个授权证明网络，该网络由七个属于Band基金会和私有选择验证者节点组成。在本文中，我们将首先从高层次探讨BandChain的工作方式，从而为进行比较分析奠定基础，该分析详细说明了BandChain与Chainlink的堆叠方式。比较的主要重点如下：数据质量Band：在发布时，BandChain最初将仅支持免费的低质量API，而付费的受密码保护的API支持在很大程度上仍是理论上的。 因此，开发人员不能只调用他们想要的任何受密码保护的API。 他们提出的计划是要求数据提供者更改其整个业务模型，以接受数据的链上加密货币支付。Chainlink：本机支持连接到当今任何实时生产环境中的数据源API，包括免费的开放API，付费的经过身份验证的API和专有的私有API。 所有这些都可以通过模块化的外部适配器实现，任何人都可以创建和托管这些适配器，而无需Chainlink团队或数据提供商本身的任何其他支持。随机性依赖Band：将随机性作为协议的核心组成部分； 这是选择oracle节点的必需方法，尽管该功能不受任何原始学术研究的支持。 这不仅严重限制了数据的可访问性（每个节点都必须有权访问相同的数据）和网络安全性（必须信任每个节点），而且该团队在此主题上无能为力，因为他们在尝试复制Chainlink VRF在他们自己的github repo上的时候，被发现了(https://twitter.com/chainlink_alert/status/1267133567764758533)。Chainlink：不将随机性作为协议的核心部分，以确保用户具有高度的灵活性和质量控制机制，可以选择节点并连接到数据。 他们建立了Chainlink可验证随机性功能（VRF），作为一种新颖的方法，以领先的和原创的学术研究为后盾，为区块链游戏和NFT dApp创建可证明的公平的随机性源。采纳指标Band：尽管Band v1在以太坊上存在了将近一年，但主网上目前没有正在使用的产品。 Band v2尚未完成（没有oracle功能），完全未经验证，并且缺少能够支持生产中的真实用户的任何案例研究。Chainlink：目前，通过其众多实时价格参考供稿，对于排名靠前的DeFi项目，其在Mainnet上的价值超过$ 10B。 由于其在VRF方面的开创性工作，它是整个DeFi，跨区块链，游戏中使用最广泛的Oracle，并拥有240多个项目集成管道。资源效率与网络设计Band：他们的Oracle建立在自己的区块链上，需要Oracle节点执行作为BandChain的块生产者/验证者的辅助工作，这对Oracle的数据交付工作没有任何价值。 这样，由于状态膨胀越来越大，并且随着时间的推移，同步时间较长，因此节点将承受较高的运营成本。Chainlink：Chainlink不是，以后也不会是一个区块链网络，因此节点仅充当仅专注于数据交付的预言家，而不会阻止生产/验证。 节点非常轻巧，不需要状态处理或同步，因此可以将节点旋转并立即使用。团队Band：Band团队规模很小，没有进行过任何原始的学术研究，也缺乏构建分布式系统和Oracle的经验，尤其是那些能够确保真实价值的产品。 他们还放弃了原始设计，并多次更改了协议。Chainlink：40+ Chainlink团队成员自2014年以来一直在建立Oracle预言机并发表原创学术研究，并得到了顶级顾问的支持，例如Ari Juels（RSA的前首席科学家），Tom Gonser（DocuSign的创始人），Evan Cheng（工程总监） 在Facebook）等等。 他们坚持原始设计并对其进行扩展以改善用户体验。去中心化Brand：所有数据查询/响应必须通过单个区块链BandChain处理，从而限制了最大吞吐量。 由于Tendermint BFT共识的可扩展性有限，因此上限为100个节点。Chainlink：无限数量的Oracle网络可以并行运行，并且可以在任何区块链，DLT或Layer 2解决方案上本地运行，从而无需通过任何一条链来进行数据查询/响应。 即将到来的阈值签名和链外聚合升级的节点没有上限。多链支持Brand：依靠尚未发布的Cosmos IBC将数据本地桥接到其他区块链。 因此，它目前仅支持精简客户端，精简客户端要求数据由协议之外的未知第三方交付，这些第三方对其性能的奖励或处罚为零。Chainlink：通过模块化的外部适配器，外部发起程序，核心合约部署和令牌桥接，以本地方式支持任意区块链。 节点将数据直接传递到任何区块链上的请求合约，从而最大程度地减少网络跳转并确保及时传递。怎么运行的Band Protocol v2（BandChain）是基于Bender（DPoS）共识算法的基于Tendermint的区块链，并在Cosmos生态系统中运行。 BandChain当前在主网上不支持oracle，仅产生大部分为空的块。本节介绍了BandChain一旦完全发挥作用后将如何运行，但请记住，主网中尚不存在许多这些功能。BandChain节点必须既充当区块链的验证器（产生块，验证和订购交易），又充当服务外部数据请求的预言家。拥有最多代币的前100名验证者成为BandChain的验证者。该网络的年通胀率将从13.5％开始，目标是占总供应量的66％。如果抵押率低于66％，通货膨胀率最高将上升到20％。如果抵押率高于66％，通货膨胀率将至少降低7％。另外，虽然尚不清楚这些资金将如何分配以及分配给谁，但每个区块奖励的2%会转入社区资金池。可以大幅度削减验证者的本金，以使停机时间过多，超过30,000个区块（0.01％罚款），双重签名区块（5％罚款）或无响应（百分比不清楚）。如果大幅减少停机时间，节点将无法参与对任何块的签名，直到它们在BandChain上发送交易证明其在线。重要的是要注意，BAND赌注和所有这些削减条件仅用于维护区块链验证和区块生产，而不是用于确保任何oracle服务的可靠性或数据准确性。尽管Band团队建议在将来共同投票以惩罚执行错误的Oracle服务的验证者（这将受到鲸鱼的操纵），但这尚待开发，并且仍然完全是理论上的。用户可以通过调用可用的“ Oracle Script”智能合约将数据请求发送到BandChain，这些智能合约是对数据请求详细信息进行编码的链上可执行程序，例如要调用的数据源API以及将验证程序响应聚合为单个响应的方法。选择响应数据请求的节点由随机权益加权算法决定。验证者投入的BAND令牌越多，将它们分配给数据请求的可能性就越大。因此，数据请求者无法控制将使用哪些节点来完成其数据查询。选定的验证器通过获取链下数据并在链上（到BandChain）传递响应来完成数据请求。然后，将来自每个参与节点的数据汇总以形成最终响应。创建了一个oracle数据证明（Merkle证明），并显示最终结果的存在以及oracle脚本哈希，输入参数，执行时间等。该证明可以发送到其他区块链上的智能合约以验证其证明由BandChain验证者。证明也可以被解码，以便智能合约可以使用数据结果。Band Protocol的目标是与区块链无关，其中Oracle请求在BandChain的环境中处理并桥接到其他链上。他们计划利用Cosmos正在开发的未发布的跨区块链通信（IBC）协议来将数据桥接到其他链，尽管目前尚不清楚IBC是否以及何时准备投入生产。因此，要求用户使用lite客户端协议将数据手动桥接到其他区块链，直到IBC启动。这要求用户依赖BandChain协议之外的外部第三方将数据实际传递到另一个区块链（例如，以太坊上的DeFi应用程序）上正在使用的智能合约中。这些第三方没有动力可靠地提供数据，也没有因此而受到惩罚。现在您对BandChain的工作方式有了一些了解，我们可以逐点深入进行比较，以了解Band如何与Chainlink抗衡。数据质量和Oracle连接范围Band ProtocolBand协议仅支持免费的开放API。目前，他们对付费的受密码保护的API的支持完全是理论上的。当前的提议将要求数据提供商单独上岗，并修改其业务模型以加密货币支付。 Chainlink原生支持当今的所有数据源，包括通过模块化外部适配器的开放式和经过身份验证的API，这些适配器不需要数据提供商更改其现有业务模型。编写本文时，Oracle功能在主网上尚不可用，但一旦上线，它将仅支持免费的低质量API，这些API通常每隔10分钟或更长时间更新一次，精度不超过小数点后1位点。从一开始就无法支持高质量数据，这使人们严重怀疑DeFi协议是否会感到满意，依靠Band来保护数百万美元的用户存款，尤其是当几乎所有高质量数据都存在于付费专区且仅发生一次Oracle攻击时由于数据质量低劣，最终可能导致破产并破坏应用程序的整体声誉。Band表示BandChain将无法支持经过身份验证（受密码保护）的API，直到第2阶段（时间表尚不清楚）。密码保护的API如何实施的细节几乎不存在，在他们的文档中减去一句话，即” API提供者通过BandChain的链上支付结算来通过数据获利”。尽管这种模型不太可能已经准备好投入生产，但从整体上考虑它会暴露出逻辑上的一些缺陷。首先，数据提供者将需要改变其现有业务模型以支持加密货币支付，这意味着Band将不得不携带成百上千的特定于应用程序的，经过身份验证的利基数据源，数据请求者需要这些数据源来构建其dApp。这既不切实际又不可扩展，将严重限制开发人员访问绝大多数数据源。其次，它们的随机权益加权节点选择机制意味着可以潜在地选择网络中的每个节点来服务数据请求，这导致每个节点都需要访问每个潜在的数据源。这将需要与数据提供商进行激烈的协商，以达成整个区块链都可以访问的交易，以及节点之间缓慢，复杂的链外协调/治理，以共同添加新数据源并为其提供资金，这使其非常不切实际或完全不可行。扩展性上，由于采用了这种设计选择，Band仅是所有节点都可以平等访问的唯一数据类型，因此它仅非常适合支持开放的API。这将阻止开发人员访问他们所需的特定外部数据，尤其是以任何快速无摩擦的方式。这也将消除绝大多数数据提供商永远无法加入网络，因为他们不能（出于法律原因）和/或不希望（出于商业原因）接受加密货币支付。鉴于缺乏利用BandChain生产的应用程序，任何数据提供商花费时间，资源和金钱来重新设计其业务模型以支持BandChain几乎没有意义。他们也从未详细说明过如何保护数据隐私的功能，这将进一步使BandChain不再受到希望保护其IP的数据提供商和需要保护敏感信息的企业的支持。ChainlinkChainlink已经通过其价格参考合约利用了凭据数据源，这些参考数据是由分散的oracle网络保护的30多种DeFi价格摘要的集合，这些摘要使任何智能合约都可以在单个交易中同步提取外部数据。Chainlink可以灵活地提供高质量的数据，因为节点始终具有内置的凭据管理功能，这些功能使它们可以使用模块化外部适配器访问任何受密码保护的API。可以使用任何编程语言编写Chainlink外部适配器，并与Chainlink节点本身分开托管。这打开了API的整个世界，例如高级数据提供商，Web API，企业系统，云提供商，IoT设备，支付系统，其他区块链（公共和私有）等等。数据提供商无需更改其核心业务模型或后端基础结构即可通过智能合约访问，因为Chainlink节点可以处理外部适配器中的API密码密钥。因此，他们可以为今天使用的法定订阅模型中的已认证API付费，然后只需将其API密码密钥放在外部适配器中，然后立即开始在链上传递该数据。数据提供商更喜欢这种模型，尤其是在最初，因为它们可以在不花费任何时间，资源或金钱进行复杂区块链集成的情况下获得更多收入。这极大地减少了开发人员的负担，因为节点可以在无需任何许可或需要所有其他节点获得相同访问权限的情况下，快速构建对任何链外数据资源的支持。它只需要一个节点或开发人员为该数据源API编写一个外部适配器，使其可用于任何区块链。然后，节点可以通过专门提供特定的数据集来区分自己。同样，如果数据提供者希望直接在链上获得报酬，则他们可以自己运行节点并直接向市场出售。实际上，一些数据提供者已经在Chainlink上这样做了，例如Huobi，Kaiko，Alpha Vantage等。重要的是，外部适配器模型可确保数据提供商始终获得报酬，而企业系统仅授权经过验证的用户。Chainlink还高度了解Oracle隐私的必要性，因此他们在可信赖的硬件解决方案（如Town Crier）上的完善工作已得到广泛认可。企业可以使用该技术来满足隐私法规，同时在执行智能合约时仍使用其专有数据。最重要的是，企业可以准确选择哪些oracle节点满足其数据问题，这在确保机密数据（PII）即使经过加密的情况下也仅位于特定地理区域内以确保遵守诸如GDPR –许多全球企业和机构的基本要求。Chainlink网络是一种资本主义的自由市场经济，任何人都可以运行自己的节点，开始在任何区块链上提供智能合约，并可以访问任何链下数据源API。这促进了健康的竞争，并允许节点建立自己的业务模型，而无需其他所有节点的外部依赖。相反，BandChain采取的是共产主义的，中央计划的经济方法，该方法要求网络中的每个节点都经过标准化，并支持与网络中每个其他节点相同的功能和连接，最终限制了创新，竞争和采用。哪些开发人员或用户将信任那些不了解其核心功能到其协议中，没有学术研究或安全审核支持，并要求复制竞争对手解决方案的开发人员大量价值？ 这是BandChain如何利用现有技术，区块链和随机性功能，并试图迫使它们成为基于错误假设的Oracle解决方案的又一个示例。Chainlink允许数据请求者准确选择他们要使用的预言软件，从而为智能合约开发人员带来最大的灵活性。 Chainlink团队已经构建了Chainlink VRF，可以用作可证明是公平的随机性源，作为区块链游戏和NFT行业的输入，而不是Chainlink协议本身的核心部分。他们理解并避免了强迫数据请求者使用随机性选择节点的严重危险，特别是无法获得高质量或许可的数据集（如数据质量部分中所述）以及无法在网络上获得确定性保证的巨大安全风险。节点运营商的可靠性或基础架构安全性。Chainlink VRF已被广泛采用，在启动后的短时间内便进行了许多集成，包括：PoolTogether，Digitix，Get Protocol，Blocklords，Polyient Games，BlockPegnio，Vibe，Texel，Tiny Boxes，Cargo，Wildcards，FaceGolf和更多。 Chainlink的VRF建立在行业专家多年的学术研究基础之上，这些专家在分布式系统和高级密码学领域拥有数十年的经验，例如Ari Juels，Andrew Miller，Evan Cheng，Alex Coventry等（在下面的部分中进行详细介绍）。 Chainlink VRF不仅是由世界上一些最聪明的人内部开发的，而且还经过了顶级安全公司的审核，并经过了无数次审查才能投入生产。发展与网络效应Band团队缺乏在分布式系统，高级密码学和构建oracle方面的经验，已经放弃了最初的v1版本启动，无法捕获任何网络影响，并且Band v2完全未经验证，没有在生产中使用。 自2014年以来，Chainlink团队一直在建立Oracle，其团队由40多人组成，其中包括顶级学术和业务顾问。 Chainlink还为市场领先的DeFi项目确保了Mainnet上超过$ 10B的价值，并且集成管道中有240多个项目（包括60多个区块链）。Band v1在开发方面完全被放弃了，并且没有看到任何外部项目在生产中的使用。缺乏任何主网采用以及其价格信息的更新不频繁就证明了这一点，其中许多经常表现出较大的偏差。Band协议在设计上也进行了多次更改，包括放弃了其双令牌绑定曲线设计，等离子L2，Gas，稳定币费用支持，用户驱动的数据治理等。v1的性能不佳以及协议的不断变化质疑Band团队是否真的考虑了他们的Oracle机制的设计，以及是否可以信任他们以确保从其他用户的资金中获得数百万美元的价值。Band v2（BandChain）也未经Oracle系统的完全验证，尚不支持其原始主网上的任何Oracle功能。 BandChain的大部分与区块链相关的工作都外包给了Cosmos SDK和Tendermint。对于任何现实价值而言，都缺乏经过时间考验的安全性，这意味着Band仍需要证明自己是一种可靠的解决方案，然后任何项目才能放心地相信其oracle实现来保护核心协议功能。请务必记住，甲骨文负责其他dApp的关键任务功能，例如发放贷款和执行清算。当其他人正在考虑是否可以将整个协议的正确功能委托给您的外部Oracle机制时，成为一个好人或在您的墙上获得学位是毫无意义的。考虑到Band没有获得生产中的用户，已经进行了多次设计变更，并且仅使用提取了所有艰巨工作的SDK推出了区块链，因此任何希望使用BandChain的dApp都承担着严重的风险并且对其鲁their地进行粗鲁用户的资金。Band团队由三位创始人组成，他们在构建区块链基础架构，oracle机制或任何处理实际价值的关键任务系统方面没有经验。他们在软件开发方面的唯一经验是在2015年创建了基于加密的手机游戏，此游戏已被放弃。为儿童构建手机游戏与构建复杂的分布式系统并不遥不可及，后者不仅为Band令牌持有者确保价值，而且最终也希望确保其他应用程序的价值。这种经验几乎没有甚至没有交叉，因为建立一个区块链的甲骨文网络是一个具有挑战性的指数难题，并且存在许多明显的陷阱和攻击媒介。他们不仅缺乏经验，而且没有学术或商业顾问来指导他们。所有这些都表明Band团队处于顶峰，这将给使用它的任何人带来巨大风险，并在不可避免地发现和利用漏洞时打开Mt Gox类型的内爆。Chainlink,至少从2014年SmartContract LTD成立（以太坊推出之前）开始，Chainlink的联合创始人一直在研究和构建外部连接的智能合约和区块链Oracle技术。该团队直接与需要区块链Oracle的顶级开发人员和企业合作，他们通过开发已在生产中使用的可靠解决方案，了解了如何满足各种不同用例的安全性，隐私性和可扩展性需求，以及应用程序。他们从未放弃过自己的初衷，而是继续在创建的坚实基础上进行创新，包括TownCrier，Threshold签名，Mixicles等原始研究开发。Chainlink的40多人开发团队由区块链，甲骨文，密码学，机器学习，人工智能和业务开发方面的资深专家组成。其中包括众多学术和商业顾问，这对于Chainlink的技术和国防深度方法至关重要。Chainlink于一年前在主网上推出，并已迅速实现大型网络效应，目前已从许多领先的DeFi项目（包括Synthetix，Aave，Loopring，Nexus Mutual，Set Protocol，bZx，Kava， 和更多。 Chainlink还拥有240多个集成开发项目，从区块链和加密货币初创企业到Google，Oracle和SWIFT等全球企业以及Hyperledger，IC3，EEA，Baseline，InterWork等企业联盟/标准化组织等等。最终的结果是一个非常有经验和知识渊博的团队，他们有能力以加密初创公司，全球企业和顶尖学者的支持方式来解决甲骨文的难题。 开发人员拥有案例研究和明确的证明，Chainlink是一个安全可靠的Oracle解决方案，可通过在生产中的实际使用来确保高价值合同。 它的采用已经在推动一个积极的反馈循环，在该循环中，使用网络的用户，数据提供者和节点越多，对于新的和现有的利益相关者来说，作为Oracle解决方案的功能更强大，价值更高的Chainlink也就变得如此。 鉴于缺乏主网使用以及合作伙伴数量非常有限（大多数是验证者或交易所列表），Band无法实现任何网络效果。 此外，开发人员除了缺乏活力的v1版本外，还没有任何关于Band的预言的信息。资源效率与网络设计BandChain使用自己的区块链，这对于Oracle的工作是完全不必要的-将数据传送到智能合约。 Band团队正在使用区块链解决方案来解决一个根本不同的问题，这会导致许多问题，例如状态膨胀，同步时间长和强制随机节点选择。 Chainlink并非现在也永远不会是其专有的区块链，而是真正的与区块链无关的中间件，这使得它可以灵活地支持所有DLT网络和数据资源，并为节点运营商提供轻量级的支持。带BandChain区块链背后的设计选择（即两个秒的块时间）导致所有节点的状态膨胀迅速增长，而新节点或重新连接的节点的同步时间更长。运行Band节点比诸如Bitcoin和Ethereum之类的区块链要昂贵得多，并且要消耗大量资源，这些区块链已针对降低硬件要求进行了优化，以增加分散性。与完全不运行专有区块链的Chainlink oracle节点相比，它的成本和资源消耗也成倍增加。随着时间的流逝，BandChain的设计决策很可能自然导致集中度的提高，而节点大多由资本雄厚的验证者在几个数据中心中运行。这些问题与EOS和BSV等区块链受到的影响相同。为了支付运行节点的成本，如果用户费用没有增加到足够高的水平，BandChain将需要更高的新铸造令牌的通货膨胀率来维持相同级别的安全性。由于Band的预言机也是块生产者，因此，块生产的失败（例如最近Cosmos SDK中的内存泄漏和状态修剪问题）也会导致预兆机制的失败。将oracle机制直接集成到区块链的基础层中也将强制执行单个整体网络设计，这由于强制实施的标准化而阻碍了oracle的创新，并极大地限制了oracle在支持各种用例方面的概括（如数据质量部分）。BandChain通过隐秘方法通过一种安全措施有效地运作，其中验证者无需透露其身份或可靠性。 这与随机的股权加权选择相结合，意味着数据请求者必须信任在BandChain上运行的所有节点，因为他们无法控制最终将被选中的匿名或非匿名节点，从而给用户带来了很高的信任障碍。 这远非理想，因为大多数安全专家普遍认为通过模糊性来实现安全性是设计基本健壮的系统或网络的不良方法。由于Chainlink不是区块链，因此不会遭受状态膨胀或同步时间问题。 Chainlink节点重量轻，对硬件的要求极低，可以通过一个简单的Docker容器在任何计算环境中运行。甚至将节点设置为在Raspberry Pi等极低规格的设备上运行，从而使IoT设备可以直接运行Chainlink节点以减少智能合约的跳数。由于缺乏资源需求而导致的低进入门槛极大地增加了Chainlink网络整体的分散性。与BandChain不同，不需要所有活动Chainlink节点之间的整体全局共识，而是选择水平可伸缩性，即无限数量的oracle网络并行并行运行。 Chainlink节点不需要创建或验证任何专有区块链的块，因此不依赖于任何一个特定区块链的功能操作。对于每个单独的Oracle网络，Chainlink的安全性都是完全自主的。它没有做任何实现假设，而是提供了使用任何区块链所需的节点，数据源或参数来创建任何类型的oracle网络所需的工具。它是高度通用的，这意味着它不会对用户强加任何一种类型的oracle设计模式（推送或拉动，允许或不允许，集中或分散，开放或列入白名单，偏差阈值和/或心跳更新等），允许无限在新的Oracle模型上进行创新。当前在主网上运行的Chainlink网络通过透明性原理使用安全性进行操作，其中价格参考数据网络仅由经过安全审查的节点组成，这些节点由经验丰富的区块链DevOps和分布在全球数据中心和现场裸机中的安全团队操作服务器。此外，许多独立的团队创建了多种分析服务，使最终用户和开发人员都可以直接查看每个Oracle网络的性能和历史记录。这样，任何人都可以使用以简单易用的方式呈现的历史索引链上数据来确切地知道特定的Chainlink网络或节点是否可靠。这包括feeds.chain.link（由Chainlink创建），market.link（由LinkPool创建），reputation.link（由Secure Data Links创建），honeycomb.market（由CLCG创建）等。去中心化和加密经济安全由于Tendermint BFT的可伸缩性有限，BandChain使用具有100个节点上限的单个整体共识机制。验证器仅放样产生块，而对于操作或无效的外部数据则不加砍刀。 Chainlink是独立的分散式Oracle网络的集合，这些Oracle网络在众多区块链上并行运行，其阈值签名和链外聚合升级没有每个网络中节点数量的上限。 LINK放样将涉及绑定服务协议，并在数据质量，可靠性，准确性等方面采用预先定义的削减条件。由于BandChain使用Tendermint BFT共识进行操作，因此最多只能扩展到几百个验证器，然后通信带宽才成为问题和每秒事务（TPS）池。因此，Band在任何给定时间点的验证器数量有限，最多100个节点。这是使用整体式区块链作为处理数据请求和响应的唯一共识机制的另一个缺点。它极大地限制了BandChain将能够达到的最大分散级别，除非对整个网络模型进行根本性的重新设计。还需要注意的是，BandChain验证程序只有在充当糟糕的区块生产者（停机，双重签名，无响应）的情况下，才可以削减其BAND股份。充当不良或恶意的Oracle（操纵数据，Oracle网络攻击，串通）不会造成任何重大的惩罚。 BandChain中的验证者可能更专注于成为一个好的区块生产者，而不是成为一个好的预言家，因为这是决定他们是否被削减的原因。尽管零售业者已经讨论了BandChain Token，但现实是，验证者的零售股份并没有为BandChain作为Oracle网络提供任何真正的价值。将来，BandChain可能会对通过链上投票传递不良数据的节点实施大幅削减，但目前很少有细节，因为仅提一个小建议，因为它们已弃用的D3N规范中只有一句话。此后，有关该主题的信息已从其github wiki上的当前文档中删除，表明他们可能对该主题几乎没有积极的开发。尽管这个想法可能也已经被抛弃（就像许多其他以前的核心功能一样），但他们过去曾指出，零售BAND令牌涉众将有助于将数据提供者作为信誉系统机制进行管理。这代表了执行质量控制的一种非常脆弱和临界的危险形式，尤其是在考虑到它应该为价值数百万美元或更多的合同提供安全性时。散户投资者不太可能进行任何认真的尽职调查，而只会选择即时投资回报率最高的数据提供商。区块链不可知论的方法BandChain依靠尚未发布的Cosmos IBC将数据本地桥接到其他链。 当前，它仅支持lite客户端，在这些客户端中，数据必须由协议外部的未付费和可能未知的外部方传送。 Chainlink本机支持当今最领先的区块链，并将通过其自适应且易于集成的设计继续支持未来的链。由于BandChain是其自己的区块链，因此另一个要使用Band oracles的区块链上的去中心化应用程序完全依赖于跨链通信桥。 BandChain的主要跨链功能取决于Cosmos区块链内部通信（IBC）协议，该协议不是由其团队构建的，距离全面运行和经过时间考验还需要数月甚至数年的时间，尤其是对于不信任的数据传输而言从一个区块链环境到另一个。在此之前，将通过部署在每个集成区块链上的BandChain lite客户端执行区块链互操作性。使用Band作为预言的其他区块链上的智能合约将完全依赖于一些外部非激励性第三方向该链上的精简版客户合约提供证明。 BandChain验证器不会将这些证明提供给其他链（直到IBC为止），这意味着当前始终需要第三方在链之间中继数据。这种方法很难扩展，因为每个受支持的区块链将需要托管自己的lite客户合同，并需要Band协议之外的外部实体来提供证明并保持lite客户同步。关于将数据传递给精简客户的动机存在主要问题，尤其是在网络拥挤的情况下，当交易费用在外部区块链上飙升时。需要特别注意的是，即使BandChain在其自己的区块链上聚合数据，但将数据本身广播到其他区块链也将受使用链的本机速度和延迟的影响。 Bandchain当前仅支持少数几个Testnet区块链。Chainlink与区块链无关，但是以与BandChain根本不同的方式实现了此类功能。 Chainlink不是运行自己的专有区块链，而是一个框架，用于在任何区块链上为智能合约构建异构的分散式Oracle网络。通过模块化的外部适配器和外部启动器，Chainlink节点能够监视数据请求并将链外数据直接传递到任何区块链环境，这意味着不依赖具有可疑激励/问责制的精简客户或外部第三方。因此，Chainlink节点能够本地支持当前或将来存在的任何区块链，DLT或layer2解决方案，包括智能合约功能有限的链，例如无法托管此类lite客户端的比特币。这还包括非IBC兼容的许可链和非区块链系统，例如企业ERP / CRM后端和旧数据库，这些系统希望从加密经济保护的分散式Oracle网络中创建和使用外部数据。Chainlink网络上受支持的区块链包括以太坊，比特币，Polkadot，Ava，NEAR，Kava，Tezos，Binance Smart Chain，BSN，IRIS，基于EVM的链，基于基质的链，Harmony，Zilliqa，本体论，Kadena，Klaytn，CasperLabs， Solana，Hdac，ICON，Conflux，Hedera Hashgraph，Matic等。有60多个区块链被集成到Chainlink协议中。最初在以太坊区块链上启动时，Chainlink的合同系统被重写为可以在其他众多区块链上本地运行，而LINK令牌则通过跨链桥包装。因此，每个Chainlink甲骨文网络仅需遵循其所运行的特定链的吞吐量和安全性假设。即使有IBC支持（Chainlink也可以支持），Chainlink的区块链不可知论形式的规模可以远远超过BandChain。代替Bandchain通过单个区块链传递数据请求和节点响应的方法，Chainlink网络可以并行且彼此完全独立地处理数据请求和节点响应，从而提供理论上无限的水平可扩展性。 Chainlink在每个词义上都是与区块链无关的，因为它不是区块链，而是在所有区块链网络上同时运行的抽象层。结论Chainlink与区块链行业中最著名的研究人员一起进行两次测量并进行一次切割，以进行敏捷开发，以保持在新的前沿技术和创新之上。团队认识到了考虑周到且端到端的安全Oracle框架的重要性，该框架可以提前缓解复杂的攻击媒介。Band的做法更像是将意大利面条扔在墙上，看看遵循“快速行动并打破事物”的理念的实质，换句话说。尽管此方法可以在某些行业中使用，但绝对不是绝对必要的解决方案，它可以解决oracle问题，因为绝对安全是必须的，实际价值很容易受到无法逆转的操纵。经过全面比较，Band协议将采用基于区块链的方法，通过使用整体共识来解决oracle问题，这将强制执行节点的标准化并对其分散有上限。这种僵化的模式是Band努力以可扩展的方式支持经过身份验证的API的原因，因为如果不从头开始重新设计整个数据行业，几乎所有节点都无法在其框架中支持凭据数据。他们的大多数原始开发和设计规范已被放弃，未来的功能集几乎完全是理论上的，极其模糊的或根本不存在的。虽然探索和更改有时可能会很好，但它们也可能表明有人在他们的头顶上，这尤其应与构建oracle协议时所面临的风险有关。另外，Chainlink已确定Oracle问题与区块链问题是分开的，它采用了高度模块化的自由市场框架，该框架支持无限数量的并行Oracle网络，这些网络达成共识并保持彼此完全独立的安全性。 Chainlink用户可以在多个方面访问高级定制，包括节点选择，数据类型，安全性方法，抵押抵押，隐私支持等等。 Chainlink团队证明了其能够支持主网上DeFi项目的大型生态系统，确保超过10亿美元的用户资金的能力。 Chainlink已经在建立公益的Oracle网络，其中多个用户贡献相同的价格，从而降低了每个用户的成本。尽管竞争是健康的，每个人都应该尽自己的努力，但真正检查用于直接保护大量用户资金的预言机机制很重要。如果智能合约经济有望扩大规模，并被风险偏好更为保守，对灵活性和质量控制有更高要求的传统机构所利用，那么，Oracle可以轻而易举。Oracle的“足够好”方法恰恰是遭到黑客入侵并失去用户资金的开发人员的心态。这与部署未经审计的智能合约没有什么不同，智能合约面临着巨大的未知安全风险，这些风险可能会使项目及其用户完全破产。同样，非通用解决方案可能会在短期内服务于一个细分市场，但会像许多高科技行业一样被通用标准所吞并。出于这些原因，需要通过智能合约的价值和通用性来扩大安全性，以增强卓越的网络效果，我们认为，与Band Protocol相比，Chainlink迄今为止是一个非常出色的oracle解决方案。","categories":[{"name":"blockchain","slug":"blockchain","permalink":"http://yangxinqi.com/categories/blockchain/"}],"tags":[{"name":"oracle, band, chainlink","slug":"oracle-band-chainlink","permalink":"http://yangxinqi.com/tags/oracle-band-chainlink/"}]},{"title":"DEFI深入浅出实战编程一入门篇","slug":"DEFI深入浅出实战编程一入门篇","date":"2020-09-24T10:47:25.000Z","updated":"2020-11-02T03:01:34.000Z","comments":true,"path":"2020/09/24/DEFI深入浅出实战编程一入门篇/","link":"","permalink":"http://yangxinqi.com/2020/09/24/DEFI深入浅出实战编程一入门篇/","excerpt":"翻译者： 大杨， 链因智能CEO， 一家初创区块链技术公司，DEFI布道者。技术点： DEFI，ETH，NODEJS，SOLIDITY今天抽出了一些时间，翻译了CoinBase的Pete Kim 写的【Introduction to Building on DeFi with Ethereum and USDC — Part 1】DEFI编程入门学习的文章。翻了下Pete Kim的twitter和他的github，发现是个全栈高手和社区活跃者，看上去应该是韩国人，技术很不错，人也很帅 😂。最为美系的第一交易所CoinBase对整个Crypto生态的贡献是巨大的，本篇DEFI编程的入门文章也非常适合新手，看了有很想翻译的冲动，就花了2小时做了下整理，并在kovan的网络上实战了一把，对很多细节的地方做了补充，强烈推荐给大家。 经历DEFI，后续链因智能3年积累的相关技术都会进行开源，通过开源促进技术发展。","text":"翻译者： 大杨， 链因智能CEO， 一家初创区块链技术公司，DEFI布道者。技术点： DEFI，ETH，NODEJS，SOLIDITY今天抽出了一些时间，翻译了CoinBase的Pete Kim 写的【Introduction to Building on DeFi with Ethereum and USDC — Part 1】DEFI编程入门学习的文章。翻了下Pete Kim的twitter和他的github，发现是个全栈高手和社区活跃者，看上去应该是韩国人，技术很不错，人也很帅 😂。最为美系的第一交易所CoinBase对整个Crypto生态的贡献是巨大的，本篇DEFI编程的入门文章也非常适合新手，看了有很想翻译的冲动，就花了2小时做了下整理，并在kovan的网络上实战了一把，对很多细节的地方做了补充，强烈推荐给大家。 经历DEFI，后续链因智能3年积累的相关技术都会进行开源，通过开源促进技术发展。以下是文章的内容：首先介绍 CoinBase 的价值观和愿景。在Coinbase，我们的任务是建立一个开放的财务系统。我们坚信，促进经济自由将使世界变得更美好。分布式金融，简称DeFi-一种开放，无边界和可编程的金融-是我们伟大愿景不可分割的一部分。智能合约DeFi由运行在分布式网络（例如以太坊（“区块链”））上的数字货币（如美元代币（USDC））智能合约组成。智能合约的想法由来实际上很简单。数字货币和密码学的先驱尼克·萨博（Nick Szabo）最初在1997年提出了这个想法，他将自动售货机描述为智能合约的始祖。自动售货机是合同的自动化版本，以电子硬件的形式表示：您通过向机器中投入钱来支付显示的价格，机器将为您分配饮料您不支付显示的价格，也不分配饮料如果您支付了显示的价格但机器没有分配饮料，或者即使您没有支付显示的价格也分配了饮料，则违反了合同自动售货机无需人工干预即可完全自主地管理其合同义务。现代智能合约的工作方式相同，但是合约条款被表示为可执行的计算机代码，而不是在硬件中实现。在其上运行智能合约的网络的分散性确保了它们以书面形式执行，并且没有任何单个实体能够弯曲规则或操纵结果。一个重要的警告是，因为网络逐字执行代码，所以错误的智能合约代码可能会导致意外的后果（“代码就是法律”）。没有比现在更好的时机许多人发现基于加密技术构建的区块链非常令人生畏，并认为只有坚韧的计算机科学家才能使用它。尽管就在几年前，情况确实如此，但自那时以来，工具和开发人员用户体验已有了显着改善，任何具有基本编程技能的人都可以开始构建。DeFi生态系统目前正在爆炸性增长。 USDC在不到2年的时间里达到了$1B的市值，并且在不到3年的时间内，存储在各种DeFi服务中的资产总值超过$2B。确实没有一个哪个领域有这么好的时机快速发展。来源：DeFi Pulse以下教程是开始开发自己的DeFi智能合约的简单指南。我们希望，这样的指南将有助于建立全球开放的民主化金融体系。入门本教程系列假定您具有JavaScript的经验，JavaScript是世界上使用最广泛的编程语言。您也可能被介绍过Solidity，这是一种在以太坊上使用的智能合约编程语言，这是世界上使用最广泛的智能合约区块链编程语言。最后，您将与DeFi应用常用稳定币USDC进行交互（这里我们Fake了一个USDC，不是真实USDC）。搭建开发环境首先，我们需要一个类似Unix的环境，并在其上安装Node.js v12.x（最新的LTS版本）。 MacOS本质上是Unix环境，Windows用户可以通过从Microsoft Store在WSL上安装Ubuntu来获得它。在MacOS和Windows中可以找到更详细的步骤。对于代码编辑器，强烈建议使用 Visual Studio Code，因为您要使用的项目模板已经预先配置好了，但是从技术上讲，您可以使用任何编辑器。哦，我更喜欢Vim而不是Emacs。设置项目设置Solidity项目需要一些工作，老实说，分心对于这个阶段的学习不是很有用，因此已经为您准备了一个预先配置的模板。这块作者提供了一个很好的模版来跑，原地址： https://github.com/CoinbaseStablecoin/solidity-tutorial ，这里我做了一些修改，FORK了一个项目地址，大家需要看代码的可以用下面的地址，作者提供的模版非常方便，可以让动手，推荐使用作者的地址。在终端中运行以下命令以下载并设置模板：12345git clone https://github.com/CoinbaseStablecoin/solidity-tutorial.git # 作者原模版地址git clone https://github.com/chaininout/solidity-tutorial.git # 这个是包含了最新代码的地址cd solidity-tutorialnpm install -g yarn # Install yarn package manager 安装包管理器yarn # Install project dependencies 安装依赖当yarn尝试构建本机扩展时，您可能会看到一些编译错误。这些是可选的，可以忽略这些错误。只要您最后看到“完成”消息，就可以继续。在Visual Studio Code中打开项目在Visual Studio Code中打开项目文件夹（solidity-tutorial）。第一次打开项目时，Visual Studio Code可能会提示您安装扩展。继续并单击“全部安装”，这将向编辑器添加各种有用的扩展，例如自动代码格式和Solidity语法突出显示。在以太坊上创建账户在以太坊上进行任何操作之前，您需要拥有一个帐户。帐户通常称为“钱包”，因为它们可以包含ETH和USDC等数字资产。最终用户通常使用Coinbase Wallet或Metamask等以太坊钱包应用程序创建帐户，但是使用模板随附的出色的ethers.js库，以编程方式创建帐户也非常简单。在src文件夹中创建一个名为createWallet.js的新JavaScript文件，然后输入以下代码：保存文件，并使用Node执行代码，如下所示：1234const ethers = require(\"ethers\");const wallet = ethers.Wallet.createRandom();console.log(`Mnemonic: $&#123;wallet.mnemonic.phrase&#125;`);console.log(`Address: $&#123;wallet.address&#125;`);在shell命令行状态下执行：1node src/createWallet.js执行后生成如下结果, 生成助记词和地址：12Mnemonic: viable glow tone pole input series weather slam blouse embark achieve positionAddress: 0x6598f11d48Da2bfA897d5Eb3968223f98dabc008刚才发生了什么？ 好吧，您拥有了一个全新的以太坊账户。 “助记符”或可能更普遍地称为“恢复短语”是从帐户执行操作所需的密钥的人类可读表示，并且地址是帐户的名称和标识符。将它们复制到某个地方。附带说明一下，本文中显示的助记符已稍作更改，以阻止您使用它，请使用您自己的助记符！可以将它们视为银行帐户的密码和帐号，只需要几秒钟即可创建一个，并且不必填写申请表或共享任何个人信息。您也可以在任何地方运行此代码。⚠️注意该帐户的记忆符号必须保密。如果丢失，您将永远无法访问您的帐户以及该帐户中存储的所有资产，没有人能够为您提供帮助！妥善保管！从技术上讲，您本身并没有真正“创建”帐户。相反，您创建的是私钥/公钥对。如果您对引擎盖下实际发生的事情感到好奇，请阅读椭圆曲线密码学以及比特币和以太坊规范BIP39，BIP32，EIP55及其在此项目中的实现。关于Gas燃料和挖矿以太坊是一个分布式网络，由世界各地成千上万的计算机组成，它们并非完全免费。要在区块链上执行任何状态更改（例如存储和更新数据），您必须向网络运营商支付以太坊（ETH）的交易费，在以太坊上也称为“ GAS”。这与运营商为在链中添加新区块而获得的奖励一样，也激励着他们保持计算机正常运行。此过程称为“挖矿”，而网络运营商称为“矿工”。我们将在本教程的后面部分（GAS，GAS价格和GAS限制）再次讨论这一点。获取测试网ETH现在您已经有一个帐户，您应该存入一些ETH。我们不想在开发时浪费真钱，因此我们将获得一些假的ETH，用于在测试网络（“ testnet”）上进行开发和测试。有许多不同的以太坊测试网，但由于容易获得测试Token，因此我们将使用Kovan。首先，让我们使用以太坊的区块浏览器Etherscan检查当前余额。为此，您可以在浏览器中输入以下网址，然后用您之前创建的地址（从0x开始）替换 0x6598f11d48Da2bfA897d5Eb3968223f98dabc008。https://kovan.etherscan.io/address/0x6598f11d48Da2bfA897d5Eb3968223f98dabc008您应该看到您的余额为0 ETH。保持此选项卡处于打开状态，然后在其他选项卡中打开Kovan Ethereum Faucet 地址： https://faucet.kovan.network。在页面中，输入您的地址，然后单击“发送给我”按钮。交易可能只需要几秒钟到一分钟或一两分钟即可完成。再次检查Etherscan，您应该在列表中看到1 ETH的新余额和一笔传入交易。资料来源：https://faucet.kovan.network以编程方式获取ETH余额连接以太坊，使用Etherscan查看余额非常有用，但是也可以通过代码轻松查看余额。但是，在回到代码之前，我们需要一种连接到以太坊的方法。有很多方法可以做到这一点，包括自己在计算机上运行网络节点，但是到目前为止，最快，最简单的方法是通过诸如INFURA或Alchemy之类的托管节点提供程序来实现，也可以自建节点。前往INFURA，创建一个免费帐户并创建一个新项目以获取API密钥（项目ID），链接这里： https://infura.io/dashboard/ethereum 注册后在面板中创建自己的Project，然后拿到APIKEY。如果要自己搭建节点，也可以使用Go Ethereum（“ geth”）和Open Ethereum（以前称为Parity Ethereum）是两种使用最广泛的以太坊节点软件，这里后续我会在后续章节中列举节点搭建。用代码查看ETH余额首先，让我们编写代码以从助记符中读取并获取帐户。在src文件夹中创建一个名为wallet.js的新JavaScript文件，然后输入以下代码：1234567891011const ethers = require(\"ethers\");// Replace the following with your own mnemonic 这里输入刚刚生成的助记词const mnemonic = \"rabbit enforce proof always embrace tennis version reward scout shock license wing\";const wallet = ethers.Wallet.fromMnemonic(mnemonic);console.log(`Mnemonic: $&#123;wallet.mnemonic.phrase&#125;`);console.log(`Address: $&#123;wallet.address&#125;`);module.exports = wallet;用您自己的代码替换助记符字符串。请注意，在生产代码中，助记符不应该这样硬编码。相反，应从配置文件或环境变量中读取它，以免例如由于将其检入源代码存储库而意外泄漏。执行代码，您应该能够看到与之前获得的地址相同的地址：123➜ solidity-tutorial git:(master) ✗ node src/wallet.jsMnemonic: viable glow tone pole input series weather slam blouse embark achieve positionAddress: 0x6598f11d48Da2bfA897d5Eb3968223f98dabc008看到生成的地址：0x6598f11d48Da2bfA897d5Eb3968223f98dabc008接下来，在同一文件夹中创建一个名为provider.js的新文件。在此文件中，我们将使用我们先前获得的INFURA API密钥初始化提供者对象。确保将API密钥字符串替换为您自己的字符串：12345678const ethers = require(\"ethers\");// 注意这里我们使用的kovan的网络，下面是infura上申请的keyconst provider = ethers.getDefaultProvider(\"kovan\", &#123; // Replace the following with your own INFURA API key infura: \"c844845b06f84d379ba3fb3bba5a1f99\",&#125;);module.exports = provider;注意这里需要在truffle-config.js进行网络配置：12345678910networks: &#123; development: &#123; host: \"localhost\", port: 8545, network_id: \"*\", &#125;, mainnet: infuraProvider(\"mainnet\", 1), ropsten: infuraProvider(\"ropsten\", 3), kovan: infuraProvider(\"kovan\", 42), //这个是我们加上的测试网络，因为比较快&#125;,最后，我们将使用在同一文件夹中新建名为getBalance.js的新文件，并通过wallet.js和provider.js来获取ETH余额：1234567891011const ethers = require(\"ethers\");const wallet = require(\"./wallet\");const provider = require(\"./provider\");async function main() &#123; const account = wallet.connect(provider); const balance = await account.getBalance(); console.log(`ETH Balance: $&#123;ethers.utils.formatUnits(balance, 18)&#125;`);&#125;main();运行代码，您将看到ETH余额！1234node src/getBalance.jsMnemonic: viable glow tone pole input series weather slam blouse embark achieve positionAddress: 0x6598f11d48Da2bfA897d5Eb3968223f98dabc008ETH Balance: 1.0代币计价我们刚刚创建的代码很容易解释，但是您可能想知道ethers.utils.formatUnits（balance，18）的作用。好吧，ETH实际上可以整除到小数点后18位，最小的面额单位称为“ wei”（发音为“ way”）。换句话说，一个ETH等于1,000,000,000,000,000,000 wei。另一个常见的面额是Gwei（发音为“ Giga-way”），为10亿魏。 getBalance方法碰巧以wei返回结果，因此我们必须通过将结果乘以10⁸将其转换回ETH。可以在这里找到所有面额的清单。您还可以使用ethers.utils.formatEther（balance），这是ethers.utils.formatUnits（balance，18）的简写。获取Testnet USDC您帐户中的ETH感到有些孤单，所以我们也想获取其中的USDC。我在Kovan测试网上部署了一个FakeUSDC智能合约。它没有专门的水龙头网站，但合同包含一项功能，在调用该功能时，您将获得一些免费的Kovan测试网USDC。如果您导航到Etherscan中的合同代码选项卡，并在合同源代码中搜索gimmeSome。这就是我们要调用的功能，用于将一些USDC发送到我们的帐户。1234567891011121314151617181920212223pragma solidity 0.6.12;contract FakeUSDC is Ownable, ERC20 &#123; constructor() public Ownable() ERC20(\"FakeUSDC\", \"USDC\") &#123; _setupDecimals(6); &#125; function mint(address account, uint256 amount) external onlyOwner &#123; _mint(account, amount); &#125; function burn(address account, uint256 amount) external onlyOwner &#123; _burn(account, amount); &#125; /** * @notice Give the caller 10 USDC (10,000,000 units) * 这里我们加了个给测试账户发送代币的方法，能够免费给账户发送USDC测试代币 */ function gimmeSome() external &#123; _mint(msg.sender, 10e6); &#125;&#125;进行交易以调用智能合约在以太坊智能合约中主要有两种类型的功能：读写和只读。前者可能导致存储在区块链中的数据发生变化，而后者纯粹是读取但从未写入。可以在不创建事务的情况下调用只读函数，因此无需支付交易费用，除非作为读写函数的一部分进行调用。另一方面，必须在交易内部调用读写功能，并且必须支付交易费（GAS）。调用gimmeSome函数会导致存储在区块链中的USDC余额发生变化，因此必须在交易内部调用它。调用智能合约功能需要一些额外的步骤，但这并不太困难。首先，我们需要找到我们要调用的函数的完整接口，也称为函数签名或函数原型。在合同源代码中再次查找gimmeSome，您将发现界面如下：1function gimmeSome() external这是一个非常简单的函数，不带任何参数，并且被标记为外部函数，这意味着该函数只能从外部调用，而不能从该协定内的其他函数调用。因为我们将在事务中直接调用此函数。显而易见，在以太坊主网络上部署的“真实” USDC合约中 不存在gimmeSome功能。 下面需要去部署智能合约，才能获取合约的地址，以便在下面调用：1MNEMONIC=\"viable glow tone pole input series weather slam blouse embark achieve position\" INFURA_API_KEY=\"c844845b06f84d379ba3fb3bba5a1f99\" truffle deploy --network=kovan我们执行 truffle deploy 命令，在kovan测试网络中发布我们写好的合约。 签名的2个是地址的私钥和INFURA的KEY，这样能够用这个账户部署合约，部署完成后将现实如下过程，部署的合约数量和总共花费的GAS的费用。123456789101112131415161718192021222324252627283_init_FakeUSDC.js================== Deploying 'FakeUSDC' -------------------- &gt; transaction hash: 0x239e6922e55957d964dec79ffc2a8667b375c87185e47a334d824ffea89d9c0f &gt; Blocks: 1 Seconds: 5 &gt; contract address: 0x4bB2ef39DD99A01BD5C11dDd25F890FeB45081e9 # 这个我们在后续要用到 &gt; block number: 21121362 &gt; block timestamp: 1600937752 &gt; account: 0x6598f11d48Da2bfA897d5Eb3968223f98dabc008 &gt; balance: 0.95161372 &gt; gas used: 1705672 (0x1a06c8) &gt; gas price: 20 gwei &gt; value sent: 0 ETH &gt; total cost: 0.03411344 ETH &gt; Saving migration to chain. &gt; Saving artifacts ------------------------------------- &gt; Total cost: 0.03411344 ETHSummary=======&gt; Total deployments: 3&gt; Final cost: 0.03985546 ETH拿到合约地址，在src文件夹中创建一个名为getTestnetUSDC.js的新文件，然后输入以下代码：12345678910111213141516171819202122const ethers = require(\"ethers\");const wallet = require(\"./wallet\");const provider = require(\"./provider\");async function main() &#123; const account = wallet.connect(provider); const usdc = new ethers.Contract( \"0x68ec573C119826db2eaEA1Efbfc2970cDaC869c4\", //这里是我们发布的合约地址 [\"function gimmeSome() external\"], //我们本次需要调用的函数名 account ); const tx = await usdc.gimmeSome(&#123; gasPrice: 20e9 &#125;); //指定gas console.log(`Transaction hash: $&#123;tx.hash&#125;`); const receipt = await tx.wait(); console.log(`Transaction confirmed in block $&#123;receipt.blockNumber&#125;`); console.log(`Gas used: $&#123;receipt.gasUsed.toString()&#125;`);&#125;main();该代码首先使用我们感兴趣的函数gimmeSome的接口实例化一个合同对象（新ethers.Contract），并将其指向testnet Fake USDC合同的地址：0x68ec⋯69c4。然后，您可以调用列出的任何功能。 gimmeSome函数本身不会接受任何参数，但是您可以将事务选项指定为最后一个参数。在这种情况下，我们给它20 Gwei的GAS价格，这将加快交易速度。本质上，与网络交互的所有方法都是异步的，并返回Promise，因此我们使用的是JavaScript的await表达式。然后，代码将打印交易哈希，这是您交易的唯一标识符，可用于跟踪进度。然后等待直到确认交易。运行代码，您将看到类似以下内容：1node src/getTestnetUSDC.js输出结果：123456➜ solidity-tutorial git:(master) ✗ node src/getTestnetUSDC.jsMnemonic: viable glow tone pole input series weather slam blouse embark achieve positionAddress: 0x6598f11d48Da2bfA897d5Eb3968223f98dabc008Transaction hash: 0xf7ca007d794ea7d530da36b8cc55f6dce3c99276d65d45e0d32ea10290505666Transaction confirmed in block 21121386Gas used: 65221瞧！您已经使用代码进行了首次以太坊交易！在Kovan Etherscan中检查您的地址和交易哈希。现在您应该看到，由于执行交易所支付的汽油费用，您现在拥有10个测试网USDC和略少于1 ETH。ℹ️如果您在Etherscan中检查交易，您会发现这是将 （0）ETH与4字节数据一起发送到合约地址的交易。如果函数调用具有参数，则将不止4个字节的数据。如果您想了解此数据的编码方式，请阅读以太坊合约ABI规范。GAS，GAS价格和GAS限额之前，我提到过，我们为交易提供20 Gwei的价格，以加快交易速度，并且脚本还显示使用的GAS量。这些都是什么意思？嗯，以太坊是一个由网络运营商组成的网络。将其视为一台世界计算机。它不是一台免费的计算机，您在该计算机上运行的每条指令都需要钱。该计算机也被世界各地的所有人共享，这意味着每个人都必须互相竞争才能在此计算机上花费时间。我们如何做到这一点？好吧，我们可以在这台计算机上拍卖时间，而您愿意为在此计算机上运行的每条计算指令支付的费用越多，网络运营商（矿工）将给您更多的时间。这种确定不是完美的，因为它可能会导致只有富人才能使用此系统的特权。但是，这是我们拥有的最差的解决方案，直到系统具有更高的可伸缩性并可以容纳更多的交易为止。回到区块链的术语上，“已使用的GAS”是您运行交易后消耗的计算资源量，“GAS价格”是您愿意为每单位天然气支付多少费用。通常，您愿意支付的费用越高，交易的优先级就越高，并且网络会更快地对其进行确认。在我们的案例中，我们使用20 Gwei作为GAS价格，使用的GAS为35121（您还可以通过在Etherscan中检查交易来找到此价格），因此总GAS成本为35121 * 20 Gwei = 702,420 Gwei 或0.00070242 ETH。由于用GAS要花钱，因此您可能需要设置您愿意花费的最大GAS上限。幸运的是，您可以设置“GAS限制”。如果交易最终需要的GAS超过指定的GAS上限，则交易将失败，而不是继续执行并消耗比您愿意支付的更多的GAS。要注意的一个副作用是，如果执行由于限制而最终失败，那么已花费的汽油量将不会退还给您。调用智能合约功能以读取数据您可以检查是否在Etherscan上收到了10 USDC，但请通过代码检查余额来确认这一点。我们在src文件夹中的创建个新文件getFakeUSDCBalance.js，内容如下：1234567891011121314151617181920212223242526const ethers = require(\"ethers\");const wallet = require(\"./wallet\");const provider = require(\"./provider\");async function main() &#123; const account = wallet.connect(provider); // Define FakeUSDC contract interface const usdc = new ethers.Contract( \"0x4bB2ef39DD99A01BD5C11dDd25F890FeB45081e9\", [ \"function balanceOf(address _owner) public view returns (uint256 balance)\", ], account ); // get eth const ethBalance = await account.getBalance(); console.log(`ETH Balance: $&#123;ethers.utils.formatEther(ethBalance)&#125;`); // Call FackUSDC balanceOf function const usdcBalance = await usdc.balanceOf(account.address); console.log(`USDC Balance: $&#123;ethers.utils.formatUnits(usdcBalance, 6)&#125;`);&#125;main();USDC是ERC20代币，因此它包含ERC20规范中定义的所有方法。 balanceOf是其中之一，其接口直接来自规格。 balanceOf是一个只读函数，因此可以免费调用，不需要作为事务提交。 最后，重要的是要注意，USDC使用6个小数位精度，而许多其他ERC20令牌使用18个精度。您可以在此处了解有关Solidity函数的更多信息。运行代码，现在您还将看到USDC余额：执行：12345➜ solidity-tutorial git:(master) ✗ node src/getFakeUSDCBalance.js Mnemonic: viable glow tone pole input series weather slam blouse embark achieve positionAddress: 0x6598f11d48Da2bfA897d5Eb3968223f98dabc008ETH Balance: 0.9497621USDC Balance: 10.0 //这里拿到了 USDC返回的数量转移ETH和USDC现在，让我们看看如何使用帐户中的ETH和USDC。转移ETH在src文件夹中创建transferETH.js并输入以下代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950const ethers = require(\"ethers\");const wallet = require(\"./wallet\");const provider = require(\"./provider\");async function main(args) &#123; const account = wallet.connect(provider); let to, value; // Parse the first argument - recipient address try &#123; to = ethers.utils.getAddress(args[0]); &#125; catch &#123; console.error(`Invalid recipient address: $&#123;args[0]&#125;`); process.exit(1); &#125; // Parse the second argument - amount try &#123; value = ethers.utils.parseEther(args[1]); if (value.isNegative()) &#123; throw new Error(); &#125; &#125; catch &#123; console.error(`Invalid amount: $&#123;args[1]&#125;`); process.exit(1); &#125; const valueFormatted = ethers.utils.formatEther(value); // Check that the account has sufficient balance const balance = await account.getBalance(); if (balance.lt(value)) &#123; const balanceFormatted = ethers.utils.formatEther(balance); console.error( `Insufficient balance to send $&#123;valueFormatted&#125; (You have $&#123;balanceFormatted&#125;)` ); process.exit(1); &#125; console.log(`Transferring $&#123;valueFormatted&#125; ETH to $&#123;to&#125;...`); // Submit transaction const tx = await account.sendTransaction(&#123; to, value, gasPrice: 20e9 &#125;); console.log(`Transaction hash: $&#123;tx.hash&#125;`); const receipt = await tx.wait(); console.log(`Transaction confirmed in block $&#123;receipt.blockNumber&#125;`);&#125;main(process.argv.slice(2));这段代码虽然比以前的代码长，但实际上只是到目前为止所学到的一切的结合。该脚本接受两个命令行参数。第一个是收件人地址，第二个是发送金额。然后，它确保提供的地址有效，提供的金额不为负，并且帐户具有足够的余额以能够发送所请求的金额。然后，它提交交易并等待确认。使用我们之前创建的createWallet.js脚本创建一个新帐户，然后尝试向新地址汇款：123➜ solidity-tutorial git:(master) ✗ node src/createWallet.js Mnemonic: put among keep license two negative version uniform claw zebra health inputAddress: 0x7B6d22b2130e585f5dacb40dE9Ff9DbD23E5CDB0我们建了个新地址，在将0.1 ETH转移到 0x7B6d22b2130e585f5dacb40dE9Ff9DbD23E5CDB0 新地址上：123456➜ solidity-tutorial git:(master) ✗ node src/transferETH.js 0x7B6d22b2130e585f5dacb40dE9Ff9DbD23E5CDB0 0.1Mnemonic: viable glow tone pole input series weather slam blouse embark achieve positionAddress: 0x6598f11d48Da2bfA897d5Eb3968223f98dabc008Transferring 0.1 ETH to 0x7B6d22b2130e585f5dacb40dE9Ff9DbD23E5CDB0...Transaction hash: 0x91cb73c1ed608eec56eb6c81319bc232c8a0a7d0023eda87d1631ac45f29f49aTransaction confirmed in block 21121715您可以在Etherscan中验证结果。我们还要测试验证逻辑是否有效, 以下是一些无效的例子：123456789101112$ node src/transferETH.js fooAddress: 0xB3512cF013F71598F359bd5CA3f53C1F4260956aInvalid address: foo$ node src/transferETH.js 0xDdAC089Fe56F0a9C70e6a04C74DCE52F86a91e13 0.1.2Address: 0xB3512cF013F71598F359bd5CA3f53C1F4260956aInvalid amount: 0.1.2$ node src/transferETH.js 0xDdAC089Fe56F0a9C70e6a04C74DCE52F86a91e13 -0.1Address: 0xB3512cF013F71598F359bd5CA3f53C1F4260956aInvalid amount: -0.1$ node src/transferETH.js 0xDdAC089Fe56F0a9C70e6a04C74DCE52F86a91e13 100Address: 0xB3512cF013F71598F359bd5CA3f53C1F4260956aInsufficient balance to send 100.0 (You have 0.89328474)转移USDC您将能够复用大部分代码。主要区别在于USDC有6个小数位，并且您必须使用ERC20规格的传递函数来执行交易。您还需要将参数“ to”和“ value”传递给转让智能合约功能，而不是以太坊交易本身。在同一文件夹中创建transferUSDC.js并输入以下内容：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061const ethers = require(\"ethers\");const wallet = require(\"./wallet\");const provider = require(\"./provider\");async function main(args) &#123; const account = wallet.connect(provider); // Define balanceOf and transfer functions in the contract const usdc = new ethers.Contract( \"0x4bB2ef39DD99A01BD5C11dDd25F890FeB45081e9\", [ \"function balanceOf(address _owner) public view returns (uint256 balance)\", \"function transfer(address _to, uint256 _value) public returns (bool success)\", ], account ); let to, value; // Parse the first argument - recipient address try &#123; to = ethers.utils.getAddress(args[0]); &#125; catch &#123; console.error(`Invalid address: $&#123;args[0]&#125;`); process.exit(1); &#125; // Parse the second argument - amount try &#123; value = ethers.utils.parseUnits(args[1], 6); if (value.isNegative()) &#123; throw new Error(); &#125; &#125; catch &#123; console.error(`Invalid amount: $&#123;args[1]&#125;`); process.exit(1); &#125; const valueFormatted = ethers.utils.formatUnits(value, 6); // Check that the account has sufficient balance const balance = await usdc.balanceOf(account.address); if (balance.lt(value)) &#123; const balanceFormatted = ethers.utils.formatUnits(balance, 6); console.error( `Insufficient balance to send $&#123;valueFormatted&#125; (You have $&#123;balanceFormatted&#125;)` ); process.exit(1); &#125; console.log(`Transferring $&#123;valueFormatted&#125; USDC to $&#123;to&#125;...`); // Submit a transaction to call the transfer function const tx = await usdc.transfer(to, value, &#123; gasPrice: 20e9 &#125;); console.log(`Transaction hash: $&#123;tx.hash&#125;`); const receipt = await tx.wait(); console.log(`Transaction confirmed in block $&#123;receipt.blockNumber&#125;`);&#125;main(process.argv.slice(2));尝试一下向新地址转1个FakeUSDC，它应该也可以正常工作：123456➜ solidity-tutorial git:(master) ✗ node src/transferUSDC.js 0x7B6d22b2130e585f5dacb40dE9Ff9DbD23E5CDB0 1Mnemonic: viable glow tone pole input series weather slam blouse embark achieve positionAddress: 0x6598f11d48Da2bfA897d5Eb3968223f98dabc008Transferring 1.0 USDC to 0x7B6d22b2130e585f5dacb40dE9Ff9DbD23E5CDB0...Transaction hash: 0xb81d2844a086750f5b6e3a71778fc4362cc913cc9960aacdce7028c627e7f49dTransaction confirmed in block 21121797恭喜你，完成了！最后看看之前的地址还有多少个ETH和USDC12345➜ solidity-tutorial git:(master) ✗ node src/getFakeUSDCBalance.js Mnemonic: viable glow tone pole input series weather slam blouse embark achieve positionAddress: 0x6598f11d48Da2bfA897d5Eb3968223f98dabc008ETH Balance: 0.84831602USDC Balance: 9.0 // 这里的USDC就剩下9个了在本教程中，您学习了如何生成帐户，查询余额，转移代币以及调用智能合约。您可能以为您对加密还不很了解，但是实际上您已经足够了解能够构建自己的加密钱包应用程序了。我们一直在编写命令行脚本来简化操作，但是如何使用基于Web的漂亮图形界面来完成作业来构建脚本呢？在本教程系列的下一部分中，我们将使用Solidity从零开始编写我们自己的以太坊智能合约，并学习如何构建自己的可与USDC交换的代币。我们还将使用今天学到的技术与该合约进行互动。敬请关注。这个是之前作者的下一篇， 之后大杨会加上如何使用脚本自动化的调用Uniswap进行自动交易。如果您对分布式金融DEFI的未来感兴趣，请关注Chaininout链因智能，大杨作为创始人，会努力的科普DEFI技能，促进生态发展。作者原文中有CoinBase的免责声明，这里略过，以下也是常规的我们的免责声明。以上表达的观点是作者的观点，并不代表Chaininout链因智能的观点和立场。信息仅用于一般教育目的，并不构成对金融产品的投资或其他建议。大杨和Chaininout对本篇内容上任何信息的准确性，完整性，及时性，适用性或有效性不做任何陈述，对于该信息的任何错误，遗漏或延误，或因其造成的任何损失，伤害或损害，概不负责。显示或使用。除非另有说明，否则本文提供的所有图像均为大杨的财产，所有商标均为其各自所有者的财产。","categories":[{"name":"blockchain","slug":"blockchain","permalink":"http://yangxinqi.com/categories/blockchain/"}],"tags":[{"name":"DEFI ETH NODEJS SOLIDITY","slug":"DEFI-ETH-NODEJS-SOLIDITY","permalink":"http://yangxinqi.com/tags/DEFI-ETH-NODEJS-SOLIDITY/"}]},{"title":"数字金融数据科学系列-Tushare实战","slug":"数字金融数据科学系列-Tushare实战","date":"2020-07-28T07:47:23.000Z","updated":"2020-11-02T03:04:30.000Z","comments":true,"path":"2020/07/28/数字金融数据科学系列-Tushare实战/","link":"","permalink":"http://yangxinqi.com/2020/07/28/数字金融数据科学系列-Tushare实战/","excerpt":"数据科学已经走入我们的生活近年来AI很热，大部分人看AI的角度，或者说切入点都和实际商业场景有很大的落差，走的是存粹的优化，做的很研究，有时候模型很准，但是难以付之行动，比如金融模型常常是快速的杀进快速杀出，倒跌手续费还赔上时间。大部分时候，做模型的成本太高，解决一个实际问题，需要不少预算来购买云端服务器，GPU资源来做大量运算，但是回归商业社会，不是实验室，不能重来，一切都得小心翼翼的向前，后退就意味着接受沉没成本，可能也因此给公司造成巨额损失。经历过几个项目，也和不少同事一起共事，往往不是模型问题，大部分是数据问题，数据的获取和清洗，已经训练集的准备和调优基本上占去了70%的时间，模型选型基本不是重点。所以说回来，还是先从数据科学的角度，来切入，底层基础搭好了，上层的模型才能稳固。所以我认为，数据科学的本质： 就是认清现在能够拿到多少资源，想产出多大效益。让我们一起来认识下数字金融模型下的数据科学的实际应用，本期给大家介绍Tushare数据组件。","text":"数据科学已经走入我们的生活近年来AI很热，大部分人看AI的角度，或者说切入点都和实际商业场景有很大的落差，走的是存粹的优化，做的很研究，有时候模型很准，但是难以付之行动，比如金融模型常常是快速的杀进快速杀出，倒跌手续费还赔上时间。大部分时候，做模型的成本太高，解决一个实际问题，需要不少预算来购买云端服务器，GPU资源来做大量运算，但是回归商业社会，不是实验室，不能重来，一切都得小心翼翼的向前，后退就意味着接受沉没成本，可能也因此给公司造成巨额损失。经历过几个项目，也和不少同事一起共事，往往不是模型问题，大部分是数据问题，数据的获取和清洗，已经训练集的准备和调优基本上占去了70%的时间，模型选型基本不是重点。所以说回来，还是先从数据科学的角度，来切入，底层基础搭好了，上层的模型才能稳固。所以我认为，数据科学的本质： 就是认清现在能够拿到多少资源，想产出多大效益。让我们一起来认识下数字金融模型下的数据科学的实际应用，本期给大家介绍Tushare数据组件。什么是TushareTushare金融大数据开放社区，免费提供各类金融数据和区块链数据，助力智能投资和创新型投资。平台特点：数据丰富： 拥有丰富的数据维度，股票，基金，期货，数字货币等行情数据，公司财务数据，基金经历等基本面数据。获取简单： SDK开发包支持语言，同时提供http restful接口，最大成都方便不同人群使用。落地方便： 提供多种数据存储方式，如Mysql,MongoDB, HDF5,CSV等，为数据获取提供了性能保证。Tushare自2014年12月起，经历了6年的发展，逐渐形成了自己的社区，与国内知名金融数据服务商，优矿，米筐，聚宽等量化平台合作，作者曾就职于通联数据，并和上海交大等高校建立合作，作为金融大数据的开源服务提供商，是一个很不错的选择。Tushare代码reviewTuShare的github上的开源代码有段时间没有更新了。本次直接review安装后的lib代码，最新版本1.2.60。github地址： https://github.com/waditu/tushare最核心的代码是 tushare/pro 目录下的 data_pro 以及 client 。 一个作为api调用的入口类，client作为api交互的client用来和服务器端收发数据用。核心代码通过requests.post 拼接post params 的方式，发送请求，返回的结果用json的方式，解析并拼接成pandas Dataframe对象，返回给上层。其他的主要是util的一些辅助类，formula.py中有一些常见的指标方法，推荐可以使用。Tushare的数字金融数据介绍tushare的数字金融数据模块，包含基础数据，行情数据，资讯数据：基础数据：全球数字货币列表， 全球数字货币交易所，交易所交易对，以及项目和交易所LOGO， 很多交易所也停止维护了。行情数据：数字货币行情， 每日市值，交易所费率，比特币每日市值，比特币每日交易量，数字货币K线资讯公告：包含了，金色财经，巴比特，比世界，交易所公告，twitter数据， twitter大V数据等。很不幸的是，大部分已经停止更新了。 最新的数据更新到6月10号，联系了维护的米哥，这块业务有个人维护，服务器费用的原因，已经暂停了部分数据的更新，缺钱来为开源的项目做贡献。 国内的开源项目，大杨也捐赠过几个，花了几千块rmb，在国内没有这样的捐助的氛围，很多开源项目很难维持下去。如何玩转TuShare开箱即用：使用pip来安装tushare:1pip install tushare安装好之后，开始些个测试来获取数据：如果注册好了，在官方网站，申请了token了之后，就可以用token来访问api获取数据了：这里申明那个交易所的那个时间段，哪个币种的数据，并将获取的数据打印出来。 最后保存成CSV文件。def test_coindayohlcv(self): token = &apos;b3a30846b80**************:89db61bf236&apos; pro = ts.pro_api(token) ex = &apos;huobi&apos; &quot;&quot;&quot; 1min 1分钟 5min 5分钟 15min 15分钟 30min 30分钟 60min 60分钟 daily 日线 week 周线 &quot;&quot;&quot; df = pro.coinbar(exchange=ex, symbol=&apos;btcusdt&apos;, freq=&apos;daily&apos;, start_date=&apos;20200301&apos;, end_date=&apos;20200728&apos;) print(df.columns) print(df) df.to_csv(&apos;{}.csv&apos;.format(ex), index=False) 结语最后，测试了下指数数据，美股数据，期货数据，外汇数据，还有港股数据，作为学习来使用，还是挺适合的，但是作为生产环境的数据源头的话，还是推荐购买，米筐，聚宽等专业的数据服务商提供的稳定的数据源,当然每年的费用6-8万也是企业才能够承受的了的，个人还是相对困难。数据的完整性还是没法保证，毕竟只有米哥一个人维护，而且通过大家捐助的方式，来收取一定的费用，来维持服务器，还有抓取程序。作为开源的一份子，tushare还是做的不错的，坚持6年也相当的不容易，数据商业化，在中国还是相当难的。 大家多给一些鼓励，如果有用，并且学到东西，可以捐助下，捐助地址： https://waditu.com/document/1?doc_id=243。为开源点赞吧。","categories":[{"name":"finance","slug":"finance","permalink":"http://yangxinqi.com/categories/finance/"}],"tags":[{"name":"数据科学 数字货币","slug":"数据科学-数字货币","permalink":"http://yangxinqi.com/tags/数据科学-数字货币/"}]},{"title":"进入数字金融行业","slug":"进入数字金融行业","date":"2020-06-22T04:54:59.000Z","updated":"2020-06-22T05:02:30.000Z","comments":true,"path":"2020/06/22/进入数字金融行业/","link":"","permalink":"http://yangxinqi.com/2020/06/22/进入数字金融行业/","excerpt":"","text":"迷茫的时候，不知道自己的未来是如何的，做下人生规划，开始找份工作，从IT行业，进入数字金融行业。以”Quantamental”为主线，开始努力学习，重新规划自己的人生。 需要补的英语，还有编程能力，还有AI能力。36岁，从新开始自己的人生。 对于编程，是热爱的，数字金融可以改变生活的状态，做自己喜欢而且能够改变生活条件的事情，是很值得的，5年规划，希望5年之后，自己不会后悔自己做的选择。 因为后悔也没用，自己选的路，在这么艰难都要走下去。数字金融我来啦！","categories":[{"name":"finance","slug":"finance","permalink":"http://yangxinqi.com/categories/finance/"}],"tags":[{"name":"数字金融","slug":"数字金融","permalink":"http://yangxinqi.com/tags/数字金融/"}]},{"title":"直面失败消除焦虑设计人生","slug":"直面失败消除焦虑设计人生","date":"2020-06-22T02:28:21.000Z","updated":"2020-06-22T04:52:42.000Z","comments":true,"path":"2020/06/22/直面失败消除焦虑设计人生/","link":"","permalink":"http://yangxinqi.com/2020/06/22/直面失败消除焦虑设计人生/","excerpt":"","text":"今天早晨，翻看朋友圈，看到lynne发到一篇读书笔记《斯坦福大学人生设计课》，看了下分析的读书笔记发现是一本蛮有见解的书，从另外的角度，来缓解焦虑，同时用简明扼要的大纲，来一步一步说明，如何克服迷茫，设计自己人生的重要性，而且给出了实际做法， 引起的读它的兴趣。读书是缓解的焦虑的好办法最近疫情影响，还有创业的行业赛代也都经历的变化，思想和心态都跌入了低谷，也背上了很大的债务， 人也变得迷茫了，尝试了做新的领域，尝试了积极主动，但是内心深处，依旧是那么的迷茫。跨过内心的徘徊，直面市场。失败没有大不了的，都是人生的一个阶段而已。","categories":[{"name":"other","slug":"other","permalink":"http://yangxinqi.com/categories/other/"}],"tags":[{"name":"人生","slug":"人生","permalink":"http://yangxinqi.com/tags/人生/"}]},{"title":"整理下简历","slug":"整理下简历","date":"2020-05-26T18:45:47.000Z","updated":"2020-05-26T19:04:56.000Z","comments":true,"path":"2020/05/27/整理下简历/","link":"","permalink":"http://yangxinqi.com/2020/05/27/整理下简历/","excerpt":"","text":"简历停下来，整理下简历，继续前行，用jekyll生成了个新的，这10年来，做了不少项目，有4个开源的，接下来把项目中用到的开源出来。体现出自己的价值，从整理简历开始，阳光的面对接下来的路。 让家里人过的幸福是最终的。xinqiyang’s resume重新进入职场，躲过危机，关注，数据，流量和交易。 让交易飞起来，才有可能实现理想。github pages 会自动执行构建，出错就不更新了。好吧，好久没更新了。","categories":[{"name":"other","slug":"other","permalink":"http://yangxinqi.com/categories/other/"}],"tags":[{"name":"简历","slug":"简历","permalink":"http://yangxinqi.com/tags/简历/"}]},{"title":"2019年终总结","slug":"2019年终总结","date":"2020-01-03T18:14:43.000Z","updated":"2020-01-03T18:21:04.000Z","comments":true,"path":"2020/01/04/2019年终总结/","link":"","permalink":"http://yangxinqi.com/2020/01/04/2019年终总结/","excerpt":"","text":"2019年，年终总结痛并快乐着的创业历程，战到最后，孤身一人，战至一兵一卒。最后：卒","categories":[{"name":"other","slug":"other","permalink":"http://yangxinqi.com/categories/other/"}],"tags":[{"name":"创业","slug":"创业","permalink":"http://yangxinqi.com/tags/创业/"}]},{"title":"低风险创业阅读笔记","slug":"低风险创业阅读笔记","date":"2019-10-25T05:52:06.000Z","updated":"2019-10-28T16:14:04.000Z","comments":true,"path":"2019/10/25/低风险创业阅读笔记/","link":"","permalink":"http://yangxinqi.com/2019/10/25/低风险创业阅读笔记/","excerpt":"序言经典名言： 千万不要卖房创业！ 千万不要卖房创业！ 千万不要卖房创业！实践名言： 创业可能亏掉一套房！创业可能亏掉一套房！创业可能亏掉一套房！读书笔记创业的初衷，你到底是为了什么？做企业最重要的是现金流，而不是净资产。从最本质的肾上腺素粉笔，到感受到爱，善意拥抱世界，拥抱创业的过程。出发点和初衷，带着爱与希望，而不是为了金钱，往往初衷不对会欲速不达，对于下属严苛，失去很多。性格好的人，结果不会坏到哪里去。","text":"序言经典名言： 千万不要卖房创业！ 千万不要卖房创业！ 千万不要卖房创业！实践名言： 创业可能亏掉一套房！创业可能亏掉一套房！创业可能亏掉一套房！读书笔记创业的初衷，你到底是为了什么？做企业最重要的是现金流，而不是净资产。从最本质的肾上腺素粉笔，到感受到爱，善意拥抱世界，拥抱创业的过程。出发点和初衷，带着爱与希望，而不是为了金钱，往往初衷不对会欲速不达，对于下属严苛，失去很多。性格好的人，结果不会坏到哪里去。创业实践中优雅的解决一个社会问题，才能影响寻常百姓的日常生活。正确的时间，正确的姿势解决一个社会问题，是对的事情，也要天时，地利，人和。创业一个是一件令人愉悦的事情， 花时间工作，然后剩下的时间陪孩子和家人。 最完美的创业模式，打造个人IP，同时还能够获得收入，这个过程是互利互惠的。克服心理问题，把创业视为人生的修炼。从用户抱怨的中，发现低风险创业的机会， 身边的人如何抱怨的，找到真正的需求点，然后着手解决。做乙方的生意模式非常危险（外包，咨询），当你江郎才尽的那天，就是公司倒闭的日子。痛点： 挖掘小数据满足用户需求产品就是小数据加上一个好的用户体验的呈现， 大部分只是改变产品包装，而不是改变产品。洞察的力量，进入实际场景，观察用户同时能够给出解决方案。忘掉你的创始人身份，开始体验产品，作为第三个灵感来源。 亲自试用自己的产品，像小白一样体验产品。把产品做简单。找到宏大的变革目标MTP， 找到目标市场足够大，存在问题，存在变革，解决的空间。我的MTP是什么？ 需要详细的描述出来。在客户最痛的点上突破，痛点到产品的一见钟情。识别真痛点和假痛点，客户真的有购买动机，能够在客户口渴的时候递出水，递给他的是半瓶救命水。没有秘密是创业者最大的风险，核心竞争力在哪里？铁杆粉丝，1000个铁杆，拉起你的产品，用户是创业者的衣食父母，也是你的力量之源。超越竞争的“10倍好”原则，如何才能拥有10倍的增长。秘密是一个慢慢积累的过程，积累一批核心用户，有了口碑。时间是最需要的东西，市场不会等待你和你的企业壮大，你只能自己真去时间，孕育出秘密之花。一切没有找对秘密的创业都是谋财害命。 谋投资人，创始人的才，害员工的命。验证商业秘密最好的方法是卖而不是问。能够让客户带来客户的销售效果，才能让产品的销售持续增长。足够价值的服务是会尖叫的。打造最小化可行性的产品，幸苦做出来的产品没有人用，悲剧了。 得不到客户认可，才是创业公司最不该犯的错误。好的用户体验，最小化，可行性。 少成本，又好用。融资需有度，钱不是越多越好。 在发现商业秘密的过程中，一定要把现金流放在最重要的位置。正向现金流，不靠融资续命。有不断流进来的现金，让自己的公司尽可能处于盈利状态。反脆弱的结构设计，人和创业秘密，商业节奏和团队管理手段，离开特定环境和北京，都难以复制。所谓反脆弱，其实就是如何应对黑天鹅时间，从随时可能发生的 不确定性中受益。人类总是过度相信经验，而不知道黑天鹅事件出现一次就足以颠覆一切。 而意外的必然性，一定会发生。黑天鹅事件，带有巨大的冲击性，会产生极端后果。发生后，可解释可预测。创业的脆弱性越强，风险也越来越大。具备反脆弱的能力，不等于坚强不屈，在必然出现的不确定风险发生时保全自我，还能让其变得更好，更有力量。合作让双方都具备反脆弱能力，在不确定中，找到生存点和发展点。设计反脆弱的商业结构，成本有底线，收益无上限。找到问题，设计一套反脆弱的模型，IP生意，需要看到本质。找到“非对称交易”的机会， 这个世界是曲线的。 损失和收益并不完全对应。创业者可以不断试错，不断调整，以期实现收益最大化和风险最小化。固定资产不产生任何收益，靠亏损维持不是长久之计。创业需要情怀，员工有匠人精神。 情怀，热爱，真诚，专注。创业最痛苦的事，莫过于只把事业当作谋生的工具。没有经历过痛苦，不懂得欢乐。情怀的价值所在，人要经历痛苦才明白。配置你的“创业杠铃”， 好的企业家不是善于冒风险，而是善于控制风险。你在一个领域安全，另外一个领域才能创新。修炼“君子不器”。让你成为全方位，多向度的人。不能够一条路走到黑，要有选择权。只要我们能够在内容层面不断精进突破，就不担心某一天会遭遇不确定性。通过思维方式的转变，扩大自己的生意的选择空间，让自己的风险发生时，有可以选择杠铃的另一端。大前提保证自己的安全，成功最好，不成功也不会伤经动骨。能力陷阱和资源陷阱，先看自己的能力和资源做什么，而不是设计一套反脆弱的商业结构。赋能生物态团队，创业是孤独而寒冷的路，会渐渐失去热情而难以持久，容易迷失。需要“群智涌现，彼此协同”创业团队是复杂体系，不能机械化管理，需要打造应对不确定性的敏捷团队。 需要为社会做贡献，不断成长。 要善待一起的兄弟，也不能过于安稳。重新定义成功，成功的思维模式，倡导终生成长。 能够守住底线，让员工犯错误，能够一起承担错误。建员工迟早会离开团队，离开才是最大的不稳定。有些创业者格局不够大，从气量就可以看出来。创业过程中，核心员工，兼职的千万不能要，三心二意的坚决清理。突产品十万人说不错，不如一百人尖叫。 优质的产品，偏向于营销推广。客户只会给你一次机会，学会珍惜自己的品牌。不着急打广告和买流量。产品重要，用户才会分享。让客户为你带来新的客户。让用户主动分享，专业化，简单化，情绪化，可视化，故事化。广告是必须做的，广告要持续，定下来不能经常变。唤醒大众情绪，才能被大量传播。用故事打败只是的诅咒， 将一个好的故事，好想法和好故事，好IP才行。学会用幂次法则思考，线性思想被幂次法则取代。 头部公司带来偏好链接，形成马太效应。 想法流，实现指数型增长。突运营让边际成本为零的运营方法，增加一个用户所需要支付的成本，决定创业是否成功的关键。内容和程序，生产的成本是一样的， 可以卖的人越来越多。只运营信息，杜绝将大部分精力用于维护用户和商家的平台系统，边际成本自然能够大幅降低。学会撬动资源刚刚，用梦想感召他人，MTP，宏大的变革目标，用你的梦想去感召更多的人，一起实践这个梦想。对于团队培养2个接班人。找到指数型增长的关键节点，列出工作流，要点，注意事项。 清单管理时间，找出关键点。手里有收入更好的更从容的解决问题，提高用户体验，找代理商。 在全球范围内找最合适的代理商。二周一个关键点，找到方向有实际结果。保增长搭建跨部门的增长小组，增长这件事人不能多。只有增长，最重要只有增长才能创造奇迹下2周多目标，看这周的实际数据企业的下一个增长方向应该取决于数据，它决定了你该做什么事，不该做什么事。让增长小组进行实验，监控，反馈。 6个角色，增长负责人，产品经理，工程师，营销专员，数据分析师和设计师。 获得支持，多实验，高效沟通。天下武功，唯快不破。唯一限制我们的是我们的想象力。最后做最好的自己，终生成长，创业也许是一个过程，也是会持续一生，但是 勿忘初心，用爱前行。 我错了，我改正。 樊登读书真心很不错，强烈推荐下。 微信读书，每天的时间应该都给他。","categories":[{"name":"other","slug":"other","permalink":"http://yangxinqi.com/categories/other/"}],"tags":[{"name":"创业","slug":"创业","permalink":"http://yangxinqi.com/tags/创业/"}]},{"title":"践行时间管理","slug":"践行时间管理","date":"2019-10-21T02:28:55.000Z","updated":"2019-10-28T16:13:52.000Z","comments":true,"path":"2019/10/21/践行时间管理/","link":"","permalink":"http://yangxinqi.com/2019/10/21/践行时间管理/","excerpt":"回归经历了近2年的全力创业历程，发现自己欠缺的太多太多。从本质上来讲，是自己的心态以及具体的执行层面，很多事情的抉择很容易受到心态的干扰。 做事情欠缺全盘考虑。回到内心初衷， 进行深刻的反省。先从时间管理开始，忙是一种状态，一直忙碌好几年，遵循着不好的时间分配原则，导致效率低下，还有花在某个点上的时间太多，导致面上整理出现不协调。 买了微信读书的会员，不知不觉，以及收藏了近300本书，认真的看着这些书，为自己充充电，才能继续前行。​","text":"回归经历了近2年的全力创业历程，发现自己欠缺的太多太多。从本质上来讲，是自己的心态以及具体的执行层面，很多事情的抉择很容易受到心态的干扰。 做事情欠缺全盘考虑。回到内心初衷， 进行深刻的反省。先从时间管理开始，忙是一种状态，一直忙碌好几年，遵循着不好的时间分配原则，导致效率低下，还有花在某个点上的时间太多，导致面上整理出现不协调。 买了微信读书的会员，不知不觉，以及收藏了近300本书，认真的看着这些书，为自己充充电，才能继续前行。​ 时间管理和生活态度好的经验别人告诉你，但是你自己不实践，没有意义。时间对于每个人是一样的， 其多少是效率问题，更关乎自己的生活态度。一些不好的例子残酷错误： 不整理。解决方法： 整理东西，尽量少买，丢掉不需要的。 各种购物软件，淘宝，京东，尽量少打开，还有小红书。残酷错误：拖来拖去，事情都在那里，只多不少解决方法： 拖延因为没有开始，开始起来就好了。 行动吧。 马上行动，马上行动，马上行动。残酷错误： 承若的大事情，不能善始善终解决方法： 大事情分解成小事情，身体力行。 行动行动，先把小事情做好。残酷错误： 决策遇上选择恐惧症解决方法： 每天晚上列出明天应该必须做的5件最重要的事情。残酷错误： 很多待办TODO列表解决方法： 把待办变成必办，其他的事情就会迎刃而解。残酷错误： 各种干扰以及时间顺序不当解决方法： 有些事情说不，整理生活碎片，想干扰说不， 不给干扰开口的机会。残酷错误： 忙得焦头烂额，嘴上还在说好好好解决方法： 不经常说不，问题很严重， 不管是谁的拜托，应该权衡之后在去做。残酷错误： 网络世界里经常欲罢不能解决方法： 离开位置，离开电脑，说不，网络上的事情，尽量少打开各类必须软件。 特别是 微信，微博，twitter之类的，以及各种的视频软件。 整理自己的电脑及手机，把消耗自己时间的APP全部干掉，电脑上的不用的统统卸载。残酷错误： 做了很多低于自己时间估值的事情解决方法： 事情可不可以分出去给其他人做，低于自己时间价值的事情，坚决不做。残酷错误： 开会花太多的时间解决方法： 小会5分钟， 大会30-45分钟，切记不要超过45分钟。残酷错误： 大部分时间在工作上，在客户那边解决方法： 留时间给自己以及家人，这个世界安排第一优先，这样你才能做的更好。残酷错误： 没有陪孩子，教育的时间太少解决方法： 和家人和孩子一起用早餐和晚餐，具体询问一些具体的事情，学校还有朋友啊，相互问候，陪孩子玩游戏，单独带他们出去玩， 给他们分配清单培养他们独立购买的能力。 星期天一家人聚在床上说话，增加家庭温馨感。残酷错误： 好久没有一家人旅行了解决方法： 规划一个假期，提前规划好，不要因为公事而影响一家人的出游放松。 提早计划。残酷错误： 没有在理财上花时间解决方法： 定期一个月，一个季度，半年，一年，对家庭财务进行整理，列出花费，到年末了需要进行年末调整了。残酷错误： 没有花时间在锻炼身体上解决方法： 看着自己的大肚子，每天锻炼坚持10分钟，比如平板撑，还有做收肚子的5组运动，先锻炼起来，去掉大肚子。残酷错误： 没有给自己留时间解决方法： 自我日，关键日，事物日要分清，这样才能规划好，自我日最优先，先把自己的时间安排好，才能够做好关键和事物安排。 聚集5种最大收益的活动，每天必须完成5种活动。残酷错误： 思想没有升级解决方案： 对自己的细节，行为，举止，外观气质等没有很好的关注。 需要做到 少即是多， 倾听少说，不要乱买了， 特别是那些便宜的所谓性价比高的东西，必须买顶配，而且尽量少买。总结需要多花时间，看书，总结，践行自己的修改，类似程序写了后的review和打patch是一样的。 人需要打补丁，需要不断的循序渐进的优化自己的行为，提高自己的气质的，最基本的是做好自己的时间安排，将大部分的时间花在自己有益的事情上面。 对自己好了，只有自己好了，才能够带动其他人，好起来。","categories":[{"name":"other","slug":"other","permalink":"http://yangxinqi.com/categories/other/"}],"tags":[{"name":"other","slug":"other","permalink":"http://yangxinqi.com/tags/other/"}]},{"title":"一年的产出","slug":"一年的产出","date":"2019-08-02T06:51:49.000Z","updated":"2019-10-28T16:13:30.000Z","comments":true,"path":"2019/08/02/一年的产出/","link":"","permalink":"http://yangxinqi.com/2019/08/02/一年的产出/","excerpt":"​ 一年积累下来23个项目，一年下来，忙活代码行数，超过10w+。 涵盖了数据库， app的， 后端模块， 发布模块，以及前端，还有网站，部署等等。使用了包含java,python,php,js,sh,go, sodility 共计7种语言。产品产品发布后，提供给用户使用，接下来做好定价后，开始买卖吧。产品需要市场的体验，才行的。在国内有各种卖法，如何让用户能够更容易的找到我们，还是很关键的。","text":"​ 一年积累下来23个项目，一年下来，忙活代码行数，超过10w+。 涵盖了数据库， app的， 后端模块， 发布模块，以及前端，还有网站，部署等等。使用了包含java,python,php,js,sh,go, sodility 共计7种语言。产品产品发布后，提供给用户使用，接下来做好定价后，开始买卖吧。产品需要市场的体验，才行的。在国内有各种卖法，如何让用户能够更容易的找到我们，还是很关键的。拥抱开源接下来，还是做一个开源的项目，让大家可以用的很happy，让大家能够放心，这样的话。接下来我们的项目 https://github.com/coinphd 项目都在这里，欢迎大家参观。拥抱区块链拥抱区块链，在区块链上，做自己的应用，服务市场，服务客户。这个才是我们应该做的，这样的话，成本可以减少下来，但是我们的产品，能够得到大家的认同，这样才能够活下来，走出去。技术成就梦想开发和运营集合起来，ansible很好用，docker也很好用，用技术实现梦想，才是最近这个阶段应该做的事情的。","categories":[{"name":"devops","slug":"devops","permalink":"http://yangxinqi.com/categories/devops/"}],"tags":[{"name":"devops","slug":"devops","permalink":"http://yangxinqi.com/tags/devops/"}]},{"title":"创业一周年快乐","slug":"记回国创业的一年","date":"2019-08-02T05:38:33.000Z","updated":"2019-10-28T16:13:44.000Z","comments":true,"path":"2019/08/02/记回国创业的一年/","link":"","permalink":"http://yangxinqi.com/2019/08/02/记回国创业的一年/","excerpt":"​一周年快乐2019年8月，距离去年回国创业已经整整一年了，一年里，时局变迁，做一个流水账的记录。 创业犹如踩坑，经历过，才知道，原来这么小的坑，有这么大，足以吞噬，在让你浴火重生。帮助过的人，应该感恩，坑过的人，依旧应该感恩。​","text":"​一周年快乐2019年8月，距离去年回国创业已经整整一年了，一年里，时局变迁，做一个流水账的记录。 创业犹如踩坑，经历过，才知道，原来这么小的坑，有这么大，足以吞噬，在让你浴火重生。帮助过的人，应该感恩，坑过的人，依旧应该感恩。​ 回到原点也许开始就是错的，那接下来不管怎么做都是错的。起点的配置已经决定了未来的结局。不能去撑及时止损，受用一生，当一个团队，没有斗志，那么应该选择重来，而不应该撑。 可以的人，可以的事，自然而然，当你去硬撑的时候，未必有好的结果，反而会带来更多的伤害，不管是金钱上，还是精神上的。 闻到坏味道，就应该立即处理，OUT出团队，这个是最最关键的。孤独感当团队没有人的时候，应该控制好节奏，就算在孤独，也应该一步一步，不能忽视指标，一切以指标论英雄，才是最好的。 不管在孤独，也不应该失去心智，创业从来都是孤独的，很多时候，悲欢亦不可与人分享，在亲密的团队都是如此。 作为创始人，应该坚持走自己的路。指标指标指标指标，自己引以为要的 数据，流量，交易。 还是一直停留在数据上。数据： 有用的数据，高质量的内容， 可以销售的服务，都算。流量： 每天多少pv，多少uv，都在哪里，跑不掉的，一切以实际的数据说话，都在这边。交易： 每天多少笔交易。 实际利润率多少，成单多少，未成单多少。必须严格执行。 一切必须严格的执行。 对团队的懒散，是对自己最大的伤害。 所以一切回归初心。责任感对投资人负责，也是对自己家里人负责。 减负之后，感觉好多了。没有那么多的负担，不用每天起来寻思着，今天公司花了多少钱，还有哪些事情没有做，还需要做哪些事情？网红思考现在的网红经济， 是一个很新颖的领域，一个小团队，发挥自己的能动性，带来不错的收入。 这里的网红，不单单指的是现在所谓的直播网红，是个泛指。其实通过网络的个性活动，还是能够带来不少流量，这些流量和这些粉丝还是可以变现的。 走小团队的路，在现在资本惨淡的环境下，还是很切合实际的。动动笔头最近一年，一直在写代码，不断的填坑，不断的填坑，把坑都处理完后。 还是多输出，可以多些一些内容，这点其实很关键。 输出就是分享，能够和很多人，产生共鸣的同时，也能够提高自己。时间留给自己和家人这一年，最应该说对不起的就是家里人， 一个人在国内，其实现在的状态和之前，还是发生了很大的变化的。 如何抽出更多的时间，需要养成一个习惯。回到原点重新开始如果还有一次机会摆在你面前，你会如何抉择呢。也许还是和现在一样吧。不过避免填坑了，填了这么多的坑，应该变的更果断，更现实，这样才行。人生追求是什么家人健健康康，平平安安，我也能够陪伴在他们左右，现在这样过程，应该只是短暂的。 5年一闪而过，人生亦无几个5年。 其实走出来，简简单单就是福。 否极泰来，终其一生的追求，到最后，其实发现，简单就是美好。END","categories":[{"name":"other","slug":"other","permalink":"http://yangxinqi.com/categories/other/"}],"tags":[{"name":"other","slug":"other","permalink":"http://yangxinqi.com/tags/other/"}]},{"title":"清明时节的回忆","slug":"清明时节的回忆","date":"2019-04-05T13:17:54.000Z","updated":"2019-04-06T07:03:32.000Z","comments":true,"path":"2019/04/05/清明时节的回忆/","link":"","permalink":"http://yangxinqi.com/2019/04/05/清明时节的回忆/","excerpt":"","text":"清明时节的回忆思念的日子，祭！今天许久没聊的好哥们，好兄弟，晒娃了， 刚刚到北京的时候，备受他的照顾，聊及人生选择，一向如此。聊到感触最深的，当遇到抉择的时候，总是选择出问题，导致没搭上好的车。BAT之间选择，总是看的比较近，没有着眼于潜在，对于未来发展的预估和判断都是有问题的。行业选择及跟对人行业的选择，程序员是没错的，在外人看来，高收入，在的公司也挺好。 但是在跟对人这个基础上，看的还是很不寻常的，提早跟对人，比坚持下来，然后就发达的，作为公司股东的大有人在。 小米早进去的人，现在还在位置上的，做的好的，大有人在，就是这个道理。创业一种自虐的选择当机会错过， 没有跟对人，也没有赶上大环境，出来博一把的心态，这就是创业。今年的创业环境要求很不一样，不比前2-3年的创投蜂拥而上，不比之前的宽松环境，现在还是需要靠谱的数据来支撑。清明当觉醒创业公司，也同样存在生死生命线，年后很多公司和组织退出这个行业，区块链行业也从热门行业到现在的云淡风轻，而且还备受歧视。 当公司只有半年可以活的时候，是否拼尽全力继续活下来，还是说放弃抵抗，岁月静好的等着？","categories":[],"tags":[{"name":"other","slug":"other","permalink":"http://yangxinqi.com/tags/other/"}]},{"title":"2018年年终总结主题活下去","slug":"2018年年终总结主题活下去","date":"2018-12-28T07:19:19.000Z","updated":"2018-12-28T07:28:34.000Z","comments":true,"path":"2018/12/28/2018年年终总结主题活下去/","link":"","permalink":"http://yangxinqi.com/2018/12/28/2018年年终总结主题活下去/","excerpt":"","text":"2018年 年终总结 主题 活下去2018年的最后一个工作日，回顾下整年的发展，一切过往历历在目，在梳理下。展望20192019年，小目标 500万 人民币营收结语一切都是拼出来的，爱拼才会赢。","categories":[],"tags":[{"name":"other","slug":"other","permalink":"http://yangxinqi.com/tags/other/"}]},{"title":"入行区块链金融","slug":"入行区块链金融","date":"2018-12-02T15:20:32.000Z","updated":"2018-12-02T15:35:10.000Z","comments":true,"path":"2018/12/03/入行区块链金融/","link":"","permalink":"http://yangxinqi.com/2018/12/03/入行区块链金融/","excerpt":"","text":"距离上一篇博文，已经过去整整10个月之多了。从踌躇的观望，到ALL IN区块链，到现在Lead公司杀入区块链金融行业，转眼又是12个月，一年即将过去，内心的不安和焦虑感与日俱增。 更是看到龙哥团队，所有的成员都在著书写博，我们不能落后。区块链的未来是什么样的？未来是什么样的，现在还是看不到，从ICO,STO的概念的突起，到近期的股票金融类专业人士，携大额资金杀入这一领域，传统的区块链老人，与之形成较大的对比，虽然现在这一领域，市场在逐渐萎靡，市值整体在减小，除了传统的BTC（以及衍生出来的BCHABC，BCHSV）以及有实际应用产品的Ripple，中国人市场主推的ETH，EOS，在最近的几个月，市值缩水更严重。 走出中国放眼世界，看区块链在各个国家的发展情况，整体来看，BTC的需求还是依然存在，但是BTC对整个区块链技术的发展，还是有推动作用的。整体来看看好区块链金融的发展。个人资产管理及企业机构个人资产管理，还是没有一个很好的工具来实际的做到这一点，从最早的个人资金记账，到现在支付宝及各种P2P理财公司，用户很难实际掌握自己的资产，以及实现资产的保值。企业机构在传统的领域转型过来，针对全球的市场的数量增加，也没有很成熟的一套机制来保障资产的安全，以及能够套用现在其他市场中的工具来解决管理的问题。这块是一个很好的点。结语先说这2点，最近需要更勤奋了。","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"http://yangxinqi.com/tags/blockchain/"}]},{"title":"区块链数据分析之保存币安历史数据","slug":"区块链数据分析之保存币安历史数据","date":"2018-02-06T01:29:25.000Z","updated":"2018-02-06T06:10:48.000Z","comments":true,"path":"2018/02/06/区块链数据分析之保存币安历史数据/","link":"","permalink":"http://yangxinqi.com/2018/02/06/区块链数据分析之保存币安历史数据/","excerpt":"最近币圈大跌，作为一棵吊在高处的韭菜，还是觉得好好的做开发比跟风靠谱多了，遂静下心来，好好的写点文章，做点数据分析，抓取进阶下。接触区块链其实在三年前，一个朋友就提醒我们多关注区块链，那个时候的我们还是少不更事的认为那个虚的东西又撒好玩的，到现在回首看，眼界比技能和运气要重要得多。做人没有好的眼光，上不去的，还是捡起来好好的分析下区块链技术，后续会多些一些。言归正传，最近在分析各个交易所的数据，对接了几个交易所（bitflyer， coincheck， binance，btcbox）后续在对接一些其他的。首先作为技术出身，还是好好的做数据分析吧，先爬一些数据下来，就到处找相关的接口文档，然后通过python来把数据抓下来。这块就需要大家提供的访问api，有很多人写了交易所第三方的访问api，发布在github上，我们就使用这些api来访问以获取数据。看了好几篇文章，第一篇先给澳大利亚的一个大叔级高手打广告，翻译下他的文章，这个哥们写了好几个交易所的获取客户端。原文链接： https://sammchardy.github.io/binance/2018/01/08/historical-data-download-binance.html","text":"最近币圈大跌，作为一棵吊在高处的韭菜，还是觉得好好的做开发比跟风靠谱多了，遂静下心来，好好的写点文章，做点数据分析，抓取进阶下。接触区块链其实在三年前，一个朋友就提醒我们多关注区块链，那个时候的我们还是少不更事的认为那个虚的东西又撒好玩的，到现在回首看，眼界比技能和运气要重要得多。做人没有好的眼光，上不去的，还是捡起来好好的分析下区块链技术，后续会多些一些。言归正传，最近在分析各个交易所的数据，对接了几个交易所（bitflyer， coincheck， binance，btcbox）后续在对接一些其他的。首先作为技术出身，还是好好的做数据分析吧，先爬一些数据下来，就到处找相关的接口文档，然后通过python来把数据抓下来。这块就需要大家提供的访问api，有很多人写了交易所第三方的访问api，发布在github上，我们就使用这些api来访问以获取数据。看了好几篇文章，第一篇先给澳大利亚的一个大叔级高手打广告，翻译下他的文章，这个哥们写了好几个交易所的获取客户端。原文链接： https://sammchardy.github.io/binance/2018/01/08/historical-data-download-binance.html正文任何交易策略的基础都是有一个好的回测方案，如果你没有数据，就没法回测，数据还是很重要的。在这篇文章中，我将详细描述通过Binance API在指定时间范围内下载和保存币安的历史K线数据。这个例子不需要有币安的账户，直接访问公开的API即可。首先需要处理时间格式因为币安服务器只接受毫秒级别的时间戳的时间段，所以需要将工作日时间转换为毫秒时间戳。本次使用强大的python来进行处理，安装dateparser包。命令如下：1pip install dateparser我们可以得写个函数将日期字符串直接转换成毫秒格式。例子如下：123print(date_to_milliseconds(\"January 01, 2018\"))print(date_to_milliseconds(\"11 hours ago UTC\"))print(date_to_milliseconds(\"now UTC\"))获取币安的K线数据现在我们希望通过 get_klines API来获取实际的交易量数据。先看下接口参数：12345symbol - e.g ETHBTC 币种数据interval - one of (1m, 3m, 5m, 15m, 30m, 1h, 2h, 4h, 6h, 8h, 12h, 1d, 3d, 1w, 1M) 时间范围limit - max 500 限制条数startTime - milliseconds 开始时间 单位毫秒endTime - milliseconds 结束时间 单位毫秒因为一次最多取500条，如果时间范围比较大，我们得循环获取。返回结果格式：1234567891011121314[ 1499040000000, # Open time \"0.01634790\", # Open \"0.80000000\", # High \"0.01575800\", # Low \"0.01577100\", # Close \"148976.11427815\", # Volume 1499644799999, # Close time \"2434.19055334\", # Quote asset volume 308, # Number of trades \"1756.87402397\", # Taker buy base asset volume \"28.46694368\", # Taker buy quote asset volume \"17928899.62484339\" # Ignore ]我们把返回的结果都存储起来，有多少存多少。币安时间间隔intervals参数中的intervals是一个字符串，一次请求只能是在某个范围内，一次限制是500，所以需要获取较长时间段数据的话，需要对时间间隔进行毫秒转换。将API中设定的时间，转换成毫秒， 例子如下：12345from binance.client import Clientprint(interval_to_milliseconds(Client.KLINE_INTERVAL_1MINUTE))print(interval_to_milliseconds(Client.KLINE_INTERVAL_30MINUTE))print(interval_to_milliseconds(KLINE_INTERVAL_1WEEK))获取K线数据准备好了之后，我们开始写方法来获取历史数据。 我们通过时间范围和intervals间隔参数很容易的获取。例子如下：12345678910from binance.client import Client# fetch 1 minute klines for the last day up until nowklines = get_historical_klines(\"BNBBTC\", Client.KLINE_INTERVAL_1MINUTE, \"1 day ago UTC\")# fetch 30 minute klines for the last month of 2017klines = get_historical_klines(\"ETHBTC\", Client.KLINE_INTERVAL_30MINUTE, \"1 Dec, 2017\", \"1 Jan, 2018\")# fetch weekly klines since it listedklines = get_historical_klines(\"NEOBTC\", KLINE_INTERVAL_1WEEK, \"1 Jan, 2017\")完整的代码可以从python-binance项目的例子中获取，链接： examples folder保存到文件获取到的数据后存到文件以方便后面使用。代码如下：123456789101112131415161718192021import jsonfrom binance.client import Clientsymbol = \"ETHBTC\"start = \"1 Dec, 2017\"end = \"1 Jan, 2018\"interval = Client.KLINE_INTERVAL_30MINUTEklines = get_historical_klines(symbol, interval, start, end)# open a file with filename including symbol, interval and start and end converted to millisecondswith open( \"Binance_&#123;&#125;_&#123;&#125;_&#123;&#125;-&#123;&#125;.json\".format( symbol, interval, date_to_milliseconds(start), date_to_milliseconds(end) ), 'w' # set file write mode) as f: f.write(json.dumps(klines))打赏功能这些好的方法，已经添加到python-binance方便大家使用。date_to_milliseconds 和 interval_to_milliseconds已经添加到binance.helpers中。get_historical_klines已经添加到finance.client中，直接调用即可。代码如下：123456import jsonfrom binance.client import Clientclient = Client(\"\", \"\")klines = client.get_historical_klines(\"ETHBTC\", Client.KLINE_INTERVAL_30MINUTE, \"1 Dec, 2017\", \"1 Jan, 2018\")接下来使用这些获取的数据，我们可以在后续的回测中使用。使用Kucoin交易所的用户同样使用python-kucoin 也有这些功能。后续还会写一些使用 pandas 和 TA-Lib 来进行简单的回测的文章。结语sammchardy 是一个很帅的澳洲哥们，大家可以在twitter上关注他， 作为开源的api客户端，写的也非常的便捷，对于这样有分享的精神的哥们，大家是不是给点打赏呢，他也给了Donate地址了。大家可以查看原文。我在最后也贴下全文例子的链接：save_historical_data.py 大家可以下下来实际的跑一下试试。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146import timeimport dateparserimport pytzimport jsonfrom datetime import datetimefrom binance.client import Clientdef date_to_milliseconds(date_str): \"\"\"Convert UTC date to milliseconds If using offset strings add \"UTC\" to date string e.g. \"now UTC\", \"11 hours ago UTC\" See dateparse docs for formats http://dateparser.readthedocs.io/en/latest/ :param date_str: date in readable format, i.e. \"January 01, 2018\", \"11 hours ago UTC\", \"now UTC\" :type date_str: str \"\"\" # get epoch value in UTC epoch = datetime.utcfromtimestamp(0).replace(tzinfo=pytz.utc) # parse our date string d = dateparser.parse(date_str) # if the date is not timezone aware apply UTC timezone if d.tzinfo is None or d.tzinfo.utcoffset(d) is None: d = d.replace(tzinfo=pytz.utc) # return the difference in time return int((d - epoch).total_seconds() * 1000.0)def interval_to_milliseconds(interval): \"\"\"Convert a Binance interval string to milliseconds :param interval: Binance interval string 1m, 3m, 5m, 15m, 30m, 1h, 2h, 4h, 6h, 8h, 12h, 1d, 3d, 1w :type interval: str :return: None if unit not one of m, h, d or w None if string not in correct format int value of interval in milliseconds \"\"\" ms = None seconds_per_unit = &#123; \"m\": 60, \"h\": 60 * 60, \"d\": 24 * 60 * 60, \"w\": 7 * 24 * 60 * 60 &#125; unit = interval[-1] if unit in seconds_per_unit: try: ms = int(interval[:-1]) * seconds_per_unit[unit] * 1000 except ValueError: pass return msdef get_historical_klines(symbol, interval, start_str, end_str=None): \"\"\"Get Historical Klines from Binance See dateparse docs for valid start and end string formats http://dateparser.readthedocs.io/en/latest/ If using offset strings for dates add \"UTC\" to date string e.g. \"now UTC\", \"11 hours ago UTC\" :param symbol: Name of symbol pair e.g BNBBTC :type symbol: str :param interval: Biannce Kline interval :type interval: str :param start_str: Start date string in UTC format :type start_str: str :param end_str: optional - end date string in UTC format :type end_str: str :return: list of OHLCV values \"\"\" # create the Binance client, no need for api key client = Client(\"\", \"\") # init our list output_data = [] # setup the max limit limit = 500 # convert interval to useful value in seconds timeframe = interval_to_milliseconds(interval) # convert our date strings to milliseconds start_ts = date_to_milliseconds(start_str) # if an end time was passed convert it end_ts = None if end_str: end_ts = date_to_milliseconds(end_str) idx = 0 # it can be difficult to know when a symbol was listed on Binance so allow start time to be before list date symbol_existed = False while True: # fetch the klines from start_ts up to max 500 entries or the end_ts if set temp_data = client.get_klines( symbol=symbol, interval=interval, limit=limit, startTime=start_ts, endTime=end_ts ) # handle the case where our start date is before the symbol pair listed on Binance if not symbol_existed and len(temp_data): symbol_existed = True if symbol_existed: # append this loops data to our output data output_data += temp_data # update our start timestamp using the last value in the array and add the interval timeframe start_ts = temp_data[len(temp_data) - 1][0] + timeframe else: # it wasn't listed yet, increment our start date start_ts += timeframe idx += 1 # check if we received less than the required limit and exit the loop if len(temp_data) &lt; limit: # exit the while loop break # sleep after every 3rd call to be kind to the API if idx % 3 == 0: time.sleep(1) return output_datasymbol = \"ETHBTC\"start = \"1 Dec, 2017\"end = \"1 Jan, 2018\"interval = Client.KLINE_INTERVAL_30MINUTEklines = get_historical_klines(symbol, interval, start, end)# open a file with filename including symbol, interval and start and end converted to millisecondswith open( \"Binance_&#123;&#125;_&#123;&#125;_&#123;&#125;-&#123;&#125;.json\".format( symbol, interval, date_to_milliseconds(start), date_to_milliseconds(end) ), 'w' # set file write mode) as f: f.write(json.dumps(klines))执行例子:1python3 save_historical_data.py生成文件：1Binance_ETHBTC_30m_1512086400000-1514764800000.json返回结果例子：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100[ [ 1512086400000, \"0.04368400\", \"0.04375100\", \"0.04334200\", \"0.04366500\", \"2081.85600000\", 1512088199999, \"90.79655078\", 3904, \"976.19100000\", \"42.59074736\", \"271480.34213668\" ], [ 1512088200000, \"0.04360200\", \"0.04369900\", \"0.04325100\", \"0.04350100\", \"2420.48100000\", 1512089999999, \"105.27683806\", 2775, \"1133.24800000\", \"49.31486895\", \"271300.32546398\" ], [ 1512090000000, \"0.04350100\", \"0.04379400\", \"0.04304900\", \"0.04370500\", \"2192.51500000\", 1512091799999, \"95.48824264\", 2359, \"1029.30200000\", \"44.86783356\", \"271143.81327337\" ], [ 1512091800000, \"0.04374900\", \"0.04392000\", \"0.04361300\", \"0.04378100\", \"1482.24800000\", 1512093599999, \"64.86877196\", 2112, \"704.81600000\", \"30.85380066\", \"271394.84389969\" ], [ 1512093600000, \"0.04375800\", \"0.04424900\", \"0.04364800\", \"0.04403800\", \"2073.49800000\", 1512095399999, \"90.95341447\", 2763, \"996.44700000\", \"43.72006243\", \"271126.63134592\" ], [ 1512095400000, \"0.04400500\", \"0.04421400\", \"0.04380000\", \"0.04389900\", \"1675.47800000\", 1512097199999, \"73.62046216\", 1817, \"808.25500000\", \"35.52008528\", \"271368.11447690\" ], [ 1512097200000, \"0.04390400\", \"0.04413600\", \"0.04364200\", \"0.04400500\", \"2138.10400000\", 1512098999999, \"93.95901243\", 2260, \"1157.93700000\", \"50.88996640\", \"271143.40315253\" ]]大家可以试试，在后续回测中可以用到。如果大家遇到报错，请升级下cryptography的包，命令如下：1pip3 install -U cryptography后续我也会多些一些原创的区块链技术方面的文章。","categories":[{"name":"blockchain","slug":"blockchain","permalink":"http://yangxinqi.com/categories/blockchain/"}],"tags":[{"name":"block chain, binance, historical data","slug":"block-chain-binance-historical-data","permalink":"http://yangxinqi.com/tags/block-chain-binance-historical-data/"}]},{"title":"将blog迁移到hexo了","slug":"将blog迁移到hexo了","date":"2018-02-06T01:14:00.000Z","updated":"2018-02-06T09:53:38.000Z","comments":true,"path":"2018/02/06/将blog迁移到hexo了/","link":"","permalink":"http://yangxinqi.com/2018/02/06/将blog迁移到hexo了/","excerpt":"总是别人的好看东西总是别人的好，之前用的octopress搭建在github page上的notes，折腾了2回了，之前因为换了机器了之后，ruby的环境丢了，重新整了下。 换了下octopress的theme，然后一年才写了2-3篇，战斗力严重下降。最近一直在看不少技术者的blog，看他们写的都不错，都是使用hexo，所以查了下，hexo是重写过的，比起之前用ruby下的rake写的octopress，感觉看上去更好看一些，而且果然提供了很多的theme，感觉做的都很全也很漂亮。遂决定换到hexo了，用下来，感觉很方便，插件和风格也都很全。插件这块，看到大家加了打赏功能了，我也默默的给加上了，不知道后续会不会有人给我打赏呢，入乡随俗啊，感觉国内这块的风气这点还是比较好的。 写文章的人很多，而且知识付费的意识也起来了。","text":"总是别人的好看东西总是别人的好，之前用的octopress搭建在github page上的notes，折腾了2回了，之前因为换了机器了之后，ruby的环境丢了，重新整了下。 换了下octopress的theme，然后一年才写了2-3篇，战斗力严重下降。最近一直在看不少技术者的blog，看他们写的都不错，都是使用hexo，所以查了下，hexo是重写过的，比起之前用ruby下的rake写的octopress，感觉看上去更好看一些，而且果然提供了很多的theme，感觉做的都很全也很漂亮。遂决定换到hexo了，用下来，感觉很方便，插件和风格也都很全。插件这块，看到大家加了打赏功能了，我也默默的给加上了，不知道后续会不会有人给我打赏呢，入乡随俗啊，感觉国内这块的风气这点还是比较好的。 写文章的人很多，而且知识付费的意识也起来了。说到免费的https看到大家的个人域名都是使用https的，之前的github pages是不支持https绑定的，结果一查，发现cloudflare支持https的跳转，这块突然想到，其实他们就是拿到解析到自己的服务器，作为一个反向代理，在把后端的页面直接给返回就行，是能够实现https的，而且还是免费的，好吧，这里赞下cloudflare。美国的一些互联网公司的产品设计果然还是很赞的。复活yangxinqi.com去年忙活了一整年了，发现时间特别少，没有咋个动笔，2018也过去2个月了，今年目标每个月1-2篇文章吧。这点还是可以实现的，停下来总结总结，总比每天忙个不停要好的多。","categories":[{"name":"other","slug":"other","permalink":"http://yangxinqi.com/categories/other/"}],"tags":[{"name":"octopress, hexo, next theme","slug":"octopress-hexo-next-theme","permalink":"http://yangxinqi.com/tags/octopress-hexo-next-theme/"}]},{"title":"回顾2017","slug":"hui-gu-2017","date":"2018-02-03T14:11:27.000Z","updated":"2018-02-06T09:53:28.000Z","comments":true,"path":"2018/02/03/hui-gu-2017/","link":"","permalink":"http://yangxinqi.com/2018/02/03/hui-gu-2017/","excerpt":"回首2017年匆匆而过，回想下过去的一年，忙忙碌碌可始终还是两手空空，很充分的体会到初创公司，为之全力付出后商业模式无情的验证结果，一个公司是否能够赚钱，看结果就知道了。用几个数字概括下：开发了3个项目到上线举办了10场亿咖啡的线下活动投资了2家公司","text":"回首2017年匆匆而过，回想下过去的一年，忙忙碌碌可始终还是两手空空，很充分的体会到初创公司，为之全力付出后商业模式无情的验证结果，一个公司是否能够赚钱，看结果就知道了。用几个数字概括下：开发了3个项目到上线举办了10场亿咖啡的线下活动投资了2家公司敏捷开发实践从1月开始到6月，都在为了客户的项目，作一个工程师应该做的事情，每天加班的把客户安排的活给清理掉。转眼半年过去的很快。开发还是挺有意思的，新的敏捷模式 + 使用N多的外部服务，用极少的工程师和时间快速的实现出业务流程，这点真的体会到卢兄的这种技术管理的思想还是很值得学习的。在此感谢下卢兄。举办活动前半年活动也不少，弄了AI + 区块链的活动，吸引了不少朋友过来，也结交了很多新朋友。在日本IT这个闷的不行的地方，我们也算尽了一点点力吧。举办了10场活动，还是没有达到每月一场的目标，在这里感谢各位讲师，特别是王博士的AI基础普及课程。经历一场撕逼做为我们的客户，因为我们做了一个媒体的项目，居然过来要和我们撕逼，说我们也做了他们的行业，对于老熟人和创业者，心胸居然这么狭窄，这点让我比较难以接收，也撕逼了一场，不知道现在的项目还活着么？现在都记不起这个项目的名字了。投资一个新媒体项目为去年一起的项目启动了一个新媒体项目，投资人想打造一个类似今日头条一样的日本本地生活服务的APP，我们开发了个，但是陷入长期的没有推广的情况，体会到做一个项目容易，但是推广和坚持一个项目有多难。也体会到项目没有投入继续维持的痛苦。最终妥协了，团队成员都派遣了。做了最不想做却不得不做的事情项目失败，无力支撑公司的运转，进而把团队的兄弟们都放到现场去了。 为了维持我们也都没有办法，作为一个项目负责人，是大家的带头大哥，我也比较抱歉，对于未来如何，现在也无可知晓了。 派遣还在继续，事情还是得继续推动下去，团队散出去容易，回来相对还是挺难的。这块多亏了张总的照顾，在这里表示感谢。等的花儿都谢了的一年也没等到合伙人归来，作为一个单枪匹马的创业者，公司从多个股东干到就剩下一个，也是没有谁了。 这点现在看来还是很需要我们把事情干好的，对于一个烂摊子谁也不想出来收拾，当然对于一个没有未来感的公司，大家也都不想投入是一样的。这块我们应该如何来分清主次呢？ 孤独感和协作感很考验一个创始团队。合伙人之于家里是同等重要的。出走国内对于没有安全感的我来讲，坚持到最后也坚持不下去的情况下，选择一口饭吃成为排解公司危机的主要方式。在坚持不下去的时候，选择了冷冻，开拓新的战场，在国内AI蓬勃发展的时机，回来体验下这样紧密的加班开发的环境。 国内的公司的工作氛围和日本完全不同，经历过熟悉又陌生的工作及生活后，陷入迷茫，未来会是什么样的？其实国内之于日本没有好和不好之说，最关键的还是在一起做事情的人，国内优秀的人很多，优秀的公司也很多，其实相对于日本，竞争更为激烈，作为一个工程师需要做的事情更多。作为管理职位的人，需要发挥的更多，这块需要投入的也更多，不比自己创业付出的少，想成就一个伟大的事业，必须需要一个比较大的付出，其实如果只有一个目标，我们还是可以好好的来处理的。实战AI回国后的3个月，做了3个项目，上线1个，搁浅了2个，对于AI的初步认识以及实际使用有了一些更深入的了解。AI之于普通的企业来讲，还需要一个过程，但是降低成本提高效率这块，技术还是可以付出很多，有一定的提升空间。 在这边带的2个小朋友我也是刮目相看，这点真心的感觉不错，有些人战斗力爆棚，稍稍带下就可以发挥出来，有些人就不行了，上手很慢的说。结语一年在忙碌中匆匆而过，最对不起的还是儿子和女儿，暂时的分离只是为了将来更好的生活。2017年努力却没有什么回报，算账目是有盈余的，实际则不然，这也许就是商业的规则。作为局中人在没有退出时机的时候，剩下的只有投入，不断的投入。","categories":[{"name":"other","slug":"other","permalink":"http://yangxinqi.com/categories/other/"}],"tags":[]},{"title":"请停止无效努力","slug":"qing-ting-zhi-wu-xiao-nu-li","date":"2017-11-12T13:43:26.000Z","updated":"2018-02-06T09:53:22.000Z","comments":true,"path":"2017/11/12/qing-ting-zhi-wu-xiao-nu-li/","link":"","permalink":"http://yangxinqi.com/2017/11/12/qing-ting-zhi-wu-xiao-nu-li/","excerpt":"往往的往往，都是到最后的时间，开始做事情，几十年来依然是如此，从未改变过，为什么会这样呢？习惯吧，一个习惯的习惯，一直持续自己的各种做事方式，不尝试去改变自己，这样肯定是不行的说。休息了一天，其实呢，感触比较深的是，做公司做人都是一样，盈利的目的性太强了，这个看过去不是什么好事，前期野蛮生长是必须的，壮大之后，你可以考虑生态，考虑到大家的幸福指数，但是在一切未安定之前，很难做到这块。","text":"往往的往往，都是到最后的时间，开始做事情，几十年来依然是如此，从未改变过，为什么会这样呢？习惯吧，一个习惯的习惯，一直持续自己的各种做事方式，不尝试去改变自己，这样肯定是不行的说。休息了一天，其实呢，感触比较深的是，做公司做人都是一样，盈利的目的性太强了，这个看过去不是什么好事，前期野蛮生长是必须的，壮大之后，你可以考虑生态，考虑到大家的幸福指数，但是在一切未安定之前，很难做到这块。自我效能勤奋一直都很勤奋的，每天不浪费时间，每周也不浪费时间，每个月更是如此，各种杂事及各种开发任务，客户维系，现在静下来，好好的梳理下，其实发现，真心需要整理下，迫切需要停止掉无谓的勤奋，一直很努力，依旧很失败，这块也许是很多人的写照吧。团队找优秀的人，有优秀的人加盟，或者是一直培养，让她成长起来，这2种方式对于人，是应该如何衡量呢？人又有拼劲，又能和团队的其他人相处，又有很好的技术，又很有责任心，其实要求很多，大部分很难做到，哪怕是你的合作伙伴都是如此的说。 所以从自身的性格上来看，很难找到和你一起的付出而不图回报的人，随着年龄的增大，冲劲和抗风险的能力都在持续的下降，所以人还是很难能够一直一直的走下去，更是拼劲全力的一起走下去。所以心态上放开来，很多事情，都是可遇而不可求的，人生总是如此，好朋友和知己总是寥寥无几，能够一起奋斗的都是在少数，我不是一个好的商人，但是可以做一个好的朋友，虽然大家都是在道上，时间流逝，一切随缘。接下来，期望给自己找一个导师montor，急切需要一位人生导师，能够开导开导下，未来的方向在哪里？找一些死党，当你在怎么不行的时候，也有人能够帮助你，能够让你重新出发。财务避税及年金保险，国内的五险一金以及各种税务法务方面的事情，这块都需要特别的注意，关于公司的固定资产和固定支出，这块也需要强烈的关注下，对于初创公司来讲，房租成本和其他的成本及年金保险这块每个月需要交的都是挺多的。这块需要特别特别的注意，关注财务及正常的流水，保证正常的现金流，这块非常非常重要，这块特别要说到最推广预算方面，产品研发的水平可以控制，但是推广的成本很难控制住，所以提取做好预算是非常关键的。还有对接在线支付，当我们需要在网上的做支付方式的时候，这块尤为重要，对接上了之后，我们能够实现正向收入并使得产品可以运营起来。方向区块链，人工智能，机器学习，未来的方向是在哪里，我们需要在哪个领域内扎根，好好的运营3年，未来很快，现在的数据内容很多，我们如何来进行很好的定位及突破方向，这块非常的重要。选择一个好方向，现在如何金融领域深入，这块对我们来讲是一个很好的课题，金融领域结合人工智能及区块链技术，做一个稳定的定投产品出来。看好的方向及未来的发展，如何在方向压对上，赚到第一桶金，这块也非常的重要的说。资源先有的技术资源，各种外面已经做的很好的开源的项目及产品，我们都可以很好的用起来，虽然很多都需要另外付费的，有一些服务是能够长久使用的。能够拿到的宣传资源，合作资源，这块也是需要很好的去梳理去实现的。人脉如何认识和自己不是一个圈子的人，并把人脉维护好，需要跨界合作，现在花的时间还很少的说，这块需要强力的合作下。跨界的人脉多认识一些，下班时间，多出去聚聚喝喝酒，有自己的圈子还是得要的说，人脉圈子还是挺重要的。总结多出去走走，把时间用在对的地方，做对的决策。","categories":[{"name":"project","slug":"project","permalink":"http://yangxinqi.com/categories/project/"}],"tags":[]},{"title":"携程技术沙龙-人机智能交互AI与客服机器人-总结","slug":"xi-cheng-ji-zhu-sha-long-ren-ji-zhi-neng-jiao-hu-aiyu-ke-fu-ji-qi-ren-zong-jie","date":"2017-09-30T08:29:39.000Z","updated":"2018-02-06T06:04:18.000Z","comments":true,"path":"2017/09/30/xi-cheng-ji-zhu-sha-long-ren-ji-zhi-neng-jiao-hu-aiyu-ke-fu-ji-qi-ren-zong-jie/","link":"","permalink":"http://yangxinqi.com/2017/09/30/xi-cheng-ji-zhu-sha-long-ren-ji-zhi-neng-jiao-hu-aiyu-ke-fu-ji-qi-ren-zong-jie/","excerpt":"时间： 2017-09-23 上海 携程议题：人机智能交互AI与客服机器人PDF及录音：https://pan.baidu.com/s/1dFmzRxf 提取密码： vxxw （文件超过插入大小，放到百度网盘上了）第一讲：微软技术在客户中的应用- 微软 于辉第二讲：腾讯语音人工智能技术的应用 - 腾讯第四讲：UNIT：语言理解与交互艺术-百度孙珂这些偏广告方面，我们先给略过了，下面的三个session深入聊下。","text":"时间： 2017-09-23 上海 携程议题：人机智能交互AI与客服机器人PDF及录音：https://pan.baidu.com/s/1dFmzRxf 提取密码： vxxw （文件超过插入大小，放到百度网盘上了）第一讲：微软技术在客户中的应用- 微软 于辉第二讲：腾讯语音人工智能技术的应用 - 腾讯第四讲：UNIT：语言理解与交互艺术-百度孙珂这些偏广告方面，我们先给略过了，下面的三个session深入聊下。第三讲：携程AI平台及客服机器人-携程于磊第五讲：京东JIMI用户未来意图预测-京东邹波第六讲：深度学习在智能助理产品中的应用-来也胡一川第七讲：阿里小蜜-电商领域的智能助理技术实践-阿里陈海青总结携程：针对当前携程这边AI方面的工作，主要由公共BI部门来做，现在主要是于磊带领的部门的40-50个人的规模来做，支持携程的各大产品线。针对当前智能客服的开发进度情况现在还不太清除，实际商用到什么程度？小诗机主要用到了CNN，RNN， LSTM等各种算法，还调用了第三放的api来获取天气，季节等数据，最终通过LSTM模型来创作，这里着重提到了seq2seq和LSTM结合的方式。对于智能机器人方面，他们使用了检索 + 意图级别 + 命名实体识别 等方法结合等给出结果。 其中算法方面用到到挺多常用到算法，模块方面主要封装成对话管理，知识图谱和个性化推荐等，在上层封装成各种应用。京东：京东讲等相对比较细节一些，将他们现在做等进行了下总结，主要围绕客服咨询和问答的领域，通过清洗，聚类及特种提取，来提高准确度，他们主要用java方向的架构，spring batch还有mapreduce来做。基于用户的意图识别方面，也是用BaseLine，之后用LSTM + Attention的模式来提高预测准确率，这个方面提出率一些模型调优方面的一些经验，通过L2正则化，通过加大样本数量（100w条） ，加入Dropout机制，截断式反向传播，掩模和填令，学习率自动衰减 AdaGrad，权重初始化xavier ，优化方法 sgd/adagrad/momentum ,激活函数 softmax主要流程： 从数据源日志中– 》 分词，word2vec，去掉停用词，同义词替换，取中心词生成句子向量，聚类生成标准问题 –》 特征收集与建模 –》 建立分类模型来也：来也讲的也比较细节方面，主要是针对当前的问答进行技术的处理，从语意方向和问答，实体抽取和知识挖掘，意图识别来进行处理。 提到框架方面主要处理流程，embed (每个词或者句子映射为向量) –&gt; Encode（对一段文本对应的向量进行转换，转换时使用上下文信息，通常使用CNN，RNN –&gt; attend（从编码后的向量中提取对预测由价值的信息，输出为一个固定维度的向量）–&gt; predict（基于输入向量产出最终的预测） 。这里主要聊了下，他们的基于深度学习，完全数据驱动，无需特征工程，效果明显由于传统机器学习模型， 使用 双向LSTM + Attend + softmax 最终输出 意图识别结果，准确率达到95% ，这块有点夸张。阿里：阿里的团队比较完善，人也比较多，单单一个客服团队，就由50+的人在做这些， 而且整体系统上看过去做的时间比较就也比较全面，主要他们也是对用户对行为特征进行意图分类的预测。 他们主要结合用户行为序列与Query的意图识别分类，使用词袋 + RNN + CNN 等对文本进行embedding 然后在用DNN 2-channel 针对多标签进行分类。 他们的基于图谱与IR模型相结合的QA Bot 使用 文本预处理 + 分词处理 + 纠错， 基于 搜索召唤模块，从现有的结构化知识库中，通过语料索引构建的索引模块，检索，然后计算模块进行 相似度，情感分析，文本属性识别 等，然后组装答案，在给出回答。他们这块对于语义关系部分的自动挖掘，使用图算法来做， graph, aiml 来做意图关系及意图规则，最后生产特征， 也有通过分类，SM ,LDA2VC, cosine ,WMD 来做特征生成，这块看看由没有现成的我们可以使用的，业务这块特征抽取，目前占用了大量的人力和时间。后面他们做的，ai boost核心算法技术，主要是在 预处理和特征工程这块，句子向量，相似度计算，聚类等，通过场景及语料，对问题进行处理，而我们现在也比较关注用户回复的答案。后记整体主要了解了各大公司在AI语言处理方向及对话机器人方向，基于场景和领域下，技术，算法的使用以及处理的过程，各家公司做的粒度和广度都有差别，但是总体来看，我们能从这边看到算法及处理过程的，对于我们现在的实际进行中的项目还是有很大帮助的。","categories":[],"tags":[]},{"title":"机器学习入门","slug":"ji-qi-xue-xi-ru-men","date":"2017-07-02T15:03:55.000Z","updated":"2018-02-06T09:52:48.000Z","comments":true,"path":"2017/07/03/ji-qi-xue-xi-ru-men/","link":"","permalink":"http://yangxinqi.com/2017/07/03/ji-qi-xue-xi-ru-men/","excerpt":"AI的入门AI的概念越来越热，各大厂都在深入的使用AI技术来提高各自的业务水平，各种创业公司和团队都在使用这个技术，在东京这块也有很多的机器人公司在尝试使用这个技术来做一些新业务的尝试，自己也不能免俗的加入的AI开发者的行业。对于算法和机器学习都不精的情况下，其实面对应用场景和技术的匹配，还是很难判断，只能一步一步的跟进，从而在真正的产品中，能够把产品做出来，有实际使用才有话语权，也有投入能够把这块做的更好。机器学习的入门从AI到机器学习，其实感觉都没撒太大的区别，对于初学者来说，我们也表示下会一些CNN从而可以说明你会点机器学习吧，但是这块地算法真心的不少。移动设备机器学习的入门从图片做简单的分类，这个是现在常见的在做的部分，当然也是想在iOS和Android上使用这块地技术来做一些实践的产品。今天演示用的iOS代码在这里下载：https://github.com/xinqiyang/iOS-10-Sampler","text":"AI的入门AI的概念越来越热，各大厂都在深入的使用AI技术来提高各自的业务水平，各种创业公司和团队都在使用这个技术，在东京这块也有很多的机器人公司在尝试使用这个技术来做一些新业务的尝试，自己也不能免俗的加入的AI开发者的行业。对于算法和机器学习都不精的情况下，其实面对应用场景和技术的匹配，还是很难判断，只能一步一步的跟进，从而在真正的产品中，能够把产品做出来，有实际使用才有话语权，也有投入能够把这块做的更好。机器学习的入门从AI到机器学习，其实感觉都没撒太大的区别，对于初学者来说，我们也表示下会一些CNN从而可以说明你会点机器学习吧，但是这块地算法真心的不少。移动设备机器学习的入门从图片做简单的分类，这个是现在常见的在做的部分，当然也是想在iOS和Android上使用这块地技术来做一些实践的产品。今天演示用的iOS代码在这里下载：https://github.com/xinqiyang/iOS-10-Sampler做个PPT自己学习下投入的时间不够，只能在现在业务繁忙的情况下，多投入一些时间来吧这块事情做好。就做一个PPT做一个session，这样有自学有交流，这样能够学习到更多。下载地址：http://yangxinqi.com/images/machine_learning_in_mobile.pdf最后攒钱买机器最后还是花钱去搞了一台机器了，开始AI的模型训练之旅了。精彩在最后在接近尾声的时候，从讨论中擦出了火花，过来的周兄是移动方面的大牛，给了不少推荐，最后有乐天的任兄给我们聊了下机器学习在金融方面的应用，顿时大家兴趣备至啊，终于有和钱相关的话题了，虽然现在还是半自动的，虽然现在AI还只是能给出建议，但是在很多的方面已经能够直接商用了，说明这个方向在未来的2-3年内应该还是很热门的。","categories":[{"name":"ai","slug":"ai","permalink":"http://yangxinqi.com/categories/ai/"}],"tags":[]},{"title":"三年之后","slug":"san-nian-zhi-hou","date":"2017-04-30T15:36:11.000Z","updated":"2018-02-06T09:52:52.000Z","comments":true,"path":"2017/05/01/san-nian-zhi-hou/","link":"","permalink":"http://yangxinqi.com/2017/05/01/san-nian-zhi-hou/","excerpt":"","text":"三年之后“三年后又三年，就快10年了，老大!” — 这个没记错的话，应该是无间道里面梁朝伟饰演的陈永仁说的。今天是从正式创立公司满三年的子，三年前的今天决心了出来做一个属于自己的公司，有一个梦想，想弯道超车，但是就现在的结果来看，很多时候都未能如愿。商场上的挣扎，和作为程序员本身的基本追求，又有着很大的冲突。庆幸我们现在还活着，庆幸现在还没有放弃。虽然现在大部分的时间不属于自己，但是整体拼杀过来，有一个小小的团队，还是有可能的。尽人事，听天命，掌握好时间，做好自己该做的事情。下一个三年，还在等着，希望十年后的今天，在来回首看，会感谢现在努力拼搏的自己。","categories":[{"name":"other","slug":"other","permalink":"http://yangxinqi.com/categories/other/"}],"tags":[]},{"title":"时间管理和情绪管理","slug":"shi-jian-guan-li-he-qing-xu-guan-li","date":"2017-03-17T03:33:42.000Z","updated":"2018-02-06T09:53:00.000Z","comments":true,"path":"2017/03/17/shi-jian-guan-li-he-qing-xu-guan-li/","link":"","permalink":"http://yangxinqi.com/2017/03/17/shi-jian-guan-li-he-qing-xu-guan-li/","excerpt":"好死不如赖活着活着讲究的是一种境界，死了一切就扯淡了。有的时候发现，有品节的去死不如好好的活着，其实很多时候大中华民族的气节也是这样的，所以面对现在的种种历史问题，新一代的人总是一直的去回避，我们都躲的远远的这样就能规避掉这个问题了。想要赖活着，这样的状态下，面对生活，必须有自己的时间管理和情绪管理的心态，不然还是做不到的，人改变自己的劣根性是很难的，我们自己改下自己的行为习惯就更难了。自创业以来，自己就像一个陀螺一样，转的停不下来，N个项目，N个ticket需要去处理，可是时间总是那么那么的平凡，就是这么的24小时。","text":"好死不如赖活着活着讲究的是一种境界，死了一切就扯淡了。有的时候发现，有品节的去死不如好好的活着，其实很多时候大中华民族的气节也是这样的，所以面对现在的种种历史问题，新一代的人总是一直的去回避，我们都躲的远远的这样就能规避掉这个问题了。想要赖活着，这样的状态下，面对生活，必须有自己的时间管理和情绪管理的心态，不然还是做不到的，人改变自己的劣根性是很难的，我们自己改下自己的行为习惯就更难了。自创业以来，自己就像一个陀螺一样，转的停不下来，N个项目，N个ticket需要去处理，可是时间总是那么那么的平凡，就是这么的24小时。改变应该从时间管理开始时间及事情的优先级总是这样的，然后协调的好不好，其实重在自己的心态，活都是那么多，愉快的干完和痛苦的干完，心态是完全不一样的，就送你拼尽全力，好多的活还是那些，我们很难能够都面面俱到的处理好。到这个月过完，创业三周年即将到来，一直没有时间回首复盘下这3年来自己走过的这一切。看到朋友们的生活，其实3年就可以变很多，现在没有变的是，3年来一直维持着自己的公司，走走停停，好歹还活着吧。 所以解放是很关键的，搞来搞去，不能老是在高压的状态下，面对时间，还有外界的压力，应该用自己的节奏去控制它，而不应该是被别人所控制。1.周末的休息是必须的，平日的加班是要有效率的​ 看到很多团队，周末一直在加班，一直在高压的状态，而且持续好几个月，而且经常出现，这个创业团队里面也比较常见，体会过来感觉真的挺没有必要的，技能重在积累，做为一个商业模式必须考虑盈利。 所以留给自己一个充裕的时间，能更有效的来思考。在加上现在有了孩子，更需要多抽时间来陪他了。​ 平日的加班，其实多数情况下是无效率的，经历下来好多时候都没有啥用，项目在最后的关头，才开始努力的去面对之前未完成的功能，靠加人和加班都是于事无补的感觉，现在来看还是比较难以见效。 所以加班不可避免的要解决问题的情况下，还不如第二天清醒的来快速解决。2. 团队管理上时间的分配和协调​ 团队开发，在最后都要避免加班，用一个已经磨合好的团队，做事情自然会快一些，用google日历来管理，大家的每个工作时间，精确到半个小时，效率就自然能上来的了，其次是给大家一些反馈，对于现在存在的问题能够尽快的沟通，当面沟通比聊天来的好，自然就能有效率了。情绪管理不淡定的情况下如何淡定自己挖的坑自己填，做错的事情，下次不要在犯错，现在的情况下大家都是这么来处理的。 但是在好多达不到自己的标准下，还是很难的在这个问题上达成一致。找个不伤害人的方式发泄吧。还是得发泄掉就好了。当心情极度不佳的时候，如何控制好情绪很关键！无法两全的情况下，只能选择一个了，做好自己认为的最重要的一个很关键，为自己活一回，还是想为自己而站，这也是一直以来自己的理想。想想自己，想想自己要做的就好了。扯到底，扯好了，好吧，扯好了，开始干活去！","categories":[{"name":"other","slug":"other","permalink":"http://yangxinqi.com/categories/other/"}],"tags":[]},{"title":"xinqiyang复活","slug":"xinqiyangfu-huo","date":"2017-02-20T10:47:09.000Z","updated":"2018-02-06T09:53:04.000Z","comments":true,"path":"2017/02/20/xinqiyangfu-huo/","link":"","permalink":"http://yangxinqi.com/2017/02/20/xinqiyangfu-huo/","excerpt":"","text":"复活好久以来一直想复活下yangxinqi.com，今天终于买下来了，一看断断续续，从13年之后，来了日本之后就没在咋个写过Blog了，来日本确实是另外一番景象，快5年了，想找回曾经的那个自己，遂又开始写博，对于创业将近3年的老油条来讲，这一路走来的一幕幕，急需复盘，有时候走累了停一停，整理整理思路。好吧，给自己一个新的开始，复活, 把blog放到github上，github还是很靠谱的，在有生之年应该都还在吧这个判断应该是对的。分享出去，为了每篇文章的美观，后续我都会加上图片的：","categories":[{"name":"other","slug":"other","permalink":"http://yangxinqi.com/categories/other/"}],"tags":[]}]}